{"ast":null,"code":"var _jsxFileName = \"/home/anasbouzid/code-projects/streamlit/custom-components/CodeEditor/code_editor/frontend/src/editor.tsx\",\n  _s = $RefreshSig$();\nimport { useEffect } from \"react\";\nimport AceEditor from \"react-ace\";\nimport ace from \"ace-builds\";\nimport \"ace-builds/webpack-resolver\";\nimport \"ace-builds/src-noconflict/mode-python\";\nimport \"ace-builds/src-noconflict/mode-javascript\";\nimport \"ace-builds/src-noconflict/ext-language_tools\";\nimport \"ace-builds/src-noconflict/ext-searchbox\";\nimport \"ace-builds/src-noconflict/ext-prompt\";\nimport \"ace-builds/src-noconflict/ext-modelist\";\nimport \"ace-builds/src-noconflict/ext-keybinding_menu\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const Editor = _ref => {\n  _s();\n  let {\n    lang,\n    theme,\n    shortcuts,\n    props,\n    snippets,\n    commands,\n    editorRef,\n    code,\n    onChange\n  } = _ref;\n  /**\n  * This function takes as input either a snippetText string that is expected\n  * to be already formatted like the text in a SnippetFile or a dictionary or \n  * and array of dictionaries. For the first case, it just returns the input.\n  * For the second and third case, a (SnippetFile format) string is constructed\n  * from the dict(s) and returned. Learn more about snippets {@link  here}\n  * @param snippetRaw snippets to be converted to a single snippetText string\n  * @returns {string} snippetText\n  */\n  const createSnippets = snippetRaw => {\n    return typeof snippetRaw === \"string\" ? snippetRaw : (Array.isArray(snippetRaw) ? snippetRaw : [snippetRaw]).map(_ref2 => {\n      let {\n        name,\n        code\n      } = _ref2;\n      return ['snippet ' + name, code.split('\\n').map(c => '\\t' + c).join('\\n')].join('\\n');\n    }).join('\\n');\n  };\n  useEffect(() => {\n    console.log(\"~~~~~ useEffect inside Editor ~~~~~\");\n    //console.log(aceEditor.current?.editor);\n    if (editorRef.current) {\n      var _editorRef$current, _editorRef$current2;\n      ace.require(\"ace/ext/keybinding_menu\").init((_editorRef$current = editorRef.current) === null || _editorRef$current === void 0 ? void 0 : _editorRef$current.editor);\n      console.log((_editorRef$current2 = editorRef.current) === null || _editorRef$current2 === void 0 ? void 0 : _editorRef$current2.editor);\n      const snips = createSnippets(snippets);\n      if (snips) {\n        const snippetManager = ace.require('ace/snippets').snippetManager;\n\n        //// The function getMode() returns an Ace.SyntaxId object that\n        //// has no way to get or access its $id variable. So the following\n        //// doesnt work:\n        //const id = editor.session.getMode().$id;\n\n        //// The current workaround used here is to recognize that when the \n        //// editorRef mode prop is set with a string (ex: mode=\"python\"), it  \n        //// constructs the mode id as follows: setMode(`ace/mode/${mode}`)\n        //const id = `ace/mode/${this.state.lang}`;\n\n        snippetManager.register(snippetManager.parseSnippetFile(snips, lang), lang);\n        console.log(JSON.stringify(snips));\n      } else {\n        console.log(\"Cannot register snippets: check format of snippets\");\n      }\n    } else {\n      console.log(\"No editor to register snippets to\");\n    }\n    return () => {\n      console.log(\"Editor unmounted*********\");\n    };\n  }, [snippets]);\n  return /*#__PURE__*/_jsxDEV(AceEditor, {\n    ref: editorRef,\n    name: \"REACT_ACE_EDITOR\",\n    mode: lang,\n    theme: theme,\n    value: code,\n    keyboardHandler: shortcuts,\n    commands: commands,\n    onChange: onChange,\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 84,\n    columnNumber: 13\n  }, this);\n};\n_s(Editor, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c = Editor;\nvar _c;\n$RefreshReg$(_c, \"Editor\");","map":{"version":3,"names":["useEffect","AceEditor","ace","Editor","lang","theme","shortcuts","props","snippets","commands","editorRef","code","onChange","createSnippets","snippetRaw","Array","isArray","map","name","split","c","join","console","log","current","require","init","editor","snips","snippetManager","register","parseSnippetFile","JSON","stringify"],"sources":["/home/anasbouzid/code-projects/streamlit/custom-components/CodeEditor/code_editor/frontend/src/editor.tsx"],"sourcesContent":["import { useEffect} from \"react\"\nimport AceEditor from \"react-ace\";\nimport ace from \"ace-builds\";\n\nimport \"ace-builds/webpack-resolver\";\nimport \"ace-builds/src-noconflict/mode-python\";\nimport \"ace-builds/src-noconflict/mode-javascript\";\nimport \"ace-builds/src-noconflict/ext-language_tools\";\nimport \"ace-builds/src-noconflict/ext-searchbox\";\nimport \"ace-builds/src-noconflict/ext-prompt\";\nimport \"ace-builds/src-noconflict/ext-modelist\";\nimport \"ace-builds/src-noconflict/ext-keybinding_menu\";\n\n\nexport type EditorProps = {\n    code: string,\n    lang: string,\n    theme: string,\n    shortcuts: string,\n    props: any,\n    editorRef: any,\n    snippets: string | object | object[],\n    commands: object,\n    onChange: (value: string, event?: any) => void \n  }\n  \nexport const Editor = ({ lang, theme, shortcuts, props, snippets, commands, editorRef, code, onChange }: EditorProps ) => {\n  \n      /**\n    * This function takes as input either a snippetText string that is expected\n    * to be already formatted like the text in a SnippetFile or a dictionary or \n    * and array of dictionaries. For the first case, it just returns the input.\n    * For the second and third case, a (SnippetFile format) string is constructed\n    * from the dict(s) and returned. Learn more about snippets {@link  here}\n    * @param snippetRaw snippets to be converted to a single snippetText string\n    * @returns {string} snippetText\n    */\n      const createSnippets = (snippetRaw: string | object | [object]): string => {\n        return (typeof snippetRaw === \"string\" ? snippetRaw : (Array.isArray(snippetRaw) ? snippetRaw : [snippetRaw]).map(({ name, code }) =>\n        ([\n          'snippet ' + name,\n          code.split('\\n')\n            .map((c: string) => '\\t' + c)\n            .join('\\n'),\n        ].join('\\n'))\n        ).join('\\n'))\n      }\n    \n      useEffect(() => {\n        console.log(\"~~~~~ useEffect inside Editor ~~~~~\");\n        //console.log(aceEditor.current?.editor);\n        if(editorRef.current){\n          ace.require(\"ace/ext/keybinding_menu\").init(editorRef.current?.editor);\n          console.log(editorRef.current?.editor);\n    \n          const snips = createSnippets(snippets);\n          if(snips){\n            const snippetManager = ace.require('ace/snippets').snippetManager;\n    \n            //// The function getMode() returns an Ace.SyntaxId object that\n            //// has no way to get or access its $id variable. So the following\n            //// doesnt work:\n            //const id = editor.session.getMode().$id;\n    \n            //// The current workaround used here is to recognize that when the \n            //// editorRef mode prop is set with a string (ex: mode=\"python\"), it  \n            //// constructs the mode id as follows: setMode(`ace/mode/${mode}`)\n            //const id = `ace/mode/${this.state.lang}`;\n    \n            snippetManager.register(snippetManager.parseSnippetFile(snips, lang), lang)\n            console.log(JSON.stringify(snips))\n          } else {\n            console.log(\"Cannot register snippets: check format of snippets\");\n          }\n        } else {\n          console.log(\"No editor to register snippets to\");\n        }\n  \n        return () => {console.log(\"Editor unmounted*********\")}\n  \n      }, [snippets]);\n  \n    return (\n            <AceEditor\n            ref={editorRef}\n            name=\"REACT_ACE_EDITOR\"\n            mode={lang}\n            theme={theme}\n            value={code}\n            keyboardHandler={shortcuts}\n            commands={commands}\n            onChange={onChange}\n            {...props} />\n    );\n  };"],"mappings":";;AAAA,SAASA,SAAS,QAAO,OAAO;AAChC,OAAOC,SAAS,MAAM,WAAW;AACjC,OAAOC,GAAG,MAAM,YAAY;AAE5B,OAAO,6BAA6B;AACpC,OAAO,uCAAuC;AAC9C,OAAO,2CAA2C;AAClD,OAAO,8CAA8C;AACrD,OAAO,yCAAyC;AAChD,OAAO,sCAAsC;AAC7C,OAAO,wCAAwC;AAC/C,OAAO,+CAA+C;AAAC;AAevD,OAAO,MAAMC,MAAM,GAAG,QAAoG;EAAA;EAAA,IAAnG;IAAEC,IAAI;IAAEC,KAAK;IAAEC,SAAS;IAAEC,KAAK;IAAEC,QAAQ;IAAEC,QAAQ;IAAEC,SAAS;IAAEC,IAAI;IAAEC;EAAsB,CAAC;EAE9G;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACM,MAAMC,cAAc,GAAIC,UAAsC,IAAa;IACzE,OAAQ,OAAOA,UAAU,KAAK,QAAQ,GAAGA,UAAU,GAAG,CAACC,KAAK,CAACC,OAAO,CAACF,UAAU,CAAC,GAAGA,UAAU,GAAG,CAACA,UAAU,CAAC,EAAEG,GAAG,CAAC;MAAA,IAAC;QAAEC,IAAI;QAAEP;MAAK,CAAC;MAAA,OAChI,CACC,UAAU,GAAGO,IAAI,EACjBP,IAAI,CAACQ,KAAK,CAAC,IAAI,CAAC,CACbF,GAAG,CAAEG,CAAS,IAAK,IAAI,GAAGA,CAAC,CAAC,CAC5BC,IAAI,CAAC,IAAI,CAAC,CACd,CAACA,IAAI,CAAC,IAAI,CAAC;IAAA,CAAC,CACZ,CAACA,IAAI,CAAC,IAAI,CAAC;EACd,CAAC;EAEDrB,SAAS,CAAC,MAAM;IACdsB,OAAO,CAACC,GAAG,CAAC,qCAAqC,CAAC;IAClD;IACA,IAAGb,SAAS,CAACc,OAAO,EAAC;MAAA;MACnBtB,GAAG,CAACuB,OAAO,CAAC,yBAAyB,CAAC,CAACC,IAAI,uBAAChB,SAAS,CAACc,OAAO,uDAAjB,mBAAmBG,MAAM,CAAC;MACtEL,OAAO,CAACC,GAAG,wBAACb,SAAS,CAACc,OAAO,wDAAjB,oBAAmBG,MAAM,CAAC;MAEtC,MAAMC,KAAK,GAAGf,cAAc,CAACL,QAAQ,CAAC;MACtC,IAAGoB,KAAK,EAAC;QACP,MAAMC,cAAc,GAAG3B,GAAG,CAACuB,OAAO,CAAC,cAAc,CAAC,CAACI,cAAc;;QAEjE;QACA;QACA;QACA;;QAEA;QACA;QACA;QACA;;QAEAA,cAAc,CAACC,QAAQ,CAACD,cAAc,CAACE,gBAAgB,CAACH,KAAK,EAAExB,IAAI,CAAC,EAAEA,IAAI,CAAC;QAC3EkB,OAAO,CAACC,GAAG,CAACS,IAAI,CAACC,SAAS,CAACL,KAAK,CAAC,CAAC;MACpC,CAAC,MAAM;QACLN,OAAO,CAACC,GAAG,CAAC,oDAAoD,CAAC;MACnE;IACF,CAAC,MAAM;MACLD,OAAO,CAACC,GAAG,CAAC,mCAAmC,CAAC;IAClD;IAEA,OAAO,MAAM;MAACD,OAAO,CAACC,GAAG,CAAC,2BAA2B,CAAC;IAAA,CAAC;EAEzD,CAAC,EAAE,CAACf,QAAQ,CAAC,CAAC;EAEhB,oBACQ,QAAC,SAAS;IACV,GAAG,EAAEE,SAAU;IACf,IAAI,EAAC,kBAAkB;IACvB,IAAI,EAAEN,IAAK;IACX,KAAK,EAAEC,KAAM;IACb,KAAK,EAAEM,IAAK;IACZ,eAAe,EAAEL,SAAU;IAC3B,QAAQ,EAAEG,QAAS;IACnB,QAAQ,EAAEG,QAAS;IAAA,GACfL;EAAK;IAAA;IAAA;IAAA;EAAA,QAAI;AAEvB,CAAC;AAAC,GApESJ,MAAM;AAAA,KAANA,MAAM;AAAA;AAAA"},"metadata":{},"sourceType":"module"}