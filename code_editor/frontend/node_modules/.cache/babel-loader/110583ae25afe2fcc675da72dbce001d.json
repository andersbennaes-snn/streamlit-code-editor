{"ast":null,"code":"var _jsxFileName = \"/mnt/c/Users/anasb/Google Drive/Colab Notebooks/streamlit/custom-components/CodeEditor/my_component/frontend/src/MyComponent.tsx\";\nimport { StreamlitComponentBase, withStreamlitConnection } from \"streamlit-component-lib\";\nimport React, { createRef } from \"react\";\nimport AceEditor from \"react-ace\";\nimport styled from \"styled-components\";\nimport \"ace-builds/src-noconflict/mode-python\";\nimport \"ace-builds/src-noconflict/theme-one_dark\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n// /** Focus handler for our \"Click Me!\" button. */\n// function onChange(value: string, event?: any){\n//   console.log(\"change\", value);\n// }\n\n/**\n * This is a React-based component template. The `render()` function is called\n * automatically when your component should be re-rendered.\n */\nclass MyComponent extends StreamlitComponentBase {\n  constructor() {\n    super(...arguments);\n    this.state = {\n      numClicks: 0,\n      isFocused: false\n    };\n    this.aceEditor = createRef;\n    this.render = () => {\n      // Arguments that are passed to the plugin in Python are accessible\n      // via `this.props.args`. Here, we access the \"name\" arg.\n      const name = this.props.args[\"name\"];\n\n      // Streamlit sends us a theme object via props that we can use to ensure\n      // that our component has visuals that match the active theme in a\n      // streamlit app.\n      const {\n        theme\n      } = this.props;\n      const style = {};\n\n      // // Maintain compatibility with older versions of Streamlit that don't send\n      // // a theme object.\n      // if (theme) {\n      //   // Use the theme object to style our button border. Alternatively, the\n      //   // theme style is defined in CSS vars.\n      //   const borderStyling = `1px solid ${\n      //     this.state.isFocused ? theme.primaryColor : \"gray\"\n      //   }`\n      //   style.border = borderStyling\n      //   style.outline = borderStyling\n      // }\n\n      console.log(\"render\");\n      const StyledCodeEditor = styled.div(_ref => {\n        let {\n          theme\n        } = _ref;\n        return {\n          height: \"5rem\",\n          borderRadius: \"4px\"\n        };\n      });\n\n      // const Editor = (props) => {\n      //   const aceEditor = this.refs;\n      //   [selectedText, setSelectedText] = useState(\"\")\n\n      //   function onChange(newValue){\n      //       console.log(aceEditor.current.editor.getSelectionRange().start.row + 1)\n      //   }\n\n      //   function onSelection(selection) {\n      //           const selected = aceEditor.current.editor.getSelectedText();\n      //           setSelectedValue(selected);  \n      //   }\n\n      //   function handleCursorChange (event) { \n      //           const line = aceEditor.current.editor.getSelectionRange().start.row + 1;\n      //           console.log(line);\n      //   }\n      // }\n\n      // Show a button and some text.\n      // When the button is clicked, we'll increment our \"numClicks\" state\n      // variable, and send its new value back to Streamlit, where it'll\n      // be available to the Python program.\n      return /*#__PURE__*/_jsxDEV(StyledCodeEditor, {\n        children: /*#__PURE__*/_jsxDEV(AceEditor, {\n          ref: this.aceEditor,\n          mode: \"python\",\n          theme: \"one_dark\"\n          // onChange={onChange}\n          // onSelectionChange={onSelection}              /*selectiongchange event*/\n          // onCursorChange={handleCursorChange} \n          ,\n          name: \"UNIQUE_ID_OF_DIV\",\n          editorProps: {\n            $blockScrolling: true\n          },\n          setOptions: {\n            maxLines: 10,\n            minLines: 10,\n            fontSize: \"1rem\",\n            cursorStyle: \"smooth\",\n            highlightActiveLine: true,\n            showPrintMargin: false,\n            showLineNumbers: false,\n            foldStyle: \"markbegin\",\n            enableLiveAutocompletion: true,\n            enableSnippets: true\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 87,\n          columnNumber: 9\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 86,\n        columnNumber: 7\n      }, this);\n    };\n  }\n  componentDidMount() {\n    console.log(\"mounted\");\n    //this.setState({code: this.props.args[\"code\"]});\n    super.componentDidMount();\n  }\n  componentDidUpdate() {\n    console.log(\"updated\");\n    console.log(this.aceEditor);\n    // this.aceEditor.current.editor.renderer.setScrollMargin(10, 10, 0, 0);\n    // this.aceEditor.current.editor.container.style.lineHeight = \"1.5rem\";\n    // this.aceEditor.current.editor.renderer.updateFontSize();\n\n    super.componentDidUpdate();\n  }\n}\n\n//==========================================================================\n// Extra snippets of code\n//   /** Blur handler for our \"Click Me!\" button. */\n//   private _onBlur = (): void => {\n//     this.setState({ isFocused: false })\n//   }\n// }\n\n// /** Click handler for our \"Click Me!\" button. */\n// private onClicked = (): void => {\n//   // Increment state.numClicks, and pass the new value back to\n//   // Streamlit via `Streamlit.setComponentValue`.\n//   this.setState(\n//     prevState => ({ numClicks: prevState.numClicks + 1 }),\n//     () => Streamlit.setComponentValue(this.state.numClicks)\n//   )\n// }\n\n// \"withStreamlitConnection\" is a wrapper function. It bootstraps the\n// connection between your component and the Streamlit app, and handles\n// passing arguments from Python -> Component.\n//\n// You don't need to edit withStreamlitConnection (but you're welcome to!).\n\nexport default _c = withStreamlitConnection(MyComponent);\nvar _c;\n$RefreshReg$(_c, \"%default%\");","map":{"version":3,"names":["StreamlitComponentBase","withStreamlitConnection","React","createRef","AceEditor","styled","MyComponent","state","numClicks","isFocused","aceEditor","render","name","props","args","theme","style","console","log","StyledCodeEditor","div","height","borderRadius","$blockScrolling","maxLines","minLines","fontSize","cursorStyle","highlightActiveLine","showPrintMargin","showLineNumbers","foldStyle","enableLiveAutocompletion","enableSnippets","componentDidMount","componentDidUpdate"],"sources":["/mnt/c/Users/anasb/Google Drive/Colab Notebooks/streamlit/custom-components/CodeEditor/my_component/frontend/src/MyComponent.tsx"],"sourcesContent":["import {\n  Streamlit,\n  StreamlitComponentBase,\n  withStreamlitConnection,\n} from \"streamlit-component-lib\"\nimport React, { ReactNode , createRef} from \"react\"\nimport AceEditor from \"react-ace\";\n\nimport styled from \"styled-components\"\n\nimport \"ace-builds/src-noconflict/mode-python\";\nimport \"ace-builds/src-noconflict/theme-one_dark\";\n\ninterface State {\n  numClicks: number\n  isFocused: boolean\n}\n\n// /** Focus handler for our \"Click Me!\" button. */\n// function onChange(value: string, event?: any){\n//   console.log(\"change\", value);\n// }\n\n/**\n * This is a React-based component template. The `render()` function is called\n * automatically when your component should be re-rendered.\n */\nclass MyComponent extends StreamlitComponentBase<State> {\n  public state = { numClicks: 0, isFocused: false }\n\n   aceEditor = createRef<AceEditor>\n\n  public render = (): ReactNode => {\n    // Arguments that are passed to the plugin in Python are accessible\n    // via `this.props.args`. Here, we access the \"name\" arg.\n    const name = this.props.args[\"name\"]\n\n    // Streamlit sends us a theme object via props that we can use to ensure\n    // that our component has visuals that match the active theme in a\n    // streamlit app.\n    const { theme } = this.props\n    const style: React.CSSProperties = {}\n\n    // // Maintain compatibility with older versions of Streamlit that don't send\n    // // a theme object.\n    // if (theme) {\n    //   // Use the theme object to style our button border. Alternatively, the\n    //   // theme style is defined in CSS vars.\n    //   const borderStyling = `1px solid ${\n    //     this.state.isFocused ? theme.primaryColor : \"gray\"\n    //   }`\n    //   style.border = borderStyling\n    //   style.outline = borderStyling\n    // }\n\n    console.log(\"render\");\n    const StyledCodeEditor = styled.div(({ theme }) => ({\n      height: \"5rem\",\n      borderRadius: \"4px\"\n    }))\n\n    // const Editor = (props) => {\n    //   const aceEditor = this.refs;\n    //   [selectedText, setSelectedText] = useState(\"\")\n      \n    //   function onChange(newValue){\n    //       console.log(aceEditor.current.editor.getSelectionRange().start.row + 1)\n    //   }\n\n    //   function onSelection(selection) {\n    //           const selected = aceEditor.current.editor.getSelectedText();\n    //           setSelectedValue(selected);  \n    //   }\n      \n    //   function handleCursorChange (event) { \n    //           const line = aceEditor.current.editor.getSelectionRange().start.row + 1;\n    //           console.log(line);\n    //   }\n    // }\n\n    // Show a button and some text.\n    // When the button is clicked, we'll increment our \"numClicks\" state\n    // variable, and send its new value back to Streamlit, where it'll\n    // be available to the Python program.\n    return (\n      <StyledCodeEditor>\n        <AceEditor\n          ref={this.aceEditor}\n          mode=\"python\"\n          theme=\"one_dark\"\n          // onChange={onChange}\n          // onSelectionChange={onSelection}              /*selectiongchange event*/\n          // onCursorChange={handleCursorChange} \n          name=\"UNIQUE_ID_OF_DIV\"\n          editorProps={{ $blockScrolling: true }}\n          setOptions={{\n            maxLines: 10,\n            minLines: 10, \n            fontSize: \"1rem\",\n            cursorStyle: \"smooth\",\n            highlightActiveLine: true,\n            showPrintMargin: false,\n            showLineNumbers: false,\n            foldStyle: \"markbegin\",\n            enableLiveAutocompletion: true,\n            enableSnippets: true\n          }}\n        />\n      </StyledCodeEditor>\n    )\n  }\n\n  public componentDidMount(): void {\n    console.log(\"mounted\");\n    //this.setState({code: this.props.args[\"code\"]});\n      super.componentDidMount();\n  }\n  \n  public componentDidUpdate(): void {\n    console.log(\"updated\");\n    console.log(this.aceEditor)\n    // this.aceEditor.current.editor.renderer.setScrollMargin(10, 10, 0, 0);\n\t\t// this.aceEditor.current.editor.container.style.lineHeight = \"1.5rem\";\n\t\t// this.aceEditor.current.editor.renderer.updateFontSize();\n\n    super.componentDidUpdate();\n  }\n  \n}\n\n  //==========================================================================\n  // Extra snippets of code\n  //   /** Blur handler for our \"Click Me!\" button. */\n  //   private _onBlur = (): void => {\n  //     this.setState({ isFocused: false })\n  //   }\n  // }\n  \n    // /** Click handler for our \"Click Me!\" button. */\n    // private onClicked = (): void => {\n    //   // Increment state.numClicks, and pass the new value back to\n    //   // Streamlit via `Streamlit.setComponentValue`.\n    //   this.setState(\n    //     prevState => ({ numClicks: prevState.numClicks + 1 }),\n    //     () => Streamlit.setComponentValue(this.state.numClicks)\n    //   )\n    // }\n  \n// \"withStreamlitConnection\" is a wrapper function. It bootstraps the\n// connection between your component and the Streamlit app, and handles\n// passing arguments from Python -> Component.\n//\n// You don't need to edit withStreamlitConnection (but you're welcome to!).\n\nexport default withStreamlitConnection(MyComponent)"],"mappings":";AAAA,SAEEA,sBAAsB,EACtBC,uBAAuB,QAClB,yBAAyB;AAChC,OAAOC,KAAK,IAAgBC,SAAS,QAAO,OAAO;AACnD,OAAOC,SAAS,MAAM,WAAW;AAEjC,OAAOC,MAAM,MAAM,mBAAmB;AAEtC,OAAO,uCAAuC;AAC9C,OAAO,0CAA0C;AAAC;AAOlD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAMC,WAAW,SAASN,sBAAsB,CAAQ;EAAA;IAAA;IAAA,KAC/CO,KAAK,GAAG;MAAEC,SAAS,EAAE,CAAC;MAAEC,SAAS,EAAE;IAAM,CAAC;IAAA,KAEhDC,SAAS,GAAGP,SAAS;IAAA,KAEfQ,MAAM,GAAG,MAAiB;MAC/B;MACA;MACA,MAAMC,IAAI,GAAG,IAAI,CAACC,KAAK,CAACC,IAAI,CAAC,MAAM,CAAC;;MAEpC;MACA;MACA;MACA,MAAM;QAAEC;MAAM,CAAC,GAAG,IAAI,CAACF,KAAK;MAC5B,MAAMG,KAA0B,GAAG,CAAC,CAAC;;MAErC;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;;MAEAC,OAAO,CAACC,GAAG,CAAC,QAAQ,CAAC;MACrB,MAAMC,gBAAgB,GAAGd,MAAM,CAACe,GAAG,CAAC;QAAA,IAAC;UAAEL;QAAM,CAAC;QAAA,OAAM;UAClDM,MAAM,EAAE,MAAM;UACdC,YAAY,EAAE;QAChB,CAAC;MAAA,CAAC,CAAC;;MAEH;MACA;MACA;;MAEA;MACA;MACA;;MAEA;MACA;MACA;MACA;;MAEA;MACA;MACA;MACA;MACA;;MAEA;MACA;MACA;MACA;MACA,oBACE,QAAC,gBAAgB;QAAA,uBACf,QAAC,SAAS;UACR,GAAG,EAAE,IAAI,CAACZ,SAAU;UACpB,IAAI,EAAC,QAAQ;UACb,KAAK,EAAC;UACN;UACA;UACA;UAAA;UACA,IAAI,EAAC,kBAAkB;UACvB,WAAW,EAAE;YAAEa,eAAe,EAAE;UAAK,CAAE;UACvC,UAAU,EAAE;YACVC,QAAQ,EAAE,EAAE;YACZC,QAAQ,EAAE,EAAE;YACZC,QAAQ,EAAE,MAAM;YAChBC,WAAW,EAAE,QAAQ;YACrBC,mBAAmB,EAAE,IAAI;YACzBC,eAAe,EAAE,KAAK;YACtBC,eAAe,EAAE,KAAK;YACtBC,SAAS,EAAE,WAAW;YACtBC,wBAAwB,EAAE,IAAI;YAC9BC,cAAc,EAAE;UAClB;QAAE;UAAA;UAAA;UAAA;QAAA;MACF;QAAA;QAAA;QAAA;MAAA,QACe;IAEvB,CAAC;EAAA;EAEMC,iBAAiB,GAAS;IAC/BjB,OAAO,CAACC,GAAG,CAAC,SAAS,CAAC;IACtB;IACE,KAAK,CAACgB,iBAAiB,EAAE;EAC7B;EAEOC,kBAAkB,GAAS;IAChClB,OAAO,CAACC,GAAG,CAAC,SAAS,CAAC;IACtBD,OAAO,CAACC,GAAG,CAAC,IAAI,CAACR,SAAS,CAAC;IAC3B;IACF;IACA;;IAEE,KAAK,CAACyB,kBAAkB,EAAE;EAC5B;AAEF;;AAEE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEJ;AACA;AACA;AACA;AACA;;AAEA,oBAAelC,uBAAuB,CAACK,WAAW,CAAC;AAAA;AAAA"},"metadata":{},"sourceType":"module"}