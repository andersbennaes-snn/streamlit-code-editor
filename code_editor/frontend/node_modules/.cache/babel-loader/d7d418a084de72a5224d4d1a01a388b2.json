{"ast":null,"code":"\"no use strict\";\n\n!function (window) {\n  if (typeof window.window != \"undefined\" && window.document) return;\n  if (window.require && window.define) return;\n  if (!window.console) {\n    window.console = function () {\n      var msgs = Array.prototype.slice.call(arguments, 0);\n      postMessage({\n        type: \"log\",\n        data: msgs\n      });\n    };\n    window.console.error = window.console.warn = window.console.log = window.console.trace = window.console;\n  }\n  window.window = window;\n  window.ace = window;\n  window.onerror = function (message, file, line, col, err) {\n    postMessage({\n      type: \"error\",\n      data: {\n        message: message,\n        data: err && err.data,\n        file: file,\n        line: line,\n        col: col,\n        stack: err && err.stack\n      }\n    });\n  };\n  window.normalizeModule = function (parentId, moduleName) {\n    // normalize plugin requires\n    if (moduleName.indexOf(\"!\") !== -1) {\n      var chunks = moduleName.split(\"!\");\n      return window.normalizeModule(parentId, chunks[0]) + \"!\" + window.normalizeModule(parentId, chunks[1]);\n    }\n    // normalize relative requires\n    if (moduleName.charAt(0) == \".\") {\n      var base = parentId.split(\"/\").slice(0, -1).join(\"/\");\n      moduleName = (base ? base + \"/\" : \"\") + moduleName;\n      while (moduleName.indexOf(\".\") !== -1 && previous != moduleName) {\n        var previous = moduleName;\n        moduleName = moduleName.replace(/^\\.\\//, \"\").replace(/\\/\\.\\//, \"/\").replace(/[^\\/]+\\/\\.\\.\\//, \"\");\n      }\n    }\n    return moduleName;\n  };\n  window.require = function require(parentId, id) {\n    if (!id) {\n      id = parentId;\n      parentId = null;\n    }\n    if (!id.charAt) throw new Error(\"worker.js require() accepts only (parentId, id) as arguments\");\n    id = window.normalizeModule(parentId, id);\n    var module = window.require.modules[id];\n    if (module) {\n      if (!module.initialized) {\n        module.initialized = true;\n        module.exports = module.factory().exports;\n      }\n      return module.exports;\n    }\n    if (!window.require.tlns) return console.log(\"unable to load \" + id);\n    var path = resolveModuleId(id, window.require.tlns);\n    if (path.slice(-3) != \".js\") path += \".js\";\n    window.require.id = id;\n    window.require.modules[id] = {}; // prevent infinite loop on broken modules\n    importScripts(path);\n    return window.require(parentId, id);\n  };\n  function resolveModuleId(id, paths) {\n    var testPath = id,\n      tail = \"\";\n    while (testPath) {\n      var alias = paths[testPath];\n      if (typeof alias == \"string\") {\n        return alias + tail;\n      } else if (alias) {\n        return alias.location.replace(/\\/*$/, \"/\") + (tail || alias.main || alias.name);\n      } else if (alias === false) {\n        return \"\";\n      }\n      var i = testPath.lastIndexOf(\"/\");\n      if (i === -1) break;\n      tail = testPath.substr(i) + tail;\n      testPath = testPath.slice(0, i);\n    }\n    return id;\n  }\n  window.require.modules = {};\n  window.require.tlns = {};\n  window.define = function (id, deps, _factory) {\n    if (arguments.length == 2) {\n      _factory = deps;\n      if (typeof id != \"string\") {\n        deps = id;\n        id = window.require.id;\n      }\n    } else if (arguments.length == 1) {\n      _factory = id;\n      deps = [];\n      id = window.require.id;\n    }\n    if (typeof _factory != \"function\") {\n      window.require.modules[id] = {\n        exports: _factory,\n        initialized: true\n      };\n      return;\n    }\n    if (!deps.length)\n      // If there is no dependencies, we inject \"require\", \"exports\" and\n      // \"module\" as dependencies, to provide CommonJS compatibility.\n      deps = [\"require\", \"exports\", \"module\"];\n    var req = function req(childId) {\n      return window.require(id, childId);\n    };\n    window.require.modules[id] = {\n      exports: {},\n      factory: function factory() {\n        var module = this;\n        var returnExports = _factory.apply(this, deps.slice(0, _factory.length).map(function (dep) {\n          switch (dep) {\n            // Because \"require\", \"exports\" and \"module\" aren't actual\n            // dependencies, we must handle them seperately.\n            case \"require\":\n              return req;\n            case \"exports\":\n              return module.exports;\n            case \"module\":\n              return module;\n            // But for all other dependencies, we can just go ahead and\n            // require them.\n            default:\n              return req(dep);\n          }\n        }));\n        if (returnExports) module.exports = returnExports;\n        return module;\n      }\n    };\n  };\n  window.define.amd = {};\n  window.require.tlns = {};\n  window.initBaseUrls = function initBaseUrls(topLevelNamespaces) {\n    for (var i in topLevelNamespaces) this.require.tlns[i] = topLevelNamespaces[i];\n  };\n  window.initSender = function initSender() {\n    var EventEmitter = window.require(\"ace/lib/event_emitter\").EventEmitter;\n    var oop = window.require(\"ace/lib/oop\");\n    var Sender = function Sender() {};\n    (function () {\n      oop.implement(this, EventEmitter);\n      this.callback = function (data, callbackId) {\n        postMessage({\n          type: \"call\",\n          id: callbackId,\n          data: data\n        });\n      };\n      this.emit = function (name, data) {\n        postMessage({\n          type: \"event\",\n          name: name,\n          data: data\n        });\n      };\n    }).call(Sender.prototype);\n    return new Sender();\n  };\n  var main = window.main = null;\n  var sender = window.sender = null;\n  window.onmessage = function (e) {\n    var msg = e.data;\n    if (msg.event && sender) {\n      sender._signal(msg.event, msg.data);\n    } else if (msg.command) {\n      if (main[msg.command]) main[msg.command].apply(main, msg.args);else if (window[msg.command]) window[msg.command].apply(window, msg.args);else throw new Error(\"Unknown command:\" + msg.command);\n    } else if (msg.init) {\n      window.initBaseUrls(msg.tlns);\n      sender = window.sender = window.initSender();\n      var clazz = this.require(msg.module)[msg.classname];\n      main = window.main = new clazz(sender);\n    }\n  };\n}(this);\nace.define(\"ace/lib/oop\", [], function (require, exports, module) {\n  \"use strict\";\n\n  exports.inherits = function (ctor, superCtor) {\n    ctor.super_ = superCtor;\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n  exports.mixin = function (obj, mixin) {\n    for (var key in mixin) {\n      obj[key] = mixin[key];\n    }\n    return obj;\n  };\n  exports.implement = function (proto, mixin) {\n    exports.mixin(proto, mixin);\n  };\n});\nace.define(\"ace/apply_delta\", [], function (require, exports, module) {\n  \"use strict\";\n\n  function throwDeltaError(delta, errorText) {\n    console.log(\"Invalid Delta:\", delta);\n    throw \"Invalid Delta: \" + errorText;\n  }\n  function positionInDocument(docLines, position) {\n    return position.row >= 0 && position.row < docLines.length && position.column >= 0 && position.column <= docLines[position.row].length;\n  }\n  function validateDelta(docLines, delta) {\n    if (delta.action != \"insert\" && delta.action != \"remove\") throwDeltaError(delta, \"delta.action must be 'insert' or 'remove'\");\n    if (!(delta.lines instanceof Array)) throwDeltaError(delta, \"delta.lines must be an Array\");\n    if (!delta.start || !delta.end) throwDeltaError(delta, \"delta.start/end must be an present\");\n    var start = delta.start;\n    if (!positionInDocument(docLines, delta.start)) throwDeltaError(delta, \"delta.start must be contained in document\");\n    var end = delta.end;\n    if (delta.action == \"remove\" && !positionInDocument(docLines, end)) throwDeltaError(delta, \"delta.end must contained in document for 'remove' actions\");\n    var numRangeRows = end.row - start.row;\n    var numRangeLastLineChars = end.column - (numRangeRows == 0 ? start.column : 0);\n    if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars) throwDeltaError(delta, \"delta.range must match delta lines\");\n  }\n  exports.applyDelta = function (docLines, delta, doNotValidate) {\n    var row = delta.start.row;\n    var startColumn = delta.start.column;\n    var line = docLines[row] || \"\";\n    switch (delta.action) {\n      case \"insert\":\n        var lines = delta.lines;\n        if (lines.length === 1) {\n          docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);\n        } else {\n          var args = [row, 1].concat(delta.lines);\n          docLines.splice.apply(docLines, args);\n          docLines[row] = line.substring(0, startColumn) + docLines[row];\n          docLines[row + delta.lines.length - 1] += line.substring(startColumn);\n        }\n        break;\n      case \"remove\":\n        var endColumn = delta.end.column;\n        var endRow = delta.end.row;\n        if (row === endRow) {\n          docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);\n        } else {\n          docLines.splice(row, endRow - row + 1, line.substring(0, startColumn) + docLines[endRow].substring(endColumn));\n        }\n        break;\n    }\n  };\n});\nace.define(\"ace/lib/event_emitter\", [], function (require, exports, module) {\n  \"use strict\";\n\n  var EventEmitter = {};\n  var stopPropagation = function stopPropagation() {\n    this.propagationStopped = true;\n  };\n  var preventDefault = function preventDefault() {\n    this.defaultPrevented = true;\n  };\n  EventEmitter._emit = EventEmitter._dispatchEvent = function (eventName, e) {\n    this._eventRegistry || (this._eventRegistry = {});\n    this._defaultHandlers || (this._defaultHandlers = {});\n    var listeners = this._eventRegistry[eventName] || [];\n    var defaultHandler = this._defaultHandlers[eventName];\n    if (!listeners.length && !defaultHandler) return;\n    if (typeof e != \"object\" || !e) e = {};\n    if (!e.type) e.type = eventName;\n    if (!e.stopPropagation) e.stopPropagation = stopPropagation;\n    if (!e.preventDefault) e.preventDefault = preventDefault;\n    listeners = listeners.slice();\n    for (var i = 0; i < listeners.length; i++) {\n      listeners[i](e, this);\n      if (e.propagationStopped) break;\n    }\n    if (defaultHandler && !e.defaultPrevented) return defaultHandler(e, this);\n  };\n  EventEmitter._signal = function (eventName, e) {\n    var listeners = (this._eventRegistry || {})[eventName];\n    if (!listeners) return;\n    listeners = listeners.slice();\n    for (var i = 0; i < listeners.length; i++) listeners[i](e, this);\n  };\n  EventEmitter.once = function (eventName, callback) {\n    var _self = this;\n    this.on(eventName, function newCallback() {\n      _self.off(eventName, newCallback);\n      callback.apply(null, arguments);\n    });\n    if (!callback) {\n      return new Promise(function (resolve) {\n        callback = resolve;\n      });\n    }\n  };\n  EventEmitter.setDefaultHandler = function (eventName, callback) {\n    var handlers = this._defaultHandlers;\n    if (!handlers) handlers = this._defaultHandlers = {\n      _disabled_: {}\n    };\n    if (handlers[eventName]) {\n      var old = handlers[eventName];\n      var disabled = handlers._disabled_[eventName];\n      if (!disabled) handlers._disabled_[eventName] = disabled = [];\n      disabled.push(old);\n      var i = disabled.indexOf(callback);\n      if (i != -1) disabled.splice(i, 1);\n    }\n    handlers[eventName] = callback;\n  };\n  EventEmitter.removeDefaultHandler = function (eventName, callback) {\n    var handlers = this._defaultHandlers;\n    if (!handlers) return;\n    var disabled = handlers._disabled_[eventName];\n    if (handlers[eventName] == callback) {\n      if (disabled) this.setDefaultHandler(eventName, disabled.pop());\n    } else if (disabled) {\n      var i = disabled.indexOf(callback);\n      if (i != -1) disabled.splice(i, 1);\n    }\n  };\n  EventEmitter.on = EventEmitter.addEventListener = function (eventName, callback, capturing) {\n    this._eventRegistry = this._eventRegistry || {};\n    var listeners = this._eventRegistry[eventName];\n    if (!listeners) listeners = this._eventRegistry[eventName] = [];\n    if (listeners.indexOf(callback) == -1) listeners[capturing ? \"unshift\" : \"push\"](callback);\n    return callback;\n  };\n  EventEmitter.off = EventEmitter.removeListener = EventEmitter.removeEventListener = function (eventName, callback) {\n    this._eventRegistry = this._eventRegistry || {};\n    var listeners = this._eventRegistry[eventName];\n    if (!listeners) return;\n    var index = listeners.indexOf(callback);\n    if (index !== -1) listeners.splice(index, 1);\n  };\n  EventEmitter.removeAllListeners = function (eventName) {\n    if (!eventName) this._eventRegistry = this._defaultHandlers = undefined;\n    if (this._eventRegistry) this._eventRegistry[eventName] = undefined;\n    if (this._defaultHandlers) this._defaultHandlers[eventName] = undefined;\n  };\n  exports.EventEmitter = EventEmitter;\n});\nace.define(\"ace/range\", [], function (require, exports, module) {\n  \"use strict\";\n\n  var comparePoints = function comparePoints(p1, p2) {\n    return p1.row - p2.row || p1.column - p2.column;\n  };\n  var Range = function Range(startRow, startColumn, endRow, endColumn) {\n    this.start = {\n      row: startRow,\n      column: startColumn\n    };\n    this.end = {\n      row: endRow,\n      column: endColumn\n    };\n  };\n  (function () {\n    this.isEqual = function (range) {\n      return this.start.row === range.start.row && this.end.row === range.end.row && this.start.column === range.start.column && this.end.column === range.end.column;\n    };\n    this.toString = function () {\n      return \"Range: [\" + this.start.row + \"/\" + this.start.column + \"] -> [\" + this.end.row + \"/\" + this.end.column + \"]\";\n    };\n    this.contains = function (row, column) {\n      return this.compare(row, column) == 0;\n    };\n    this.compareRange = function (range) {\n      var cmp,\n        end = range.end,\n        start = range.start;\n      cmp = this.compare(end.row, end.column);\n      if (cmp == 1) {\n        cmp = this.compare(start.row, start.column);\n        if (cmp == 1) {\n          return 2;\n        } else if (cmp == 0) {\n          return 1;\n        } else {\n          return 0;\n        }\n      } else if (cmp == -1) {\n        return -2;\n      } else {\n        cmp = this.compare(start.row, start.column);\n        if (cmp == -1) {\n          return -1;\n        } else if (cmp == 1) {\n          return 42;\n        } else {\n          return 0;\n        }\n      }\n    };\n    this.comparePoint = function (p) {\n      return this.compare(p.row, p.column);\n    };\n    this.containsRange = function (range) {\n      return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;\n    };\n    this.intersects = function (range) {\n      var cmp = this.compareRange(range);\n      return cmp == -1 || cmp == 0 || cmp == 1;\n    };\n    this.isEnd = function (row, column) {\n      return this.end.row == row && this.end.column == column;\n    };\n    this.isStart = function (row, column) {\n      return this.start.row == row && this.start.column == column;\n    };\n    this.setStart = function (row, column) {\n      if (typeof row == \"object\") {\n        this.start.column = row.column;\n        this.start.row = row.row;\n      } else {\n        this.start.row = row;\n        this.start.column = column;\n      }\n    };\n    this.setEnd = function (row, column) {\n      if (typeof row == \"object\") {\n        this.end.column = row.column;\n        this.end.row = row.row;\n      } else {\n        this.end.row = row;\n        this.end.column = column;\n      }\n    };\n    this.inside = function (row, column) {\n      if (this.compare(row, column) == 0) {\n        if (this.isEnd(row, column) || this.isStart(row, column)) {\n          return false;\n        } else {\n          return true;\n        }\n      }\n      return false;\n    };\n    this.insideStart = function (row, column) {\n      if (this.compare(row, column) == 0) {\n        if (this.isEnd(row, column)) {\n          return false;\n        } else {\n          return true;\n        }\n      }\n      return false;\n    };\n    this.insideEnd = function (row, column) {\n      if (this.compare(row, column) == 0) {\n        if (this.isStart(row, column)) {\n          return false;\n        } else {\n          return true;\n        }\n      }\n      return false;\n    };\n    this.compare = function (row, column) {\n      if (!this.isMultiLine()) {\n        if (row === this.start.row) {\n          return column < this.start.column ? -1 : column > this.end.column ? 1 : 0;\n        }\n      }\n      if (row < this.start.row) return -1;\n      if (row > this.end.row) return 1;\n      if (this.start.row === row) return column >= this.start.column ? 0 : -1;\n      if (this.end.row === row) return column <= this.end.column ? 0 : 1;\n      return 0;\n    };\n    this.compareStart = function (row, column) {\n      if (this.start.row == row && this.start.column == column) {\n        return -1;\n      } else {\n        return this.compare(row, column);\n      }\n    };\n    this.compareEnd = function (row, column) {\n      if (this.end.row == row && this.end.column == column) {\n        return 1;\n      } else {\n        return this.compare(row, column);\n      }\n    };\n    this.compareInside = function (row, column) {\n      if (this.end.row == row && this.end.column == column) {\n        return 1;\n      } else if (this.start.row == row && this.start.column == column) {\n        return -1;\n      } else {\n        return this.compare(row, column);\n      }\n    };\n    this.clipRows = function (firstRow, lastRow) {\n      if (this.end.row > lastRow) var end = {\n        row: lastRow + 1,\n        column: 0\n      };else if (this.end.row < firstRow) var end = {\n        row: firstRow,\n        column: 0\n      };\n      if (this.start.row > lastRow) var start = {\n        row: lastRow + 1,\n        column: 0\n      };else if (this.start.row < firstRow) var start = {\n        row: firstRow,\n        column: 0\n      };\n      return Range.fromPoints(start || this.start, end || this.end);\n    };\n    this.extend = function (row, column) {\n      var cmp = this.compare(row, column);\n      if (cmp == 0) return this;else if (cmp == -1) var start = {\n        row: row,\n        column: column\n      };else var end = {\n        row: row,\n        column: column\n      };\n      return Range.fromPoints(start || this.start, end || this.end);\n    };\n    this.isEmpty = function () {\n      return this.start.row === this.end.row && this.start.column === this.end.column;\n    };\n    this.isMultiLine = function () {\n      return this.start.row !== this.end.row;\n    };\n    this.clone = function () {\n      return Range.fromPoints(this.start, this.end);\n    };\n    this.collapseRows = function () {\n      if (this.end.column == 0) return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0);else return new Range(this.start.row, 0, this.end.row, 0);\n    };\n    this.toScreenRange = function (session) {\n      var screenPosStart = session.documentToScreenPosition(this.start);\n      var screenPosEnd = session.documentToScreenPosition(this.end);\n      return new Range(screenPosStart.row, screenPosStart.column, screenPosEnd.row, screenPosEnd.column);\n    };\n    this.moveBy = function (row, column) {\n      this.start.row += row;\n      this.start.column += column;\n      this.end.row += row;\n      this.end.column += column;\n    };\n  }).call(Range.prototype);\n  Range.fromPoints = function (start, end) {\n    return new Range(start.row, start.column, end.row, end.column);\n  };\n  Range.comparePoints = comparePoints;\n  Range.comparePoints = function (p1, p2) {\n    return p1.row - p2.row || p1.column - p2.column;\n  };\n  exports.Range = Range;\n});\nace.define(\"ace/anchor\", [], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"./lib/oop\");\n  var EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\n  var Anchor = exports.Anchor = function (doc, row, column) {\n    this.$onChange = this.onChange.bind(this);\n    this.attach(doc);\n    if (typeof column == \"undefined\") this.setPosition(row.row, row.column);else this.setPosition(row, column);\n  };\n  (function () {\n    oop.implement(this, EventEmitter);\n    this.getPosition = function () {\n      return this.$clipPositionToDocument(this.row, this.column);\n    };\n    this.getDocument = function () {\n      return this.document;\n    };\n    this.$insertRight = false;\n    this.onChange = function (delta) {\n      if (delta.start.row == delta.end.row && delta.start.row != this.row) return;\n      if (delta.start.row > this.row) return;\n      var point = $getTransformedPoint(delta, {\n        row: this.row,\n        column: this.column\n      }, this.$insertRight);\n      this.setPosition(point.row, point.column, true);\n    };\n    function $pointsInOrder(point1, point2, equalPointsInOrder) {\n      var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;\n      return point1.row < point2.row || point1.row == point2.row && bColIsAfter;\n    }\n    function $getTransformedPoint(delta, point, moveIfEqual) {\n      var deltaIsInsert = delta.action == \"insert\";\n      var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row - delta.start.row);\n      var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);\n      var deltaStart = delta.start;\n      var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.\n      if ($pointsInOrder(point, deltaStart, moveIfEqual)) {\n        return {\n          row: point.row,\n          column: point.column\n        };\n      }\n      if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {\n        return {\n          row: point.row + deltaRowShift,\n          column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)\n        };\n      }\n      return {\n        row: deltaStart.row,\n        column: deltaStart.column\n      };\n    }\n    this.setPosition = function (row, column, noClip) {\n      var pos;\n      if (noClip) {\n        pos = {\n          row: row,\n          column: column\n        };\n      } else {\n        pos = this.$clipPositionToDocument(row, column);\n      }\n      if (this.row == pos.row && this.column == pos.column) return;\n      var old = {\n        row: this.row,\n        column: this.column\n      };\n      this.row = pos.row;\n      this.column = pos.column;\n      this._signal(\"change\", {\n        old: old,\n        value: pos\n      });\n    };\n    this.detach = function () {\n      this.document.off(\"change\", this.$onChange);\n    };\n    this.attach = function (doc) {\n      this.document = doc || this.document;\n      this.document.on(\"change\", this.$onChange);\n    };\n    this.$clipPositionToDocument = function (row, column) {\n      var pos = {};\n      if (row >= this.document.getLength()) {\n        pos.row = Math.max(0, this.document.getLength() - 1);\n        pos.column = this.document.getLine(pos.row).length;\n      } else if (row < 0) {\n        pos.row = 0;\n        pos.column = 0;\n      } else {\n        pos.row = row;\n        pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));\n      }\n      if (column < 0) pos.column = 0;\n      return pos;\n    };\n  }).call(Anchor.prototype);\n});\nace.define(\"ace/document\", [], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"./lib/oop\");\n  var applyDelta = require(\"./apply_delta\").applyDelta;\n  var EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\n  var Range = require(\"./range\").Range;\n  var Anchor = require(\"./anchor\").Anchor;\n  var Document = function Document(textOrLines) {\n    this.$lines = [\"\"];\n    if (textOrLines.length === 0) {\n      this.$lines = [\"\"];\n    } else if (Array.isArray(textOrLines)) {\n      this.insertMergedLines({\n        row: 0,\n        column: 0\n      }, textOrLines);\n    } else {\n      this.insert({\n        row: 0,\n        column: 0\n      }, textOrLines);\n    }\n  };\n  (function () {\n    oop.implement(this, EventEmitter);\n    this.setValue = function (text) {\n      var len = this.getLength() - 1;\n      this.remove(new Range(0, 0, len, this.getLine(len).length));\n      this.insert({\n        row: 0,\n        column: 0\n      }, text || \"\");\n    };\n    this.getValue = function () {\n      return this.getAllLines().join(this.getNewLineCharacter());\n    };\n    this.createAnchor = function (row, column) {\n      return new Anchor(this, row, column);\n    };\n    if (\"aaa\".split(/a/).length === 0) {\n      this.$split = function (text) {\n        return text.replace(/\\r\\n|\\r/g, \"\\n\").split(\"\\n\");\n      };\n    } else {\n      this.$split = function (text) {\n        return text.split(/\\r\\n|\\r|\\n/);\n      };\n    }\n    this.$detectNewLine = function (text) {\n      var match = text.match(/^.*?(\\r\\n|\\r|\\n)/m);\n      this.$autoNewLine = match ? match[1] : \"\\n\";\n      this._signal(\"changeNewLineMode\");\n    };\n    this.getNewLineCharacter = function () {\n      switch (this.$newLineMode) {\n        case \"windows\":\n          return \"\\r\\n\";\n        case \"unix\":\n          return \"\\n\";\n        default:\n          return this.$autoNewLine || \"\\n\";\n      }\n    };\n    this.$autoNewLine = \"\";\n    this.$newLineMode = \"auto\";\n    this.setNewLineMode = function (newLineMode) {\n      if (this.$newLineMode === newLineMode) return;\n      this.$newLineMode = newLineMode;\n      this._signal(\"changeNewLineMode\");\n    };\n    this.getNewLineMode = function () {\n      return this.$newLineMode;\n    };\n    this.isNewLine = function (text) {\n      return text == \"\\r\\n\" || text == \"\\r\" || text == \"\\n\";\n    };\n    this.getLine = function (row) {\n      return this.$lines[row] || \"\";\n    };\n    this.getLines = function (firstRow, lastRow) {\n      return this.$lines.slice(firstRow, lastRow + 1);\n    };\n    this.getAllLines = function () {\n      return this.getLines(0, this.getLength());\n    };\n    this.getLength = function () {\n      return this.$lines.length;\n    };\n    this.getTextRange = function (range) {\n      return this.getLinesForRange(range).join(this.getNewLineCharacter());\n    };\n    this.getLinesForRange = function (range) {\n      var lines;\n      if (range.start.row === range.end.row) {\n        lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];\n      } else {\n        lines = this.getLines(range.start.row, range.end.row);\n        lines[0] = (lines[0] || \"\").substring(range.start.column);\n        var l = lines.length - 1;\n        if (range.end.row - range.start.row == l) lines[l] = lines[l].substring(0, range.end.column);\n      }\n      return lines;\n    };\n    this.insertLines = function (row, lines) {\n      console.warn(\"Use of document.insertLines is deprecated. Use the insertFullLines method instead.\");\n      return this.insertFullLines(row, lines);\n    };\n    this.removeLines = function (firstRow, lastRow) {\n      console.warn(\"Use of document.removeLines is deprecated. Use the removeFullLines method instead.\");\n      return this.removeFullLines(firstRow, lastRow);\n    };\n    this.insertNewLine = function (position) {\n      console.warn(\"Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.\");\n      return this.insertMergedLines(position, [\"\", \"\"]);\n    };\n    this.insert = function (position, text) {\n      if (this.getLength() <= 1) this.$detectNewLine(text);\n      return this.insertMergedLines(position, this.$split(text));\n    };\n    this.insertInLine = function (position, text) {\n      var start = this.clippedPos(position.row, position.column);\n      var end = this.pos(position.row, position.column + text.length);\n      this.applyDelta({\n        start: start,\n        end: end,\n        action: \"insert\",\n        lines: [text]\n      }, true);\n      return this.clonePos(end);\n    };\n    this.clippedPos = function (row, column) {\n      var length = this.getLength();\n      if (row === undefined) {\n        row = length;\n      } else if (row < 0) {\n        row = 0;\n      } else if (row >= length) {\n        row = length - 1;\n        column = undefined;\n      }\n      var line = this.getLine(row);\n      if (column == undefined) column = line.length;\n      column = Math.min(Math.max(column, 0), line.length);\n      return {\n        row: row,\n        column: column\n      };\n    };\n    this.clonePos = function (pos) {\n      return {\n        row: pos.row,\n        column: pos.column\n      };\n    };\n    this.pos = function (row, column) {\n      return {\n        row: row,\n        column: column\n      };\n    };\n    this.$clipPosition = function (position) {\n      var length = this.getLength();\n      if (position.row >= length) {\n        position.row = Math.max(0, length - 1);\n        position.column = this.getLine(length - 1).length;\n      } else {\n        position.row = Math.max(0, position.row);\n        position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);\n      }\n      return position;\n    };\n    this.insertFullLines = function (row, lines) {\n      row = Math.min(Math.max(row, 0), this.getLength());\n      var column = 0;\n      if (row < this.getLength()) {\n        lines = lines.concat([\"\"]);\n        column = 0;\n      } else {\n        lines = [\"\"].concat(lines);\n        row--;\n        column = this.$lines[row].length;\n      }\n      this.insertMergedLines({\n        row: row,\n        column: column\n      }, lines);\n    };\n    this.insertMergedLines = function (position, lines) {\n      var start = this.clippedPos(position.row, position.column);\n      var end = {\n        row: start.row + lines.length - 1,\n        column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length\n      };\n      this.applyDelta({\n        start: start,\n        end: end,\n        action: \"insert\",\n        lines: lines\n      });\n      return this.clonePos(end);\n    };\n    this.remove = function (range) {\n      var start = this.clippedPos(range.start.row, range.start.column);\n      var end = this.clippedPos(range.end.row, range.end.column);\n      this.applyDelta({\n        start: start,\n        end: end,\n        action: \"remove\",\n        lines: this.getLinesForRange({\n          start: start,\n          end: end\n        })\n      });\n      return this.clonePos(start);\n    };\n    this.removeInLine = function (row, startColumn, endColumn) {\n      var start = this.clippedPos(row, startColumn);\n      var end = this.clippedPos(row, endColumn);\n      this.applyDelta({\n        start: start,\n        end: end,\n        action: \"remove\",\n        lines: this.getLinesForRange({\n          start: start,\n          end: end\n        })\n      }, true);\n      return this.clonePos(start);\n    };\n    this.removeFullLines = function (firstRow, lastRow) {\n      firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);\n      lastRow = Math.min(Math.max(0, lastRow), this.getLength() - 1);\n      var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;\n      var deleteLastNewLine = lastRow < this.getLength() - 1;\n      var startRow = deleteFirstNewLine ? firstRow - 1 : firstRow;\n      var startCol = deleteFirstNewLine ? this.getLine(startRow).length : 0;\n      var endRow = deleteLastNewLine ? lastRow + 1 : lastRow;\n      var endCol = deleteLastNewLine ? 0 : this.getLine(endRow).length;\n      var range = new Range(startRow, startCol, endRow, endCol);\n      var deletedLines = this.$lines.slice(firstRow, lastRow + 1);\n      this.applyDelta({\n        start: range.start,\n        end: range.end,\n        action: \"remove\",\n        lines: this.getLinesForRange(range)\n      });\n      return deletedLines;\n    };\n    this.removeNewLine = function (row) {\n      if (row < this.getLength() - 1 && row >= 0) {\n        this.applyDelta({\n          start: this.pos(row, this.getLine(row).length),\n          end: this.pos(row + 1, 0),\n          action: \"remove\",\n          lines: [\"\", \"\"]\n        });\n      }\n    };\n    this.replace = function (range, text) {\n      if (!(range instanceof Range)) range = Range.fromPoints(range.start, range.end);\n      if (text.length === 0 && range.isEmpty()) return range.start;\n      if (text == this.getTextRange(range)) return range.end;\n      this.remove(range);\n      var end;\n      if (text) {\n        end = this.insert(range.start, text);\n      } else {\n        end = range.start;\n      }\n      return end;\n    };\n    this.applyDeltas = function (deltas) {\n      for (var i = 0; i < deltas.length; i++) {\n        this.applyDelta(deltas[i]);\n      }\n    };\n    this.revertDeltas = function (deltas) {\n      for (var i = deltas.length - 1; i >= 0; i--) {\n        this.revertDelta(deltas[i]);\n      }\n    };\n    this.applyDelta = function (delta, doNotValidate) {\n      var isInsert = delta.action == \"insert\";\n      if (isInsert ? delta.lines.length <= 1 && !delta.lines[0] : !Range.comparePoints(delta.start, delta.end)) {\n        return;\n      }\n      if (isInsert && delta.lines.length > 20000) {\n        this.$splitAndapplyLargeDelta(delta, 20000);\n      } else {\n        applyDelta(this.$lines, delta, doNotValidate);\n        this._signal(\"change\", delta);\n      }\n    };\n    this.$safeApplyDelta = function (delta) {\n      var docLength = this.$lines.length;\n      if (delta.action == \"remove\" && delta.start.row < docLength && delta.end.row < docLength || delta.action == \"insert\" && delta.start.row <= docLength) {\n        this.applyDelta(delta);\n      }\n    };\n    this.$splitAndapplyLargeDelta = function (delta, MAX) {\n      var lines = delta.lines;\n      var l = lines.length - MAX + 1;\n      var row = delta.start.row;\n      var column = delta.start.column;\n      for (var from = 0, to = 0; from < l; from = to) {\n        to += MAX - 1;\n        var chunk = lines.slice(from, to);\n        chunk.push(\"\");\n        this.applyDelta({\n          start: this.pos(row + from, column),\n          end: this.pos(row + to, column = 0),\n          action: delta.action,\n          lines: chunk\n        }, true);\n      }\n      delta.lines = lines.slice(from);\n      delta.start.row = row + from;\n      delta.start.column = column;\n      this.applyDelta(delta, true);\n    };\n    this.revertDelta = function (delta) {\n      this.$safeApplyDelta({\n        start: this.clonePos(delta.start),\n        end: this.clonePos(delta.end),\n        action: delta.action == \"insert\" ? \"remove\" : \"insert\",\n        lines: delta.lines.slice()\n      });\n    };\n    this.indexToPosition = function (index, startRow) {\n      var lines = this.$lines || this.getAllLines();\n      var newlineLength = this.getNewLineCharacter().length;\n      for (var i = startRow || 0, l = lines.length; i < l; i++) {\n        index -= lines[i].length + newlineLength;\n        if (index < 0) return {\n          row: i,\n          column: index + lines[i].length + newlineLength\n        };\n      }\n      return {\n        row: l - 1,\n        column: index + lines[l - 1].length + newlineLength\n      };\n    };\n    this.positionToIndex = function (pos, startRow) {\n      var lines = this.$lines || this.getAllLines();\n      var newlineLength = this.getNewLineCharacter().length;\n      var index = 0;\n      var row = Math.min(pos.row, lines.length);\n      for (var i = startRow || 0; i < row; ++i) index += lines[i].length + newlineLength;\n      return index + pos.column;\n    };\n  }).call(Document.prototype);\n  exports.Document = Document;\n});\nace.define(\"ace/lib/lang\", [], function (require, exports, module) {\n  \"use strict\";\n\n  exports.last = function (a) {\n    return a[a.length - 1];\n  };\n  exports.stringReverse = function (string) {\n    return string.split(\"\").reverse().join(\"\");\n  };\n  exports.stringRepeat = function (string, count) {\n    var result = '';\n    while (count > 0) {\n      if (count & 1) result += string;\n      if (count >>= 1) string += string;\n    }\n    return result;\n  };\n  var trimBeginRegexp = /^\\s\\s*/;\n  var trimEndRegexp = /\\s\\s*$/;\n  exports.stringTrimLeft = function (string) {\n    return string.replace(trimBeginRegexp, '');\n  };\n  exports.stringTrimRight = function (string) {\n    return string.replace(trimEndRegexp, '');\n  };\n  exports.copyObject = function (obj) {\n    var copy = {};\n    for (var key in obj) {\n      copy[key] = obj[key];\n    }\n    return copy;\n  };\n  exports.copyArray = function (array) {\n    var copy = [];\n    for (var i = 0, l = array.length; i < l; i++) {\n      if (array[i] && typeof array[i] == \"object\") copy[i] = this.copyObject(array[i]);else copy[i] = array[i];\n    }\n    return copy;\n  };\n  exports.deepCopy = function deepCopy(obj) {\n    if (typeof obj !== \"object\" || !obj) return obj;\n    var copy;\n    if (Array.isArray(obj)) {\n      copy = [];\n      for (var key = 0; key < obj.length; key++) {\n        copy[key] = deepCopy(obj[key]);\n      }\n      return copy;\n    }\n    if (Object.prototype.toString.call(obj) !== \"[object Object]\") return obj;\n    copy = {};\n    for (var key in obj) copy[key] = deepCopy(obj[key]);\n    return copy;\n  };\n  exports.arrayToMap = function (arr) {\n    var map = {};\n    for (var i = 0; i < arr.length; i++) {\n      map[arr[i]] = 1;\n    }\n    return map;\n  };\n  exports.createMap = function (props) {\n    var map = Object.create(null);\n    for (var i in props) {\n      map[i] = props[i];\n    }\n    return map;\n  };\n  exports.arrayRemove = function (array, value) {\n    for (var i = 0; i <= array.length; i++) {\n      if (value === array[i]) {\n        array.splice(i, 1);\n      }\n    }\n  };\n  exports.escapeRegExp = function (str) {\n    return str.replace(/([.*+?^${}()|[\\]\\/\\\\])/g, '\\\\$1');\n  };\n  exports.escapeHTML = function (str) {\n    return (\"\" + str).replace(/&/g, \"&#38;\").replace(/\"/g, \"&#34;\").replace(/'/g, \"&#39;\").replace(/</g, \"&#60;\");\n  };\n  exports.getMatchOffsets = function (string, regExp) {\n    var matches = [];\n    string.replace(regExp, function (str) {\n      matches.push({\n        offset: arguments[arguments.length - 2],\n        length: str.length\n      });\n    });\n    return matches;\n  };\n  exports.deferredCall = function (fcn) {\n    var timer = null;\n    var callback = function callback() {\n      timer = null;\n      fcn();\n    };\n    var deferred = function deferred(timeout) {\n      deferred.cancel();\n      timer = setTimeout(callback, timeout || 0);\n      return deferred;\n    };\n    deferred.schedule = deferred;\n    deferred.call = function () {\n      this.cancel();\n      fcn();\n      return deferred;\n    };\n    deferred.cancel = function () {\n      clearTimeout(timer);\n      timer = null;\n      return deferred;\n    };\n    deferred.isPending = function () {\n      return timer;\n    };\n    return deferred;\n  };\n  exports.delayedCall = function (fcn, defaultTimeout) {\n    var timer = null;\n    var callback = function callback() {\n      timer = null;\n      fcn();\n    };\n    var _self = function _self(timeout) {\n      if (timer == null) timer = setTimeout(callback, timeout || defaultTimeout);\n    };\n    _self.delay = function (timeout) {\n      timer && clearTimeout(timer);\n      timer = setTimeout(callback, timeout || defaultTimeout);\n    };\n    _self.schedule = _self;\n    _self.call = function () {\n      this.cancel();\n      fcn();\n    };\n    _self.cancel = function () {\n      timer && clearTimeout(timer);\n      timer = null;\n    };\n    _self.isPending = function () {\n      return timer;\n    };\n    return _self;\n  };\n});\nace.define(\"ace/worker/mirror\", [], function (require, exports, module) {\n  \"use strict\";\n\n  var Document = require(\"../document\").Document;\n  var lang = require(\"../lib/lang\");\n  var Mirror = exports.Mirror = function (sender) {\n    this.sender = sender;\n    var doc = this.doc = new Document(\"\");\n    var deferredUpdate = this.deferredUpdate = lang.delayedCall(this.onUpdate.bind(this));\n    var _self = this;\n    sender.on(\"change\", function (e) {\n      var data = e.data;\n      if (data[0].start) {\n        doc.applyDeltas(data);\n      } else {\n        for (var i = 0; i < data.length; i += 2) {\n          var d, err;\n          if (Array.isArray(data[i + 1])) {\n            d = {\n              action: \"insert\",\n              start: data[i],\n              lines: data[i + 1]\n            };\n          } else {\n            d = {\n              action: \"remove\",\n              start: data[i],\n              end: data[i + 1]\n            };\n          }\n          if ((d.action == \"insert\" ? d.start : d.end).row >= doc.$lines.length) {\n            err = new Error(\"Invalid delta\");\n            err.data = {\n              path: _self.$path,\n              linesLength: doc.$lines.length,\n              start: d.start,\n              end: d.end\n            };\n            throw err;\n          }\n          doc.applyDelta(d, true);\n        }\n      }\n      if (_self.$timeout) return deferredUpdate.schedule(_self.$timeout);\n      _self.onUpdate();\n    });\n  };\n  (function () {\n    this.$timeout = 500;\n    this.setTimeout = function (timeout) {\n      this.$timeout = timeout;\n    };\n    this.setValue = function (value) {\n      this.doc.setValue(value);\n      this.deferredUpdate.schedule(this.$timeout);\n    };\n    this.getValue = function (callbackId) {\n      this.sender.callback(this.doc.getValue(), callbackId);\n    };\n    this.onUpdate = function () {};\n    this.isPending = function () {\n      return this.deferredUpdate.isPending();\n    };\n  }).call(Mirror.prototype);\n});\nace.define(\"ace/mode/lua/luaparse\", [], function (require, exports, module) {\n  (function (root, name, factory) {\n    factory(exports);\n  })(this, 'luaparse', function (exports) {\n    'use strict';\n\n    exports.version = \"0.3.1\";\n    var input, options, length, features, encodingMode;\n    var defaultOptions = exports.defaultOptions = {\n      wait: false,\n      comments: true,\n      scope: false,\n      locations: false,\n      ranges: false,\n      onCreateNode: null,\n      onCreateScope: null,\n      onDestroyScope: null,\n      onLocalDeclaration: null,\n      luaVersion: '5.3',\n      encodingMode: 'none'\n    };\n    function _encodeUTF(codepoint, highMask) {\n      highMask = highMask || 0;\n      if (codepoint < 0x80) {\n        return String.fromCharCode(codepoint);\n      } else if (codepoint < 0x800) {\n        return String.fromCharCode(highMask | 0xc0 | codepoint >> 6, highMask | 0x80 | codepoint & 0x3f);\n      } else if (codepoint < 0x10000) {\n        return String.fromCharCode(highMask | 0xe0 | codepoint >> 12, highMask | 0x80 | codepoint >> 6 & 0x3f, highMask | 0x80 | codepoint & 0x3f);\n      } else /* istanbul ignore else */if (codepoint < 0x110000) {\n          return String.fromCharCode(highMask | 0xf0 | codepoint >> 18, highMask | 0x80 | codepoint >> 12 & 0x3f, highMask | 0x80 | codepoint >> 6 & 0x3f, highMask | 0x80 | codepoint & 0x3f);\n        } else {\n          return null;\n        }\n    }\n    function toHex(num, digits) {\n      var result = num.toString(16);\n      while (result.length < digits) result = '0' + result;\n      return result;\n    }\n    function checkChars(rx) {\n      return function (s) {\n        var m = rx.exec(s);\n        if (!m) return s;\n        raise(null, errors.invalidCodeUnit, toHex(m[0].charCodeAt(0), 4).toUpperCase());\n      };\n    }\n    var encodingModes = {\n      'pseudo-latin1': {\n        fixup: checkChars(/[^\\x00-\\xff]/),\n        encodeByte: function encodeByte(value) {\n          if (value === null) return '';\n          return String.fromCharCode(value);\n        },\n        encodeUTF8: function encodeUTF8(codepoint) {\n          return _encodeUTF(codepoint);\n        }\n      },\n      'x-user-defined': {\n        fixup: checkChars(/[^\\x00-\\x7f\\uf780-\\uf7ff]/),\n        encodeByte: function encodeByte(value) {\n          if (value === null) return '';\n          if (value >= 0x80) return String.fromCharCode(value | 0xf700);\n          return String.fromCharCode(value);\n        },\n        encodeUTF8: function encodeUTF8(codepoint) {\n          return _encodeUTF(codepoint, 0xf700);\n        }\n      },\n      'none': {\n        discardStrings: true,\n        fixup: function fixup(s) {\n          return s;\n        },\n        encodeByte: function encodeByte(value) {\n          return '';\n        },\n        encodeUTF8: function encodeUTF8(codepoint) {\n          return '';\n        }\n      }\n    };\n    var EOF = 1,\n      StringLiteral = 2,\n      Keyword = 4,\n      Identifier = 8,\n      NumericLiteral = 16,\n      Punctuator = 32,\n      BooleanLiteral = 64,\n      NilLiteral = 128,\n      VarargLiteral = 256;\n    exports.tokenTypes = {\n      EOF: EOF,\n      StringLiteral: StringLiteral,\n      Keyword: Keyword,\n      Identifier: Identifier,\n      NumericLiteral: NumericLiteral,\n      Punctuator: Punctuator,\n      BooleanLiteral: BooleanLiteral,\n      NilLiteral: NilLiteral,\n      VarargLiteral: VarargLiteral\n    };\n    var errors = exports.errors = {\n      unexpected: 'unexpected %1 \\'%2\\' near \\'%3\\'',\n      unexpectedEOF: 'unexpected symbol near \\'<eof>\\'',\n      expected: '\\'%1\\' expected near \\'%2\\'',\n      expectedToken: '%1 expected near \\'%2\\'',\n      unfinishedString: 'unfinished string near \\'%1\\'',\n      malformedNumber: 'malformed number near \\'%1\\'',\n      decimalEscapeTooLarge: 'decimal escape too large near \\'%1\\'',\n      invalidEscape: 'invalid escape sequence near \\'%1\\'',\n      hexadecimalDigitExpected: 'hexadecimal digit expected near \\'%1\\'',\n      braceExpected: 'missing \\'%1\\' near \\'%2\\'',\n      tooLargeCodepoint: 'UTF-8 value too large near \\'%1\\'',\n      unfinishedLongString: 'unfinished long string (starting at line %1) near \\'%2\\'',\n      unfinishedLongComment: 'unfinished long comment (starting at line %1) near \\'%2\\'',\n      ambiguousSyntax: 'ambiguous syntax (function call x new statement) near \\'%1\\'',\n      noLoopToBreak: 'no loop to break near \\'%1\\'',\n      labelAlreadyDefined: 'label \\'%1\\' already defined on line %2',\n      labelNotVisible: 'no visible label \\'%1\\' for <goto>',\n      gotoJumpInLocalScope: '<goto %1> jumps into the scope of local \\'%2\\'',\n      cannotUseVararg: 'cannot use \\'...\\' outside a vararg function near \\'%1\\'',\n      invalidCodeUnit: 'code unit U+%1 is not allowed in the current encoding mode'\n    };\n    var ast = exports.ast = {\n      labelStatement: function labelStatement(label) {\n        return {\n          type: 'LabelStatement',\n          label: label\n        };\n      },\n      breakStatement: function breakStatement() {\n        return {\n          type: 'BreakStatement'\n        };\n      },\n      gotoStatement: function gotoStatement(label) {\n        return {\n          type: 'GotoStatement',\n          label: label\n        };\n      },\n      returnStatement: function returnStatement(args) {\n        return {\n          type: 'ReturnStatement',\n          'arguments': args\n        };\n      },\n      ifStatement: function ifStatement(clauses) {\n        return {\n          type: 'IfStatement',\n          clauses: clauses\n        };\n      },\n      ifClause: function ifClause(condition, body) {\n        return {\n          type: 'IfClause',\n          condition: condition,\n          body: body\n        };\n      },\n      elseifClause: function elseifClause(condition, body) {\n        return {\n          type: 'ElseifClause',\n          condition: condition,\n          body: body\n        };\n      },\n      elseClause: function elseClause(body) {\n        return {\n          type: 'ElseClause',\n          body: body\n        };\n      },\n      whileStatement: function whileStatement(condition, body) {\n        return {\n          type: 'WhileStatement',\n          condition: condition,\n          body: body\n        };\n      },\n      doStatement: function doStatement(body) {\n        return {\n          type: 'DoStatement',\n          body: body\n        };\n      },\n      repeatStatement: function repeatStatement(condition, body) {\n        return {\n          type: 'RepeatStatement',\n          condition: condition,\n          body: body\n        };\n      },\n      localStatement: function localStatement(variables, init) {\n        return {\n          type: 'LocalStatement',\n          variables: variables,\n          init: init\n        };\n      },\n      assignmentStatement: function assignmentStatement(variables, init) {\n        return {\n          type: 'AssignmentStatement',\n          variables: variables,\n          init: init\n        };\n      },\n      callStatement: function callStatement(expression) {\n        return {\n          type: 'CallStatement',\n          expression: expression\n        };\n      },\n      functionStatement: function functionStatement(identifier, parameters, isLocal, body) {\n        return {\n          type: 'FunctionDeclaration',\n          identifier: identifier,\n          isLocal: isLocal,\n          parameters: parameters,\n          body: body\n        };\n      },\n      forNumericStatement: function forNumericStatement(variable, start, end, step, body) {\n        return {\n          type: 'ForNumericStatement',\n          variable: variable,\n          start: start,\n          end: end,\n          step: step,\n          body: body\n        };\n      },\n      forGenericStatement: function forGenericStatement(variables, iterators, body) {\n        return {\n          type: 'ForGenericStatement',\n          variables: variables,\n          iterators: iterators,\n          body: body\n        };\n      },\n      chunk: function chunk(body) {\n        return {\n          type: 'Chunk',\n          body: body\n        };\n      },\n      identifier: function identifier(name) {\n        return {\n          type: 'Identifier',\n          name: name\n        };\n      },\n      literal: function literal(type, value, raw) {\n        type = type === StringLiteral ? 'StringLiteral' : type === NumericLiteral ? 'NumericLiteral' : type === BooleanLiteral ? 'BooleanLiteral' : type === NilLiteral ? 'NilLiteral' : 'VarargLiteral';\n        return {\n          type: type,\n          value: value,\n          raw: raw\n        };\n      },\n      tableKey: function tableKey(key, value) {\n        return {\n          type: 'TableKey',\n          key: key,\n          value: value\n        };\n      },\n      tableKeyString: function tableKeyString(key, value) {\n        return {\n          type: 'TableKeyString',\n          key: key,\n          value: value\n        };\n      },\n      tableValue: function tableValue(value) {\n        return {\n          type: 'TableValue',\n          value: value\n        };\n      },\n      tableConstructorExpression: function tableConstructorExpression(fields) {\n        return {\n          type: 'TableConstructorExpression',\n          fields: fields\n        };\n      },\n      binaryExpression: function binaryExpression(operator, left, right) {\n        var type = 'and' === operator || 'or' === operator ? 'LogicalExpression' : 'BinaryExpression';\n        return {\n          type: type,\n          operator: operator,\n          left: left,\n          right: right\n        };\n      },\n      unaryExpression: function unaryExpression(operator, argument) {\n        return {\n          type: 'UnaryExpression',\n          operator: operator,\n          argument: argument\n        };\n      },\n      memberExpression: function memberExpression(base, indexer, identifier) {\n        return {\n          type: 'MemberExpression',\n          indexer: indexer,\n          identifier: identifier,\n          base: base\n        };\n      },\n      indexExpression: function indexExpression(base, index) {\n        return {\n          type: 'IndexExpression',\n          base: base,\n          index: index\n        };\n      },\n      callExpression: function callExpression(base, args) {\n        return {\n          type: 'CallExpression',\n          base: base,\n          'arguments': args\n        };\n      },\n      tableCallExpression: function tableCallExpression(base, args) {\n        return {\n          type: 'TableCallExpression',\n          base: base,\n          'arguments': args\n        };\n      },\n      stringCallExpression: function stringCallExpression(base, argument) {\n        return {\n          type: 'StringCallExpression',\n          base: base,\n          argument: argument\n        };\n      },\n      comment: function comment(value, raw) {\n        return {\n          type: 'Comment',\n          value: value,\n          raw: raw\n        };\n      }\n    };\n    function finishNode(node) {\n      if (trackLocations) {\n        var location = locations.pop();\n        location.complete();\n        location.bless(node);\n      }\n      if (options.onCreateNode) options.onCreateNode(node);\n      return node;\n    }\n    var slice = Array.prototype.slice,\n      toString = Object.prototype.toString;\n    var indexOf = /* istanbul ignore next */function indexOf(array, element) {\n      for (var i = 0, length = array.length; i < length; ++i) {\n        if (array[i] === element) return i;\n      }\n      return -1;\n    };\n    if (Array.prototype.indexOf) indexOf = function indexOf(array, element) {\n      return array.indexOf(element);\n    };\n    function indexOfObject(array, property, element) {\n      for (var i = 0, length = array.length; i < length; ++i) {\n        if (array[i][property] === element) return i;\n      }\n      return -1;\n    }\n    function sprintf(format) {\n      var args = slice.call(arguments, 1);\n      format = format.replace(/%(\\d)/g, function (match, index) {\n        return '' + args[index - 1] || /* istanbul ignore next */'';\n      });\n      return format;\n    }\n    var assign = /* istanbul ignore next */function assign(dest) {\n      var args = slice.call(arguments, 1),\n        src,\n        prop;\n      for (var i = 0, length = args.length; i < length; ++i) {\n        src = args[i];\n        for (prop in src) if (Object.prototype.hasOwnProperty.call(src, prop)) {\n          dest[prop] = src[prop];\n        }\n      }\n      return dest;\n    };\n    if (Object.assign) assign = Object.assign;\n    exports.SyntaxError = SyntaxError;\n    function fixupError(e) {\n      if (!Object.create) return e;\n      return Object.create(e, {\n        'line': {\n          'writable': true,\n          value: e.line\n        },\n        'index': {\n          'writable': true,\n          value: e.index\n        },\n        'column': {\n          'writable': true,\n          value: e.column\n        }\n      });\n    }\n    function raise(token) {\n      var message = sprintf.apply(null, slice.call(arguments, 1)),\n        error,\n        col;\n      if (token === null || typeof token.line === 'undefined') {\n        col = index - lineStart + 1;\n        error = fixupError(new SyntaxError(sprintf('[%1:%2] %3', line, col, message)));\n        error.index = index;\n        error.line = line;\n        error.column = col;\n      } else {\n        col = token.range[0] - token.lineStart;\n        error = fixupError(new SyntaxError(sprintf('[%1:%2] %3', token.line, col, message)));\n        error.line = token.line;\n        error.index = token.range[0];\n        error.column = col;\n      }\n      throw error;\n    }\n    function tokenValue(token) {\n      var raw = input.slice(token.range[0], token.range[1]);\n      if (raw) return raw;\n      return token.value;\n    }\n    function raiseUnexpectedToken(type, token) {\n      raise(token, errors.expectedToken, type, tokenValue(token));\n    }\n    function unexpected(found) {\n      var near = tokenValue(lookahead);\n      if ('undefined' !== typeof found.type) {\n        var type;\n        switch (found.type) {\n          case StringLiteral:\n            type = 'string';\n            break;\n          case Keyword:\n            type = 'keyword';\n            break;\n          case Identifier:\n            type = 'identifier';\n            break;\n          case NumericLiteral:\n            type = 'number';\n            break;\n          case Punctuator:\n            type = 'symbol';\n            break;\n          case BooleanLiteral:\n            type = 'boolean';\n            break;\n          case NilLiteral:\n            return raise(found, errors.unexpected, 'symbol', 'nil', near);\n          case EOF:\n            return raise(found, errors.unexpectedEOF);\n        }\n        return raise(found, errors.unexpected, type, tokenValue(found), near);\n      }\n      return raise(found, errors.unexpected, 'symbol', found, near);\n    }\n    var index, token, previousToken, lookahead, comments, tokenStart, line, lineStart;\n    exports.lex = lex;\n    function lex() {\n      skipWhiteSpace();\n      while (45 === input.charCodeAt(index) && 45 === input.charCodeAt(index + 1)) {\n        scanComment();\n        skipWhiteSpace();\n      }\n      if (index >= length) return {\n        type: EOF,\n        value: '<eof>',\n        line: line,\n        lineStart: lineStart,\n        range: [index, index]\n      };\n      var charCode = input.charCodeAt(index),\n        next = input.charCodeAt(index + 1);\n      tokenStart = index;\n      if (isIdentifierStart(charCode)) return scanIdentifierOrKeyword();\n      switch (charCode) {\n        case 39:\n        case 34:\n          // '\"\n          return scanStringLiteral();\n        case 48:\n        case 49:\n        case 50:\n        case 51:\n        case 52:\n        case 53:\n        case 54:\n        case 55:\n        case 56:\n        case 57:\n          // 0-9\n          return scanNumericLiteral();\n        case 46:\n          // .\n          if (isDecDigit(next)) return scanNumericLiteral();\n          if (46 === next) {\n            if (46 === input.charCodeAt(index + 2)) return scanVarargLiteral();\n            return scanPunctuator('..');\n          }\n          return scanPunctuator('.');\n        case 61:\n          // =\n          if (61 === next) return scanPunctuator('==');\n          return scanPunctuator('=');\n        case 62:\n          // >\n          if (features.bitwiseOperators) if (62 === next) return scanPunctuator('>>');\n          if (61 === next) return scanPunctuator('>=');\n          return scanPunctuator('>');\n        case 60:\n          // <\n          if (features.bitwiseOperators) if (60 === next) return scanPunctuator('<<');\n          if (61 === next) return scanPunctuator('<=');\n          return scanPunctuator('<');\n        case 126:\n          // ~\n          if (61 === next) return scanPunctuator('~=');\n          if (!features.bitwiseOperators) break;\n          return scanPunctuator('~');\n        case 58:\n          // :\n          if (features.labels) if (58 === next) return scanPunctuator('::');\n          return scanPunctuator(':');\n        case 91:\n          // [\n          if (91 === next || 61 === next) return scanLongStringLiteral();\n          return scanPunctuator('[');\n        case 47:\n          // /\n          if (features.integerDivision) if (47 === next) return scanPunctuator('//');\n          return scanPunctuator('/');\n        case 38:\n        case 124:\n          // & |\n          if (!features.bitwiseOperators) break;\n        case 42:\n        case 94:\n        case 37:\n        case 44:\n        case 123:\n        case 125:\n        case 93:\n        case 40:\n        case 41:\n        case 59:\n        case 35:\n        case 45:\n        case 43:\n          // * ^ % , { } ] ( ) ; # - +\n          return scanPunctuator(input.charAt(index));\n      }\n      return unexpected(input.charAt(index));\n    }\n    function consumeEOL() {\n      var charCode = input.charCodeAt(index),\n        peekCharCode = input.charCodeAt(index + 1);\n      if (isLineTerminator(charCode)) {\n        if (10 === charCode && 13 === peekCharCode) ++index;\n        if (13 === charCode && 10 === peekCharCode) ++index;\n        ++line;\n        lineStart = ++index;\n        return true;\n      }\n      return false;\n    }\n    function skipWhiteSpace() {\n      while (index < length) {\n        var charCode = input.charCodeAt(index);\n        if (isWhiteSpace(charCode)) {\n          ++index;\n        } else if (!consumeEOL()) {\n          break;\n        }\n      }\n    }\n    function scanIdentifierOrKeyword() {\n      var value, type;\n      while (isIdentifierPart(input.charCodeAt(++index)));\n      value = encodingMode.fixup(input.slice(tokenStart, index));\n      if (isKeyword(value)) {\n        type = Keyword;\n      } else if ('true' === value || 'false' === value) {\n        type = BooleanLiteral;\n        value = 'true' === value;\n      } else if ('nil' === value) {\n        type = NilLiteral;\n        value = null;\n      } else {\n        type = Identifier;\n      }\n      return {\n        type: type,\n        value: value,\n        line: line,\n        lineStart: lineStart,\n        range: [tokenStart, index]\n      };\n    }\n    function scanPunctuator(value) {\n      index += value.length;\n      return {\n        type: Punctuator,\n        value: value,\n        line: line,\n        lineStart: lineStart,\n        range: [tokenStart, index]\n      };\n    }\n    function scanVarargLiteral() {\n      index += 3;\n      return {\n        type: VarargLiteral,\n        value: '...',\n        line: line,\n        lineStart: lineStart,\n        range: [tokenStart, index]\n      };\n    }\n    function scanStringLiteral() {\n      var delimiter = input.charCodeAt(index++),\n        beginLine = line,\n        beginLineStart = lineStart,\n        stringStart = index,\n        string = encodingMode.discardStrings ? null : '',\n        charCode;\n      for (;;) {\n        charCode = input.charCodeAt(index++);\n        if (delimiter === charCode) break;\n        if (index > length || isLineTerminator(charCode)) {\n          string += input.slice(stringStart, index - 1);\n          raise(null, errors.unfinishedString, input.slice(tokenStart, index - 1));\n        }\n        if (92 === charCode) {\n          // backslash\n          if (!encodingMode.discardStrings) {\n            var beforeEscape = input.slice(stringStart, index - 1);\n            string += encodingMode.fixup(beforeEscape);\n          }\n          var escapeValue = readEscapeSequence();\n          if (!encodingMode.discardStrings) string += escapeValue;\n          stringStart = index;\n        }\n      }\n      if (!encodingMode.discardStrings) {\n        string += encodingMode.encodeByte(null);\n        string += encodingMode.fixup(input.slice(stringStart, index - 1));\n      }\n      return {\n        type: StringLiteral,\n        value: string,\n        line: beginLine,\n        lineStart: beginLineStart,\n        lastLine: line,\n        lastLineStart: lineStart,\n        range: [tokenStart, index]\n      };\n    }\n    function scanLongStringLiteral() {\n      var beginLine = line,\n        beginLineStart = lineStart,\n        string = readLongString(false);\n      if (false === string) raise(token, errors.expected, '[', tokenValue(token));\n      return {\n        type: StringLiteral,\n        value: encodingMode.discardStrings ? null : encodingMode.fixup(string),\n        line: beginLine,\n        lineStart: beginLineStart,\n        lastLine: line,\n        lastLineStart: lineStart,\n        range: [tokenStart, index]\n      };\n    }\n    function scanNumericLiteral() {\n      var character = input.charAt(index),\n        next = input.charAt(index + 1);\n      var literal = '0' === character && 'xX'.indexOf(next || null) >= 0 ? readHexLiteral() : readDecLiteral();\n      var foundImaginaryUnit = readImaginaryUnitSuffix(),\n        foundInt64Suffix = readInt64Suffix();\n      if (foundInt64Suffix && (foundImaginaryUnit || literal.hasFractionPart)) {\n        raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n      }\n      return {\n        type: NumericLiteral,\n        value: literal.value,\n        line: line,\n        lineStart: lineStart,\n        range: [tokenStart, index]\n      };\n    }\n    function readImaginaryUnitSuffix() {\n      if (!features.imaginaryNumbers) return;\n      if ('iI'.indexOf(input.charAt(index) || null) >= 0) {\n        ++index;\n        return true;\n      } else {\n        return false;\n      }\n    }\n    function readInt64Suffix() {\n      if (!features.integerSuffixes) return;\n      if ('uU'.indexOf(input.charAt(index) || null) >= 0) {\n        ++index;\n        if ('lL'.indexOf(input.charAt(index) || null) >= 0) {\n          ++index;\n          if ('lL'.indexOf(input.charAt(index) || null) >= 0) {\n            ++index;\n            return 'ULL';\n          } else {\n            raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n          }\n        } else {\n          raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n        }\n      } else if ('lL'.indexOf(input.charAt(index) || null) >= 0) {\n        ++index;\n        if ('lL'.indexOf(input.charAt(index) || null) >= 0) {\n          ++index;\n          return 'LL';\n        } else {\n          raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n        }\n      }\n    }\n    function readHexLiteral() {\n      var fraction = 0 // defaults to 0 as it gets summed\n        ,\n        binaryExponent = 1 // defaults to 1 as it gets multiplied\n        ,\n        binarySign = 1 // positive\n        ,\n        digit,\n        fractionStart,\n        exponentStart,\n        digitStart;\n      digitStart = index += 2; // Skip 0x part\n      if (!isHexDigit(input.charCodeAt(index))) raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n      while (isHexDigit(input.charCodeAt(index))) ++index;\n      digit = parseInt(input.slice(digitStart, index), 16);\n      var foundFraction = false;\n      if ('.' === input.charAt(index)) {\n        foundFraction = true;\n        fractionStart = ++index;\n        while (isHexDigit(input.charCodeAt(index))) ++index;\n        fraction = input.slice(fractionStart, index);\n        fraction = fractionStart === index ? 0 : parseInt(fraction, 16) / Math.pow(16, index - fractionStart);\n      }\n      var foundBinaryExponent = false;\n      if ('pP'.indexOf(input.charAt(index) || null) >= 0) {\n        foundBinaryExponent = true;\n        ++index;\n        if ('+-'.indexOf(input.charAt(index) || null) >= 0) binarySign = '+' === input.charAt(index++) ? 1 : -1;\n        exponentStart = index;\n        if (!isDecDigit(input.charCodeAt(index))) raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n        while (isDecDigit(input.charCodeAt(index))) ++index;\n        binaryExponent = input.slice(exponentStart, index);\n        binaryExponent = Math.pow(2, binaryExponent * binarySign);\n      }\n      return {\n        value: (digit + fraction) * binaryExponent,\n        hasFractionPart: foundFraction || foundBinaryExponent\n      };\n    }\n    function readDecLiteral() {\n      while (isDecDigit(input.charCodeAt(index))) ++index;\n      var foundFraction = false;\n      if ('.' === input.charAt(index)) {\n        foundFraction = true;\n        ++index;\n        while (isDecDigit(input.charCodeAt(index))) ++index;\n      }\n      var foundExponent = false;\n      if ('eE'.indexOf(input.charAt(index) || null) >= 0) {\n        foundExponent = true;\n        ++index;\n        if ('+-'.indexOf(input.charAt(index) || null) >= 0) ++index;\n        if (!isDecDigit(input.charCodeAt(index))) raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n        while (isDecDigit(input.charCodeAt(index))) ++index;\n      }\n      return {\n        value: parseFloat(input.slice(tokenStart, index)),\n        hasFractionPart: foundFraction || foundExponent\n      };\n    }\n    function readUnicodeEscapeSequence() {\n      var sequenceStart = index++;\n      if (input.charAt(index++) !== '{') raise(null, errors.braceExpected, '{', '\\\\' + input.slice(sequenceStart, index));\n      if (!isHexDigit(input.charCodeAt(index))) raise(null, errors.hexadecimalDigitExpected, '\\\\' + input.slice(sequenceStart, index));\n      while (input.charCodeAt(index) === 0x30) ++index;\n      var escStart = index;\n      while (isHexDigit(input.charCodeAt(index))) {\n        ++index;\n        if (index - escStart > 6) raise(null, errors.tooLargeCodepoint, '\\\\' + input.slice(sequenceStart, index));\n      }\n      var b = input.charAt(index++);\n      if (b !== '}') {\n        if (b === '\"' || b === \"'\") raise(null, errors.braceExpected, '}', '\\\\' + input.slice(sequenceStart, index--));else raise(null, errors.hexadecimalDigitExpected, '\\\\' + input.slice(sequenceStart, index));\n      }\n      var codepoint = parseInt(input.slice(escStart, index - 1) || '0', 16);\n      var frag = '\\\\' + input.slice(sequenceStart, index);\n      if (codepoint > 0x10ffff) {\n        raise(null, errors.tooLargeCodepoint, frag);\n      }\n      return encodingMode.encodeUTF8(codepoint, frag);\n    }\n    function readEscapeSequence() {\n      var sequenceStart = index;\n      switch (input.charAt(index)) {\n        case 'a':\n          ++index;\n          return '\\x07';\n        case 'n':\n          ++index;\n          return '\\n';\n        case 'r':\n          ++index;\n          return '\\r';\n        case 't':\n          ++index;\n          return '\\t';\n        case 'v':\n          ++index;\n          return '\\x0b';\n        case 'b':\n          ++index;\n          return '\\b';\n        case 'f':\n          ++index;\n          return '\\f';\n        case '\\r':\n        case '\\n':\n          consumeEOL();\n          return '\\n';\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          while (isDecDigit(input.charCodeAt(index)) && index - sequenceStart < 3) ++index;\n          var frag = input.slice(sequenceStart, index);\n          var ddd = parseInt(frag, 10);\n          if (ddd > 255) {\n            raise(null, errors.decimalEscapeTooLarge, '\\\\' + ddd);\n          }\n          return encodingMode.encodeByte(ddd, '\\\\' + frag);\n        case 'z':\n          if (features.skipWhitespaceEscape) {\n            ++index;\n            skipWhiteSpace();\n            return '';\n          }\n          break;\n        case 'x':\n          if (features.hexEscapes) {\n            if (isHexDigit(input.charCodeAt(index + 1)) && isHexDigit(input.charCodeAt(index + 2))) {\n              index += 3;\n              return encodingMode.encodeByte(parseInt(input.slice(sequenceStart + 1, index), 16), '\\\\' + input.slice(sequenceStart, index));\n            }\n            raise(null, errors.hexadecimalDigitExpected, '\\\\' + input.slice(sequenceStart, index + 2));\n          }\n          break;\n        case 'u':\n          if (features.unicodeEscapes) return readUnicodeEscapeSequence();\n          break;\n        case '\\\\':\n        case '\"':\n        case \"'\":\n          return input.charAt(index++);\n      }\n      if (features.strictEscapes) raise(null, errors.invalidEscape, '\\\\' + input.slice(sequenceStart, index + 1));\n      return input.charAt(index++);\n    }\n    function scanComment() {\n      tokenStart = index;\n      index += 2; // --\n\n      var character = input.charAt(index),\n        content = '',\n        isLong = false,\n        commentStart = index,\n        lineStartComment = lineStart,\n        lineComment = line;\n      if ('[' === character) {\n        content = readLongString(true);\n        if (false === content) content = character;else isLong = true;\n      }\n      if (!isLong) {\n        while (index < length) {\n          if (isLineTerminator(input.charCodeAt(index))) break;\n          ++index;\n        }\n        if (options.comments) content = input.slice(commentStart, index);\n      }\n      if (options.comments) {\n        var node = ast.comment(content, input.slice(tokenStart, index));\n        if (options.locations) {\n          node.loc = {\n            start: {\n              line: lineComment,\n              column: tokenStart - lineStartComment\n            },\n            end: {\n              line: line,\n              column: index - lineStart\n            }\n          };\n        }\n        if (options.ranges) {\n          node.range = [tokenStart, index];\n        }\n        if (options.onCreateNode) options.onCreateNode(node);\n        comments.push(node);\n      }\n    }\n    function readLongString(isComment) {\n      var level = 0,\n        content = '',\n        terminator = false,\n        character,\n        stringStart,\n        firstLine = line;\n      ++index; // [\n      while ('=' === input.charAt(index + level)) ++level;\n      if ('[' !== input.charAt(index + level)) return false;\n      index += level + 1;\n      if (isLineTerminator(input.charCodeAt(index))) consumeEOL();\n      stringStart = index;\n      while (index < length) {\n        while (isLineTerminator(input.charCodeAt(index))) consumeEOL();\n        character = input.charAt(index++);\n        if (']' === character) {\n          terminator = true;\n          for (var i = 0; i < level; ++i) {\n            if ('=' !== input.charAt(index + i)) terminator = false;\n          }\n          if (']' !== input.charAt(index + level)) terminator = false;\n        }\n        if (terminator) {\n          content += input.slice(stringStart, index - 1);\n          index += level + 1;\n          return content;\n        }\n      }\n      raise(null, isComment ? errors.unfinishedLongComment : errors.unfinishedLongString, firstLine, '<eof>');\n    }\n    function next() {\n      previousToken = token;\n      token = lookahead;\n      lookahead = lex();\n    }\n    function consume(value) {\n      if (value === token.value) {\n        next();\n        return true;\n      }\n      return false;\n    }\n    function expect(value) {\n      if (value === token.value) next();else raise(token, errors.expected, value, tokenValue(token));\n    }\n    function isWhiteSpace(charCode) {\n      return 9 === charCode || 32 === charCode || 0xB === charCode || 0xC === charCode;\n    }\n    function isLineTerminator(charCode) {\n      return 10 === charCode || 13 === charCode;\n    }\n    function isDecDigit(charCode) {\n      return charCode >= 48 && charCode <= 57;\n    }\n    function isHexDigit(charCode) {\n      return charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70;\n    }\n    function isIdentifierStart(charCode) {\n      if (charCode >= 65 && charCode <= 90 || charCode >= 97 && charCode <= 122 || 95 === charCode) return true;\n      if (features.extendedIdentifiers && charCode >= 128) return true;\n      return false;\n    }\n    function isIdentifierPart(charCode) {\n      if (charCode >= 65 && charCode <= 90 || charCode >= 97 && charCode <= 122 || 95 === charCode || charCode >= 48 && charCode <= 57) return true;\n      if (features.extendedIdentifiers && charCode >= 128) return true;\n      return false;\n    }\n    function isKeyword(id) {\n      switch (id.length) {\n        case 2:\n          return 'do' === id || 'if' === id || 'in' === id || 'or' === id;\n        case 3:\n          return 'and' === id || 'end' === id || 'for' === id || 'not' === id;\n        case 4:\n          if ('else' === id || 'then' === id) return true;\n          if (features.labels && !features.contextualGoto) return 'goto' === id;\n          return false;\n        case 5:\n          return 'break' === id || 'local' === id || 'until' === id || 'while' === id;\n        case 6:\n          return 'elseif' === id || 'repeat' === id || 'return' === id;\n        case 8:\n          return 'function' === id;\n      }\n      return false;\n    }\n    function isUnary(token) {\n      if (Punctuator === token.type) return '#-~'.indexOf(token.value) >= 0;\n      if (Keyword === token.type) return 'not' === token.value;\n      return false;\n    }\n    function isBlockFollow(token) {\n      if (EOF === token.type) return true;\n      if (Keyword !== token.type) return false;\n      switch (token.value) {\n        case 'else':\n        case 'elseif':\n        case 'end':\n        case 'until':\n          return true;\n        default:\n          return false;\n      }\n    }\n    var scopes, scopeDepth, globals;\n    function createScope() {\n      var scope = scopes[scopeDepth++].slice();\n      scopes.push(scope);\n      if (options.onCreateScope) options.onCreateScope();\n    }\n    function destroyScope() {\n      var scope = scopes.pop();\n      --scopeDepth;\n      if (options.onDestroyScope) options.onDestroyScope();\n    }\n    function scopeIdentifierName(name) {\n      if (options.onLocalDeclaration) options.onLocalDeclaration(name);\n      if (-1 !== indexOf(scopes[scopeDepth], name)) return;\n      scopes[scopeDepth].push(name);\n    }\n    function scopeIdentifier(node) {\n      scopeIdentifierName(node.name);\n      attachScope(node, true);\n    }\n    function attachScope(node, isLocal) {\n      if (!isLocal && -1 === indexOfObject(globals, 'name', node.name)) globals.push(node);\n      node.isLocal = isLocal;\n    }\n    function scopeHasName(name) {\n      return -1 !== indexOf(scopes[scopeDepth], name);\n    }\n    var locations = [],\n      trackLocations;\n    function createLocationMarker() {\n      return new Marker(token);\n    }\n    function Marker(token) {\n      if (options.locations) {\n        this.loc = {\n          start: {\n            line: token.line,\n            column: token.range[0] - token.lineStart\n          },\n          end: {\n            line: 0,\n            column: 0\n          }\n        };\n      }\n      if (options.ranges) this.range = [token.range[0], 0];\n    }\n    Marker.prototype.complete = function () {\n      if (options.locations) {\n        this.loc.end.line = previousToken.lastLine || previousToken.line;\n        this.loc.end.column = previousToken.range[1] - (previousToken.lastLineStart || previousToken.lineStart);\n      }\n      if (options.ranges) {\n        this.range[1] = previousToken.range[1];\n      }\n    };\n    Marker.prototype.bless = function (node) {\n      if (this.loc) {\n        var loc = this.loc;\n        node.loc = {\n          start: {\n            line: loc.start.line,\n            column: loc.start.column\n          },\n          end: {\n            line: loc.end.line,\n            column: loc.end.column\n          }\n        };\n      }\n      if (this.range) {\n        node.range = [this.range[0], this.range[1]];\n      }\n    };\n    function markLocation() {\n      if (trackLocations) locations.push(createLocationMarker());\n    }\n    function pushLocation(marker) {\n      if (trackLocations) locations.push(marker);\n    }\n    function FullFlowContext() {\n      this.scopes = [];\n      this.pendingGotos = [];\n    }\n    FullFlowContext.prototype.isInLoop = function () {\n      var i = this.scopes.length;\n      while (i-- > 0) {\n        if (this.scopes[i].isLoop) return true;\n      }\n      return false;\n    };\n    FullFlowContext.prototype.pushScope = function (isLoop) {\n      var scope = {\n        labels: {},\n        locals: [],\n        deferredGotos: [],\n        isLoop: !!isLoop\n      };\n      this.scopes.push(scope);\n    };\n    FullFlowContext.prototype.popScope = function () {\n      for (var i = 0; i < this.pendingGotos.length; ++i) {\n        var theGoto = this.pendingGotos[i];\n        if (theGoto.maxDepth >= this.scopes.length) if (--theGoto.maxDepth <= 0) raise(theGoto.token, errors.labelNotVisible, theGoto.target);\n      }\n      this.scopes.pop();\n    };\n    FullFlowContext.prototype.addGoto = function (target, token) {\n      var localCounts = [];\n      for (var i = 0; i < this.scopes.length; ++i) {\n        var scope = this.scopes[i];\n        localCounts.push(scope.locals.length);\n        if (Object.prototype.hasOwnProperty.call(scope.labels, target)) return;\n      }\n      this.pendingGotos.push({\n        maxDepth: this.scopes.length,\n        target: target,\n        token: token,\n        localCounts: localCounts\n      });\n    };\n    FullFlowContext.prototype.addLabel = function (name, token) {\n      var scope = this.currentScope();\n      if (Object.prototype.hasOwnProperty.call(scope.labels, name)) {\n        raise(token, errors.labelAlreadyDefined, name, scope.labels[name].line);\n      } else {\n        var newGotos = [];\n        for (var i = 0; i < this.pendingGotos.length; ++i) {\n          var theGoto = this.pendingGotos[i];\n          if (theGoto.maxDepth >= this.scopes.length && theGoto.target === name) {\n            if (theGoto.localCounts[this.scopes.length - 1] < scope.locals.length) {\n              scope.deferredGotos.push(theGoto);\n            }\n            continue;\n          }\n          newGotos.push(theGoto);\n        }\n        this.pendingGotos = newGotos;\n      }\n      scope.labels[name] = {\n        localCount: scope.locals.length,\n        line: token.line\n      };\n    };\n    FullFlowContext.prototype.addLocal = function (name, token) {\n      this.currentScope().locals.push({\n        name: name,\n        token: token\n      });\n    };\n    FullFlowContext.prototype.currentScope = function () {\n      return this.scopes[this.scopes.length - 1];\n    };\n    FullFlowContext.prototype.raiseDeferredErrors = function () {\n      var scope = this.currentScope();\n      var bads = scope.deferredGotos;\n      for (var i = 0; i < bads.length; ++i) {\n        var theGoto = bads[i];\n        raise(theGoto.token, errors.gotoJumpInLocalScope, theGoto.target, scope.locals[theGoto.localCounts[this.scopes.length - 1]].name);\n      }\n    };\n    function LoopFlowContext() {\n      this.level = 0;\n      this.loopLevels = [];\n    }\n    LoopFlowContext.prototype.isInLoop = function () {\n      return !!this.loopLevels.length;\n    };\n    LoopFlowContext.prototype.pushScope = function (isLoop) {\n      ++this.level;\n      if (isLoop) this.loopLevels.push(this.level);\n    };\n    LoopFlowContext.prototype.popScope = function () {\n      var levels = this.loopLevels;\n      var levlen = levels.length;\n      if (levlen) {\n        if (levels[levlen - 1] === this.level) levels.pop();\n      }\n      --this.level;\n    };\n    LoopFlowContext.prototype.addGoto = LoopFlowContext.prototype.addLabel = function () {\n      throw new Error('This should never happen');\n    };\n    LoopFlowContext.prototype.addLocal = LoopFlowContext.prototype.raiseDeferredErrors = function () {};\n    function makeFlowContext() {\n      return features.labels ? new FullFlowContext() : new LoopFlowContext();\n    }\n    function parseChunk() {\n      next();\n      markLocation();\n      if (options.scope) createScope();\n      var flowContext = makeFlowContext();\n      flowContext.allowVararg = true;\n      flowContext.pushScope();\n      var body = parseBlock(flowContext);\n      flowContext.popScope();\n      if (options.scope) destroyScope();\n      if (EOF !== token.type) unexpected(token);\n      if (trackLocations && !body.length) previousToken = token;\n      return finishNode(ast.chunk(body));\n    }\n    function parseBlock(flowContext) {\n      var block = [],\n        statement;\n      while (!isBlockFollow(token)) {\n        if ('return' === token.value || !features.relaxedBreak && 'break' === token.value) {\n          block.push(parseStatement(flowContext));\n          break;\n        }\n        statement = parseStatement(flowContext);\n        consume(';');\n        if (statement) block.push(statement);\n      }\n      return block;\n    }\n    function parseStatement(flowContext) {\n      markLocation();\n      if (Punctuator === token.type) {\n        if (consume('::')) return parseLabelStatement(flowContext);\n      }\n      if (features.emptyStatement) {\n        if (consume(';')) {\n          if (trackLocations) locations.pop();\n          return;\n        }\n      }\n      flowContext.raiseDeferredErrors();\n      if (Keyword === token.type) {\n        switch (token.value) {\n          case 'local':\n            next();\n            return parseLocalStatement(flowContext);\n          case 'if':\n            next();\n            return parseIfStatement(flowContext);\n          case 'return':\n            next();\n            return parseReturnStatement(flowContext);\n          case 'function':\n            next();\n            var name = parseFunctionName();\n            return parseFunctionDeclaration(name);\n          case 'while':\n            next();\n            return parseWhileStatement(flowContext);\n          case 'for':\n            next();\n            return parseForStatement(flowContext);\n          case 'repeat':\n            next();\n            return parseRepeatStatement(flowContext);\n          case 'break':\n            next();\n            if (!flowContext.isInLoop()) raise(token, errors.noLoopToBreak, token.value);\n            return parseBreakStatement();\n          case 'do':\n            next();\n            return parseDoStatement(flowContext);\n          case 'goto':\n            next();\n            return parseGotoStatement(flowContext);\n        }\n      }\n      if (features.contextualGoto && token.type === Identifier && token.value === 'goto' && lookahead.type === Identifier && lookahead.value !== 'goto') {\n        next();\n        return parseGotoStatement(flowContext);\n      }\n      if (trackLocations) locations.pop();\n      return parseAssignmentOrCallStatement(flowContext);\n    }\n    function parseLabelStatement(flowContext) {\n      var nameToken = token,\n        label = parseIdentifier();\n      if (options.scope) {\n        scopeIdentifierName('::' + nameToken.value + '::');\n        attachScope(label, true);\n      }\n      expect('::');\n      flowContext.addLabel(nameToken.value, nameToken);\n      return finishNode(ast.labelStatement(label));\n    }\n    function parseBreakStatement() {\n      return finishNode(ast.breakStatement());\n    }\n    function parseGotoStatement(flowContext) {\n      var name = token.value,\n        gotoToken = previousToken,\n        label = parseIdentifier();\n      flowContext.addGoto(name, gotoToken);\n      return finishNode(ast.gotoStatement(label));\n    }\n    function parseDoStatement(flowContext) {\n      if (options.scope) createScope();\n      flowContext.pushScope();\n      var body = parseBlock(flowContext);\n      flowContext.popScope();\n      if (options.scope) destroyScope();\n      expect('end');\n      return finishNode(ast.doStatement(body));\n    }\n    function parseWhileStatement(flowContext) {\n      var condition = parseExpectedExpression(flowContext);\n      expect('do');\n      if (options.scope) createScope();\n      flowContext.pushScope(true);\n      var body = parseBlock(flowContext);\n      flowContext.popScope();\n      if (options.scope) destroyScope();\n      expect('end');\n      return finishNode(ast.whileStatement(condition, body));\n    }\n    function parseRepeatStatement(flowContext) {\n      if (options.scope) createScope();\n      flowContext.pushScope(true);\n      var body = parseBlock(flowContext);\n      expect('until');\n      flowContext.raiseDeferredErrors();\n      var condition = parseExpectedExpression(flowContext);\n      flowContext.popScope();\n      if (options.scope) destroyScope();\n      return finishNode(ast.repeatStatement(condition, body));\n    }\n    function parseReturnStatement(flowContext) {\n      var expressions = [];\n      if ('end' !== token.value) {\n        var expression = parseExpression(flowContext);\n        if (null != expression) expressions.push(expression);\n        while (consume(',')) {\n          expression = parseExpectedExpression(flowContext);\n          expressions.push(expression);\n        }\n        consume(';'); // grammar tells us ; is optional here.\n      }\n\n      return finishNode(ast.returnStatement(expressions));\n    }\n    function parseIfStatement(flowContext) {\n      var clauses = [],\n        condition,\n        body,\n        marker;\n      if (trackLocations) {\n        marker = locations[locations.length - 1];\n        locations.push(marker);\n      }\n      condition = parseExpectedExpression(flowContext);\n      expect('then');\n      if (options.scope) createScope();\n      flowContext.pushScope();\n      body = parseBlock(flowContext);\n      flowContext.popScope();\n      if (options.scope) destroyScope();\n      clauses.push(finishNode(ast.ifClause(condition, body)));\n      if (trackLocations) marker = createLocationMarker();\n      while (consume('elseif')) {\n        pushLocation(marker);\n        condition = parseExpectedExpression(flowContext);\n        expect('then');\n        if (options.scope) createScope();\n        flowContext.pushScope();\n        body = parseBlock(flowContext);\n        flowContext.popScope();\n        if (options.scope) destroyScope();\n        clauses.push(finishNode(ast.elseifClause(condition, body)));\n        if (trackLocations) marker = createLocationMarker();\n      }\n      if (consume('else')) {\n        if (trackLocations) {\n          marker = new Marker(previousToken);\n          locations.push(marker);\n        }\n        if (options.scope) createScope();\n        flowContext.pushScope();\n        body = parseBlock(flowContext);\n        flowContext.popScope();\n        if (options.scope) destroyScope();\n        clauses.push(finishNode(ast.elseClause(body)));\n      }\n      expect('end');\n      return finishNode(ast.ifStatement(clauses));\n    }\n    function parseForStatement(flowContext) {\n      var variable = parseIdentifier(),\n        body;\n      if (options.scope) {\n        createScope();\n        scopeIdentifier(variable);\n      }\n      if (consume('=')) {\n        var start = parseExpectedExpression(flowContext);\n        expect(',');\n        var end = parseExpectedExpression(flowContext);\n        var step = consume(',') ? parseExpectedExpression(flowContext) : null;\n        expect('do');\n        flowContext.pushScope(true);\n        body = parseBlock(flowContext);\n        flowContext.popScope();\n        expect('end');\n        if (options.scope) destroyScope();\n        return finishNode(ast.forNumericStatement(variable, start, end, step, body));\n      } else {\n        var variables = [variable];\n        while (consume(',')) {\n          variable = parseIdentifier();\n          if (options.scope) scopeIdentifier(variable);\n          variables.push(variable);\n        }\n        expect('in');\n        var iterators = [];\n        do {\n          var expression = parseExpectedExpression(flowContext);\n          iterators.push(expression);\n        } while (consume(','));\n        expect('do');\n        flowContext.pushScope(true);\n        body = parseBlock(flowContext);\n        flowContext.popScope();\n        expect('end');\n        if (options.scope) destroyScope();\n        return finishNode(ast.forGenericStatement(variables, iterators, body));\n      }\n    }\n    function parseLocalStatement(flowContext) {\n      var name,\n        declToken = previousToken;\n      if (Identifier === token.type) {\n        var variables = [],\n          init = [];\n        do {\n          name = parseIdentifier();\n          variables.push(name);\n          flowContext.addLocal(name.name, declToken);\n        } while (consume(','));\n        if (consume('=')) {\n          do {\n            var expression = parseExpectedExpression(flowContext);\n            init.push(expression);\n          } while (consume(','));\n        }\n        if (options.scope) {\n          for (var i = 0, l = variables.length; i < l; ++i) {\n            scopeIdentifier(variables[i]);\n          }\n        }\n        return finishNode(ast.localStatement(variables, init));\n      }\n      if (consume('function')) {\n        name = parseIdentifier();\n        flowContext.addLocal(name.name, declToken);\n        if (options.scope) {\n          scopeIdentifier(name);\n          createScope();\n        }\n        return parseFunctionDeclaration(name, true);\n      } else {\n        raiseUnexpectedToken('<name>', token);\n      }\n    }\n    function parseAssignmentOrCallStatement(flowContext) {\n      var previous = token,\n        marker,\n        startMarker;\n      var lvalue, base, name;\n      var targets = [];\n      if (trackLocations) startMarker = createLocationMarker();\n      do {\n        if (trackLocations) marker = createLocationMarker();\n        if (Identifier === token.type) {\n          name = token.value;\n          base = parseIdentifier();\n          if (options.scope) attachScope(base, scopeHasName(name));\n          lvalue = true;\n        } else if ('(' === token.value) {\n          next();\n          base = parseExpectedExpression(flowContext);\n          expect(')');\n          lvalue = false;\n        } else {\n          return unexpected(token);\n        }\n        both: for (;;) {\n          var newBase;\n          switch (StringLiteral === token.type ? '\"' : token.value) {\n            case '.':\n            case '[':\n              lvalue = true;\n              break;\n            case ':':\n            case '(':\n            case '{':\n            case '\"':\n              lvalue = null;\n              break;\n            default:\n              break both;\n          }\n          base = parsePrefixExpressionPart(base, marker, flowContext);\n        }\n        targets.push(base);\n        if (',' !== token.value) break;\n        if (!lvalue) {\n          return unexpected(token);\n        }\n        next();\n      } while (true);\n      if (targets.length === 1 && lvalue === null) {\n        pushLocation(marker);\n        return finishNode(ast.callStatement(targets[0]));\n      } else if (!lvalue) {\n        return unexpected(token);\n      }\n      expect('=');\n      var values = [];\n      do {\n        values.push(parseExpectedExpression(flowContext));\n      } while (consume(','));\n      pushLocation(startMarker);\n      return finishNode(ast.assignmentStatement(targets, values));\n    }\n    function parseIdentifier() {\n      markLocation();\n      var identifier = token.value;\n      if (Identifier !== token.type) raiseUnexpectedToken('<name>', token);\n      next();\n      return finishNode(ast.identifier(identifier));\n    }\n    function parseFunctionDeclaration(name, isLocal) {\n      var flowContext = makeFlowContext();\n      flowContext.pushScope();\n      var parameters = [];\n      expect('(');\n      if (!consume(')')) {\n        while (true) {\n          if (Identifier === token.type) {\n            var parameter = parseIdentifier();\n            if (options.scope) scopeIdentifier(parameter);\n            parameters.push(parameter);\n            if (consume(',')) continue;\n          } else if (VarargLiteral === token.type) {\n            flowContext.allowVararg = true;\n            parameters.push(parsePrimaryExpression(flowContext));\n          } else {\n            raiseUnexpectedToken('<name> or \\'...\\'', token);\n          }\n          expect(')');\n          break;\n        }\n      }\n      var body = parseBlock(flowContext);\n      flowContext.popScope();\n      expect('end');\n      if (options.scope) destroyScope();\n      isLocal = isLocal || false;\n      return finishNode(ast.functionStatement(name, parameters, isLocal, body));\n    }\n    function parseFunctionName() {\n      var base, name, marker;\n      if (trackLocations) marker = createLocationMarker();\n      base = parseIdentifier();\n      if (options.scope) {\n        attachScope(base, scopeHasName(base.name));\n        createScope();\n      }\n      while (consume('.')) {\n        pushLocation(marker);\n        name = parseIdentifier();\n        base = finishNode(ast.memberExpression(base, '.', name));\n      }\n      if (consume(':')) {\n        pushLocation(marker);\n        name = parseIdentifier();\n        base = finishNode(ast.memberExpression(base, ':', name));\n        if (options.scope) scopeIdentifierName('self');\n      }\n      return base;\n    }\n    function parseTableConstructor(flowContext) {\n      var fields = [],\n        key,\n        value;\n      while (true) {\n        markLocation();\n        if (Punctuator === token.type && consume('[')) {\n          key = parseExpectedExpression(flowContext);\n          expect(']');\n          expect('=');\n          value = parseExpectedExpression(flowContext);\n          fields.push(finishNode(ast.tableKey(key, value)));\n        } else if (Identifier === token.type) {\n          if ('=' === lookahead.value) {\n            key = parseIdentifier();\n            next();\n            value = parseExpectedExpression(flowContext);\n            fields.push(finishNode(ast.tableKeyString(key, value)));\n          } else {\n            value = parseExpectedExpression(flowContext);\n            fields.push(finishNode(ast.tableValue(value)));\n          }\n        } else {\n          if (null == (value = parseExpression(flowContext))) {\n            locations.pop();\n            break;\n          }\n          fields.push(finishNode(ast.tableValue(value)));\n        }\n        if (',;'.indexOf(token.value) >= 0) {\n          next();\n          continue;\n        }\n        break;\n      }\n      expect('}');\n      return finishNode(ast.tableConstructorExpression(fields));\n    }\n    function parseExpression(flowContext) {\n      var expression = parseSubExpression(0, flowContext);\n      return expression;\n    }\n    function parseExpectedExpression(flowContext) {\n      var expression = parseExpression(flowContext);\n      if (null == expression) raiseUnexpectedToken('<expression>', token);else return expression;\n    }\n    function binaryPrecedence(operator) {\n      var charCode = operator.charCodeAt(0),\n        length = operator.length;\n      if (1 === length) {\n        switch (charCode) {\n          case 94:\n            return 12;\n          // ^\n          case 42:\n          case 47:\n          case 37:\n            return 10;\n          // * / %\n          case 43:\n          case 45:\n            return 9;\n          // + -\n          case 38:\n            return 6;\n          // &\n          case 126:\n            return 5;\n          // ~\n          case 124:\n            return 4;\n          // |\n          case 60:\n          case 62:\n            return 3;\n          // < >\n        }\n      } else if (2 === length) {\n        switch (charCode) {\n          case 47:\n            return 10;\n          // //\n          case 46:\n            return 8;\n          // ..\n          case 60:\n          case 62:\n            if ('<<' === operator || '>>' === operator) return 7; // << >>\n            return 3;\n          // <= >=\n          case 61:\n          case 126:\n            return 3;\n          // == ~=\n          case 111:\n            return 1;\n          // or\n        }\n      } else if (97 === charCode && 'and' === operator) return 2;\n      return 0;\n    }\n    function parseSubExpression(minPrecedence, flowContext) {\n      var operator = token.value,\n        expression,\n        marker;\n      if (trackLocations) marker = createLocationMarker();\n      if (isUnary(token)) {\n        markLocation();\n        next();\n        var argument = parseSubExpression(10, flowContext);\n        if (argument == null) raiseUnexpectedToken('<expression>', token);\n        expression = finishNode(ast.unaryExpression(operator, argument));\n      }\n      if (null == expression) {\n        expression = parsePrimaryExpression(flowContext);\n        if (null == expression) {\n          expression = parsePrefixExpression(flowContext);\n        }\n      }\n      if (null == expression) return null;\n      var precedence;\n      while (true) {\n        operator = token.value;\n        precedence = Punctuator === token.type || Keyword === token.type ? binaryPrecedence(operator) : 0;\n        if (precedence === 0 || precedence <= minPrecedence) break;\n        if ('^' === operator || '..' === operator) --precedence;\n        next();\n        var right = parseSubExpression(precedence, flowContext);\n        if (null == right) raiseUnexpectedToken('<expression>', token);\n        if (trackLocations) locations.push(marker);\n        expression = finishNode(ast.binaryExpression(operator, expression, right));\n      }\n      return expression;\n    }\n    function parsePrefixExpressionPart(base, marker, flowContext) {\n      var expression, identifier;\n      if (Punctuator === token.type) {\n        switch (token.value) {\n          case '[':\n            pushLocation(marker);\n            next();\n            expression = parseExpectedExpression(flowContext);\n            expect(']');\n            return finishNode(ast.indexExpression(base, expression));\n          case '.':\n            pushLocation(marker);\n            next();\n            identifier = parseIdentifier();\n            return finishNode(ast.memberExpression(base, '.', identifier));\n          case ':':\n            pushLocation(marker);\n            next();\n            identifier = parseIdentifier();\n            base = finishNode(ast.memberExpression(base, ':', identifier));\n            pushLocation(marker);\n            return parseCallExpression(base, flowContext);\n          case '(':\n          case '{':\n            // args\n            pushLocation(marker);\n            return parseCallExpression(base, flowContext);\n        }\n      } else if (StringLiteral === token.type) {\n        pushLocation(marker);\n        return parseCallExpression(base, flowContext);\n      }\n      return null;\n    }\n    function parsePrefixExpression(flowContext) {\n      var base, name, marker;\n      if (trackLocations) marker = createLocationMarker();\n      if (Identifier === token.type) {\n        name = token.value;\n        base = parseIdentifier();\n        if (options.scope) attachScope(base, scopeHasName(name));\n      } else if (consume('(')) {\n        base = parseExpectedExpression(flowContext);\n        expect(')');\n      } else {\n        return null;\n      }\n      for (;;) {\n        var newBase = parsePrefixExpressionPart(base, marker, flowContext);\n        if (newBase === null) break;\n        base = newBase;\n      }\n      return base;\n    }\n    function parseCallExpression(base, flowContext) {\n      if (Punctuator === token.type) {\n        switch (token.value) {\n          case '(':\n            if (!features.emptyStatement) {\n              if (token.line !== previousToken.line) raise(null, errors.ambiguousSyntax, token.value);\n            }\n            next();\n            var expressions = [];\n            var expression = parseExpression(flowContext);\n            if (null != expression) expressions.push(expression);\n            while (consume(',')) {\n              expression = parseExpectedExpression(flowContext);\n              expressions.push(expression);\n            }\n            expect(')');\n            return finishNode(ast.callExpression(base, expressions));\n          case '{':\n            markLocation();\n            next();\n            var table = parseTableConstructor(flowContext);\n            return finishNode(ast.tableCallExpression(base, table));\n        }\n      } else if (StringLiteral === token.type) {\n        return finishNode(ast.stringCallExpression(base, parsePrimaryExpression(flowContext)));\n      }\n      raiseUnexpectedToken('function arguments', token);\n    }\n    function parsePrimaryExpression(flowContext) {\n      var literals = StringLiteral | NumericLiteral | BooleanLiteral | NilLiteral | VarargLiteral,\n        value = token.value,\n        type = token.type,\n        marker;\n      if (trackLocations) marker = createLocationMarker();\n      if (type === VarargLiteral && !flowContext.allowVararg) {\n        raise(token, errors.cannotUseVararg, token.value);\n      }\n      if (type & literals) {\n        pushLocation(marker);\n        var raw = input.slice(token.range[0], token.range[1]);\n        next();\n        return finishNode(ast.literal(type, value, raw));\n      } else if (Keyword === type && 'function' === value) {\n        pushLocation(marker);\n        next();\n        if (options.scope) createScope();\n        return parseFunctionDeclaration(null);\n      } else if (consume('{')) {\n        pushLocation(marker);\n        return parseTableConstructor(flowContext);\n      }\n    }\n    exports.parse = parse;\n    var versionFeatures = {\n      '5.1': {},\n      '5.2': {\n        labels: true,\n        emptyStatement: true,\n        hexEscapes: true,\n        skipWhitespaceEscape: true,\n        strictEscapes: true,\n        relaxedBreak: true\n      },\n      '5.3': {\n        labels: true,\n        emptyStatement: true,\n        hexEscapes: true,\n        skipWhitespaceEscape: true,\n        strictEscapes: true,\n        unicodeEscapes: true,\n        bitwiseOperators: true,\n        integerDivision: true,\n        relaxedBreak: true\n      },\n      'LuaJIT': {\n        labels: true,\n        contextualGoto: true,\n        hexEscapes: true,\n        skipWhitespaceEscape: true,\n        strictEscapes: true,\n        unicodeEscapes: true,\n        imaginaryNumbers: true,\n        integerSuffixes: true\n      }\n    };\n    function parse(_input, _options) {\n      if ('undefined' === typeof _options && 'object' === typeof _input) {\n        _options = _input;\n        _input = undefined;\n      }\n      if (!_options) _options = {};\n      input = _input || '';\n      options = assign({}, defaultOptions, _options);\n      index = 0;\n      line = 1;\n      lineStart = 0;\n      length = input.length;\n      scopes = [[]];\n      scopeDepth = 0;\n      globals = [];\n      locations = [];\n      if (!Object.prototype.hasOwnProperty.call(versionFeatures, options.luaVersion)) {\n        throw new Error(sprintf(\"Lua version '%1' not supported\", options.luaVersion));\n      }\n      features = assign({}, versionFeatures[options.luaVersion]);\n      if (options.extendedIdentifiers !== void 0) features.extendedIdentifiers = !!options.extendedIdentifiers;\n      if (!Object.prototype.hasOwnProperty.call(encodingModes, options.encodingMode)) {\n        throw new Error(sprintf(\"Encoding mode '%1' not supported\", options.encodingMode));\n      }\n      encodingMode = encodingModes[options.encodingMode];\n      if (options.comments) comments = [];\n      if (!options.wait) return end();\n      return exports;\n    }\n    exports.write = write;\n    function write(_input) {\n      input += String(_input);\n      length = input.length;\n      return exports;\n    }\n    exports.end = end;\n    function end(_input) {\n      if ('undefined' !== typeof _input) write(_input);\n      if (input && input.substr(0, 2) === '#!') input = input.replace(/^.*/, function (line) {\n        return line.replace(/./g, ' ');\n      });\n      length = input.length;\n      trackLocations = options.locations || options.ranges;\n      lookahead = lex();\n      var chunk = parseChunk();\n      if (options.comments) chunk.comments = comments;\n      if (options.scope) chunk.globals = globals;\n      if (locations.length > 0) throw new Error('Location tracking failed. This is most likely a bug in luaparse');\n      return chunk;\n    }\n  });\n});\nace.define(\"ace/mode/lua_worker\", [], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n  var Mirror = require(\"../worker/mirror\").Mirror;\n  var luaparse = require(\"../mode/lua/luaparse\");\n  var Worker = exports.Worker = function (sender) {\n    Mirror.call(this, sender);\n    this.setTimeout(500);\n  };\n  oop.inherits(Worker, Mirror);\n  (function () {\n    this.onUpdate = function () {\n      var value = this.doc.getValue();\n      var errors = [];\n      try {\n        luaparse.parse(value);\n      } catch (e) {\n        if (e instanceof luaparse.SyntaxError) {\n          errors.push({\n            row: e.line - 1,\n            column: e.column,\n            text: e.message,\n            type: \"error\"\n          });\n        }\n      }\n      this.sender.emit(\"annotate\", errors);\n    };\n  }).call(Worker.prototype);\n});","map":{"version":3,"names":["window","document","require","define","console","msgs","Array","prototype","slice","call","arguments","postMessage","type","data","error","warn","log","trace","ace","onerror","message","file","line","col","err","stack","normalizeModule","parentId","moduleName","indexOf","chunks","split","charAt","base","join","previous","replace","id","Error","module","modules","initialized","exports","factory","tlns","path","resolveModuleId","importScripts","paths","testPath","tail","alias","location","main","name","i","lastIndexOf","substr","deps","length","req","childId","returnExports","apply","map","dep","amd","initBaseUrls","topLevelNamespaces","initSender","EventEmitter","oop","Sender","implement","callback","callbackId","emit","sender","onmessage","e","msg","event","_signal","command","args","init","clazz","classname","inherits","ctor","superCtor","super_","Object","create","constructor","value","enumerable","writable","configurable","mixin","obj","key","proto","throwDeltaError","delta","errorText","positionInDocument","docLines","position","row","column","validateDelta","action","lines","start","end","numRangeRows","numRangeLastLineChars","applyDelta","doNotValidate","startColumn","substring","concat","splice","endColumn","endRow","stopPropagation","propagationStopped","preventDefault","defaultPrevented","_emit","_dispatchEvent","eventName","_eventRegistry","_defaultHandlers","listeners","defaultHandler","once","_self","on","newCallback","off","Promise","resolve","setDefaultHandler","handlers","_disabled_","old","disabled","push","removeDefaultHandler","pop","addEventListener","capturing","removeListener","removeEventListener","index","removeAllListeners","undefined","comparePoints","p1","p2","Range","startRow","isEqual","range","toString","contains","compare","compareRange","cmp","comparePoint","p","containsRange","intersects","isEnd","isStart","setStart","setEnd","inside","insideStart","insideEnd","isMultiLine","compareStart","compareEnd","compareInside","clipRows","firstRow","lastRow","fromPoints","extend","isEmpty","clone","collapseRows","Math","max","toScreenRange","session","screenPosStart","documentToScreenPosition","screenPosEnd","moveBy","Anchor","doc","$onChange","onChange","bind","attach","setPosition","getPosition","$clipPositionToDocument","getDocument","$insertRight","point","$getTransformedPoint","$pointsInOrder","point1","point2","equalPointsInOrder","bColIsAfter","moveIfEqual","deltaIsInsert","deltaRowShift","deltaColShift","deltaStart","deltaEnd","noClip","pos","detach","getLength","getLine","min","Document","textOrLines","$lines","isArray","insertMergedLines","insert","setValue","text","len","remove","getValue","getAllLines","getNewLineCharacter","createAnchor","$split","$detectNewLine","match","$autoNewLine","$newLineMode","setNewLineMode","newLineMode","getNewLineMode","isNewLine","getLines","getTextRange","getLinesForRange","l","insertLines","insertFullLines","removeLines","removeFullLines","insertNewLine","insertInLine","clippedPos","clonePos","$clipPosition","removeInLine","deleteFirstNewLine","deleteLastNewLine","startCol","endCol","deletedLines","removeNewLine","applyDeltas","deltas","revertDeltas","revertDelta","isInsert","$splitAndapplyLargeDelta","$safeApplyDelta","docLength","MAX","from","to","chunk","indexToPosition","newlineLength","positionToIndex","last","a","stringReverse","string","reverse","stringRepeat","count","result","trimBeginRegexp","trimEndRegexp","stringTrimLeft","stringTrimRight","copyObject","copy","copyArray","array","deepCopy","arrayToMap","arr","createMap","props","arrayRemove","escapeRegExp","str","escapeHTML","getMatchOffsets","regExp","matches","offset","deferredCall","fcn","timer","deferred","timeout","cancel","setTimeout","schedule","clearTimeout","isPending","delayedCall","defaultTimeout","delay","lang","Mirror","deferredUpdate","onUpdate","d","$path","linesLength","$timeout","root","version","input","options","features","encodingMode","defaultOptions","wait","comments","scope","locations","ranges","onCreateNode","onCreateScope","onDestroyScope","onLocalDeclaration","luaVersion","encodeUTF8","codepoint","highMask","String","fromCharCode","toHex","num","digits","checkChars","rx","s","m","exec","raise","errors","invalidCodeUnit","charCodeAt","toUpperCase","encodingModes","fixup","encodeByte","discardStrings","EOF","StringLiteral","Keyword","Identifier","NumericLiteral","Punctuator","BooleanLiteral","NilLiteral","VarargLiteral","tokenTypes","unexpected","unexpectedEOF","expected","expectedToken","unfinishedString","malformedNumber","decimalEscapeTooLarge","invalidEscape","hexadecimalDigitExpected","braceExpected","tooLargeCodepoint","unfinishedLongString","unfinishedLongComment","ambiguousSyntax","noLoopToBreak","labelAlreadyDefined","labelNotVisible","gotoJumpInLocalScope","cannotUseVararg","ast","labelStatement","label","breakStatement","gotoStatement","returnStatement","ifStatement","clauses","ifClause","condition","body","elseifClause","elseClause","whileStatement","doStatement","repeatStatement","localStatement","variables","assignmentStatement","callStatement","expression","functionStatement","identifier","parameters","isLocal","forNumericStatement","variable","step","forGenericStatement","iterators","literal","raw","tableKey","tableKeyString","tableValue","tableConstructorExpression","fields","binaryExpression","operator","left","right","unaryExpression","argument","memberExpression","indexer","indexExpression","callExpression","tableCallExpression","stringCallExpression","comment","finishNode","node","trackLocations","complete","bless","element","indexOfObject","property","sprintf","format","assign","dest","src","prop","hasOwnProperty","SyntaxError","fixupError","token","lineStart","tokenValue","raiseUnexpectedToken","found","near","lookahead","previousToken","tokenStart","lex","skipWhiteSpace","scanComment","charCode","next","isIdentifierStart","scanIdentifierOrKeyword","scanStringLiteral","scanNumericLiteral","isDecDigit","scanVarargLiteral","scanPunctuator","bitwiseOperators","labels","scanLongStringLiteral","integerDivision","consumeEOL","peekCharCode","isLineTerminator","isWhiteSpace","isIdentifierPart","isKeyword","delimiter","beginLine","beginLineStart","stringStart","beforeEscape","escapeValue","readEscapeSequence","lastLine","lastLineStart","readLongString","character","readHexLiteral","readDecLiteral","foundImaginaryUnit","readImaginaryUnitSuffix","foundInt64Suffix","readInt64Suffix","hasFractionPart","imaginaryNumbers","integerSuffixes","fraction","binaryExponent","binarySign","digit","fractionStart","exponentStart","digitStart","isHexDigit","parseInt","foundFraction","pow","foundBinaryExponent","foundExponent","parseFloat","readUnicodeEscapeSequence","sequenceStart","escStart","b","frag","ddd","skipWhitespaceEscape","hexEscapes","unicodeEscapes","strictEscapes","content","isLong","commentStart","lineStartComment","lineComment","loc","isComment","level","terminator","firstLine","consume","expect","extendedIdentifiers","contextualGoto","isUnary","isBlockFollow","scopes","scopeDepth","globals","createScope","destroyScope","scopeIdentifierName","scopeIdentifier","attachScope","scopeHasName","createLocationMarker","Marker","markLocation","pushLocation","marker","FullFlowContext","pendingGotos","isInLoop","isLoop","pushScope","locals","deferredGotos","popScope","theGoto","maxDepth","target","addGoto","localCounts","addLabel","currentScope","newGotos","localCount","addLocal","raiseDeferredErrors","bads","LoopFlowContext","loopLevels","levels","levlen","makeFlowContext","parseChunk","flowContext","allowVararg","parseBlock","block","statement","relaxedBreak","parseStatement","parseLabelStatement","emptyStatement","parseLocalStatement","parseIfStatement","parseReturnStatement","parseFunctionName","parseFunctionDeclaration","parseWhileStatement","parseForStatement","parseRepeatStatement","parseBreakStatement","parseDoStatement","parseGotoStatement","parseAssignmentOrCallStatement","nameToken","parseIdentifier","gotoToken","parseExpectedExpression","expressions","parseExpression","declToken","startMarker","lvalue","targets","both","newBase","parsePrefixExpressionPart","values","parameter","parsePrimaryExpression","parseTableConstructor","parseSubExpression","binaryPrecedence","minPrecedence","parsePrefixExpression","precedence","parseCallExpression","table","literals","parse","versionFeatures","_input","_options","write","luaparse","Worker"],"sources":["/home/anasbouzid/streamlit/streamlit.io/streamlit-code-editor/code_editor/frontend/node_modules/ace-builds/src-noconflict/worker-lua.js"],"sourcesContent":["\"no use strict\";\n!(function(window) {\nif (typeof window.window != \"undefined\" && window.document)\n    return;\nif (window.require && window.define)\n    return;\n\nif (!window.console) {\n    window.console = function() {\n        var msgs = Array.prototype.slice.call(arguments, 0);\n        postMessage({type: \"log\", data: msgs});\n    };\n    window.console.error =\n    window.console.warn = \n    window.console.log =\n    window.console.trace = window.console;\n}\nwindow.window = window;\nwindow.ace = window;\n\nwindow.onerror = function(message, file, line, col, err) {\n    postMessage({type: \"error\", data: {\n        message: message,\n        data: err && err.data,\n        file: file,\n        line: line, \n        col: col,\n        stack: err && err.stack\n    }});\n};\n\nwindow.normalizeModule = function(parentId, moduleName) {\n    // normalize plugin requires\n    if (moduleName.indexOf(\"!\") !== -1) {\n        var chunks = moduleName.split(\"!\");\n        return window.normalizeModule(parentId, chunks[0]) + \"!\" + window.normalizeModule(parentId, chunks[1]);\n    }\n    // normalize relative requires\n    if (moduleName.charAt(0) == \".\") {\n        var base = parentId.split(\"/\").slice(0, -1).join(\"/\");\n        moduleName = (base ? base + \"/\" : \"\") + moduleName;\n        \n        while (moduleName.indexOf(\".\") !== -1 && previous != moduleName) {\n            var previous = moduleName;\n            moduleName = moduleName.replace(/^\\.\\//, \"\").replace(/\\/\\.\\//, \"/\").replace(/[^\\/]+\\/\\.\\.\\//, \"\");\n        }\n    }\n    \n    return moduleName;\n};\n\nwindow.require = function require(parentId, id) {\n    if (!id) {\n        id = parentId;\n        parentId = null;\n    }\n    if (!id.charAt)\n        throw new Error(\"worker.js require() accepts only (parentId, id) as arguments\");\n\n    id = window.normalizeModule(parentId, id);\n\n    var module = window.require.modules[id];\n    if (module) {\n        if (!module.initialized) {\n            module.initialized = true;\n            module.exports = module.factory().exports;\n        }\n        return module.exports;\n    }\n   \n    if (!window.require.tlns)\n        return console.log(\"unable to load \" + id);\n    \n    var path = resolveModuleId(id, window.require.tlns);\n    if (path.slice(-3) != \".js\") path += \".js\";\n    \n    window.require.id = id;\n    window.require.modules[id] = {}; // prevent infinite loop on broken modules\n    importScripts(path);\n    return window.require(parentId, id);\n};\nfunction resolveModuleId(id, paths) {\n    var testPath = id, tail = \"\";\n    while (testPath) {\n        var alias = paths[testPath];\n        if (typeof alias == \"string\") {\n            return alias + tail;\n        } else if (alias) {\n            return  alias.location.replace(/\\/*$/, \"/\") + (tail || alias.main || alias.name);\n        } else if (alias === false) {\n            return \"\";\n        }\n        var i = testPath.lastIndexOf(\"/\");\n        if (i === -1) break;\n        tail = testPath.substr(i) + tail;\n        testPath = testPath.slice(0, i);\n    }\n    return id;\n}\nwindow.require.modules = {};\nwindow.require.tlns = {};\n\nwindow.define = function(id, deps, factory) {\n    if (arguments.length == 2) {\n        factory = deps;\n        if (typeof id != \"string\") {\n            deps = id;\n            id = window.require.id;\n        }\n    } else if (arguments.length == 1) {\n        factory = id;\n        deps = [];\n        id = window.require.id;\n    }\n    \n    if (typeof factory != \"function\") {\n        window.require.modules[id] = {\n            exports: factory,\n            initialized: true\n        };\n        return;\n    }\n\n    if (!deps.length)\n        // If there is no dependencies, we inject \"require\", \"exports\" and\n        // \"module\" as dependencies, to provide CommonJS compatibility.\n        deps = [\"require\", \"exports\", \"module\"];\n\n    var req = function(childId) {\n        return window.require(id, childId);\n    };\n\n    window.require.modules[id] = {\n        exports: {},\n        factory: function() {\n            var module = this;\n            var returnExports = factory.apply(this, deps.slice(0, factory.length).map(function(dep) {\n                switch (dep) {\n                    // Because \"require\", \"exports\" and \"module\" aren't actual\n                    // dependencies, we must handle them seperately.\n                    case \"require\": return req;\n                    case \"exports\": return module.exports;\n                    case \"module\":  return module;\n                    // But for all other dependencies, we can just go ahead and\n                    // require them.\n                    default:        return req(dep);\n                }\n            }));\n            if (returnExports)\n                module.exports = returnExports;\n            return module;\n        }\n    };\n};\nwindow.define.amd = {};\nwindow.require.tlns = {};\nwindow.initBaseUrls  = function initBaseUrls(topLevelNamespaces) {\n    for (var i in topLevelNamespaces)\n        this.require.tlns[i] = topLevelNamespaces[i];\n};\n\nwindow.initSender = function initSender() {\n\n    var EventEmitter = window.require(\"ace/lib/event_emitter\").EventEmitter;\n    var oop = window.require(\"ace/lib/oop\");\n    \n    var Sender = function() {};\n    \n    (function() {\n        \n        oop.implement(this, EventEmitter);\n                \n        this.callback = function(data, callbackId) {\n            postMessage({\n                type: \"call\",\n                id: callbackId,\n                data: data\n            });\n        };\n    \n        this.emit = function(name, data) {\n            postMessage({\n                type: \"event\",\n                name: name,\n                data: data\n            });\n        };\n        \n    }).call(Sender.prototype);\n    \n    return new Sender();\n};\n\nvar main = window.main = null;\nvar sender = window.sender = null;\n\nwindow.onmessage = function(e) {\n    var msg = e.data;\n    if (msg.event && sender) {\n        sender._signal(msg.event, msg.data);\n    }\n    else if (msg.command) {\n        if (main[msg.command])\n            main[msg.command].apply(main, msg.args);\n        else if (window[msg.command])\n            window[msg.command].apply(window, msg.args);\n        else\n            throw new Error(\"Unknown command:\" + msg.command);\n    }\n    else if (msg.init) {\n        window.initBaseUrls(msg.tlns);\n        sender = window.sender = window.initSender();\n        var clazz = this.require(msg.module)[msg.classname];\n        main = window.main = new clazz(sender);\n    }\n};\n})(this);\n\nace.define(\"ace/lib/oop\",[], function(require, exports, module){\"use strict\";\nexports.inherits = function (ctor, superCtor) {\n    ctor.super_ = superCtor;\n    ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n            value: ctor,\n            enumerable: false,\n            writable: true,\n            configurable: true\n        }\n    });\n};\nexports.mixin = function (obj, mixin) {\n    for (var key in mixin) {\n        obj[key] = mixin[key];\n    }\n    return obj;\n};\nexports.implement = function (proto, mixin) {\n    exports.mixin(proto, mixin);\n};\n\n});\n\nace.define(\"ace/apply_delta\",[], function(require, exports, module){\"use strict\";\nfunction throwDeltaError(delta, errorText) {\n    console.log(\"Invalid Delta:\", delta);\n    throw \"Invalid Delta: \" + errorText;\n}\nfunction positionInDocument(docLines, position) {\n    return position.row >= 0 && position.row < docLines.length &&\n        position.column >= 0 && position.column <= docLines[position.row].length;\n}\nfunction validateDelta(docLines, delta) {\n    if (delta.action != \"insert\" && delta.action != \"remove\")\n        throwDeltaError(delta, \"delta.action must be 'insert' or 'remove'\");\n    if (!(delta.lines instanceof Array))\n        throwDeltaError(delta, \"delta.lines must be an Array\");\n    if (!delta.start || !delta.end)\n        throwDeltaError(delta, \"delta.start/end must be an present\");\n    var start = delta.start;\n    if (!positionInDocument(docLines, delta.start))\n        throwDeltaError(delta, \"delta.start must be contained in document\");\n    var end = delta.end;\n    if (delta.action == \"remove\" && !positionInDocument(docLines, end))\n        throwDeltaError(delta, \"delta.end must contained in document for 'remove' actions\");\n    var numRangeRows = end.row - start.row;\n    var numRangeLastLineChars = (end.column - (numRangeRows == 0 ? start.column : 0));\n    if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars)\n        throwDeltaError(delta, \"delta.range must match delta lines\");\n}\nexports.applyDelta = function (docLines, delta, doNotValidate) {\n    var row = delta.start.row;\n    var startColumn = delta.start.column;\n    var line = docLines[row] || \"\";\n    switch (delta.action) {\n        case \"insert\":\n            var lines = delta.lines;\n            if (lines.length === 1) {\n                docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);\n            }\n            else {\n                var args = [row, 1].concat(delta.lines);\n                docLines.splice.apply(docLines, args);\n                docLines[row] = line.substring(0, startColumn) + docLines[row];\n                docLines[row + delta.lines.length - 1] += line.substring(startColumn);\n            }\n            break;\n        case \"remove\":\n            var endColumn = delta.end.column;\n            var endRow = delta.end.row;\n            if (row === endRow) {\n                docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);\n            }\n            else {\n                docLines.splice(row, endRow - row + 1, line.substring(0, startColumn) + docLines[endRow].substring(endColumn));\n            }\n            break;\n    }\n};\n\n});\n\nace.define(\"ace/lib/event_emitter\",[], function(require, exports, module){\"use strict\";\nvar EventEmitter = {};\nvar stopPropagation = function () { this.propagationStopped = true; };\nvar preventDefault = function () { this.defaultPrevented = true; };\nEventEmitter._emit =\n    EventEmitter._dispatchEvent = function (eventName, e) {\n        this._eventRegistry || (this._eventRegistry = {});\n        this._defaultHandlers || (this._defaultHandlers = {});\n        var listeners = this._eventRegistry[eventName] || [];\n        var defaultHandler = this._defaultHandlers[eventName];\n        if (!listeners.length && !defaultHandler)\n            return;\n        if (typeof e != \"object\" || !e)\n            e = {};\n        if (!e.type)\n            e.type = eventName;\n        if (!e.stopPropagation)\n            e.stopPropagation = stopPropagation;\n        if (!e.preventDefault)\n            e.preventDefault = preventDefault;\n        listeners = listeners.slice();\n        for (var i = 0; i < listeners.length; i++) {\n            listeners[i](e, this);\n            if (e.propagationStopped)\n                break;\n        }\n        if (defaultHandler && !e.defaultPrevented)\n            return defaultHandler(e, this);\n    };\nEventEmitter._signal = function (eventName, e) {\n    var listeners = (this._eventRegistry || {})[eventName];\n    if (!listeners)\n        return;\n    listeners = listeners.slice();\n    for (var i = 0; i < listeners.length; i++)\n        listeners[i](e, this);\n};\nEventEmitter.once = function (eventName, callback) {\n    var _self = this;\n    this.on(eventName, function newCallback() {\n        _self.off(eventName, newCallback);\n        callback.apply(null, arguments);\n    });\n    if (!callback) {\n        return new Promise(function (resolve) {\n            callback = resolve;\n        });\n    }\n};\nEventEmitter.setDefaultHandler = function (eventName, callback) {\n    var handlers = this._defaultHandlers;\n    if (!handlers)\n        handlers = this._defaultHandlers = { _disabled_: {} };\n    if (handlers[eventName]) {\n        var old = handlers[eventName];\n        var disabled = handlers._disabled_[eventName];\n        if (!disabled)\n            handlers._disabled_[eventName] = disabled = [];\n        disabled.push(old);\n        var i = disabled.indexOf(callback);\n        if (i != -1)\n            disabled.splice(i, 1);\n    }\n    handlers[eventName] = callback;\n};\nEventEmitter.removeDefaultHandler = function (eventName, callback) {\n    var handlers = this._defaultHandlers;\n    if (!handlers)\n        return;\n    var disabled = handlers._disabled_[eventName];\n    if (handlers[eventName] == callback) {\n        if (disabled)\n            this.setDefaultHandler(eventName, disabled.pop());\n    }\n    else if (disabled) {\n        var i = disabled.indexOf(callback);\n        if (i != -1)\n            disabled.splice(i, 1);\n    }\n};\nEventEmitter.on =\n    EventEmitter.addEventListener = function (eventName, callback, capturing) {\n        this._eventRegistry = this._eventRegistry || {};\n        var listeners = this._eventRegistry[eventName];\n        if (!listeners)\n            listeners = this._eventRegistry[eventName] = [];\n        if (listeners.indexOf(callback) == -1)\n            listeners[capturing ? \"unshift\" : \"push\"](callback);\n        return callback;\n    };\nEventEmitter.off =\n    EventEmitter.removeListener =\n        EventEmitter.removeEventListener = function (eventName, callback) {\n            this._eventRegistry = this._eventRegistry || {};\n            var listeners = this._eventRegistry[eventName];\n            if (!listeners)\n                return;\n            var index = listeners.indexOf(callback);\n            if (index !== -1)\n                listeners.splice(index, 1);\n        };\nEventEmitter.removeAllListeners = function (eventName) {\n    if (!eventName)\n        this._eventRegistry = this._defaultHandlers = undefined;\n    if (this._eventRegistry)\n        this._eventRegistry[eventName] = undefined;\n    if (this._defaultHandlers)\n        this._defaultHandlers[eventName] = undefined;\n};\nexports.EventEmitter = EventEmitter;\n\n});\n\nace.define(\"ace/range\",[], function(require, exports, module){\"use strict\";\nvar comparePoints = function (p1, p2) {\n    return p1.row - p2.row || p1.column - p2.column;\n};\nvar Range = function (startRow, startColumn, endRow, endColumn) {\n    this.start = {\n        row: startRow,\n        column: startColumn\n    };\n    this.end = {\n        row: endRow,\n        column: endColumn\n    };\n};\n(function () {\n    this.isEqual = function (range) {\n        return this.start.row === range.start.row &&\n            this.end.row === range.end.row &&\n            this.start.column === range.start.column &&\n            this.end.column === range.end.column;\n    };\n    this.toString = function () {\n        return (\"Range: [\" + this.start.row + \"/\" + this.start.column +\n            \"] -> [\" + this.end.row + \"/\" + this.end.column + \"]\");\n    };\n    this.contains = function (row, column) {\n        return this.compare(row, column) == 0;\n    };\n    this.compareRange = function (range) {\n        var cmp, end = range.end, start = range.start;\n        cmp = this.compare(end.row, end.column);\n        if (cmp == 1) {\n            cmp = this.compare(start.row, start.column);\n            if (cmp == 1) {\n                return 2;\n            }\n            else if (cmp == 0) {\n                return 1;\n            }\n            else {\n                return 0;\n            }\n        }\n        else if (cmp == -1) {\n            return -2;\n        }\n        else {\n            cmp = this.compare(start.row, start.column);\n            if (cmp == -1) {\n                return -1;\n            }\n            else if (cmp == 1) {\n                return 42;\n            }\n            else {\n                return 0;\n            }\n        }\n    };\n    this.comparePoint = function (p) {\n        return this.compare(p.row, p.column);\n    };\n    this.containsRange = function (range) {\n        return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;\n    };\n    this.intersects = function (range) {\n        var cmp = this.compareRange(range);\n        return (cmp == -1 || cmp == 0 || cmp == 1);\n    };\n    this.isEnd = function (row, column) {\n        return this.end.row == row && this.end.column == column;\n    };\n    this.isStart = function (row, column) {\n        return this.start.row == row && this.start.column == column;\n    };\n    this.setStart = function (row, column) {\n        if (typeof row == \"object\") {\n            this.start.column = row.column;\n            this.start.row = row.row;\n        }\n        else {\n            this.start.row = row;\n            this.start.column = column;\n        }\n    };\n    this.setEnd = function (row, column) {\n        if (typeof row == \"object\") {\n            this.end.column = row.column;\n            this.end.row = row.row;\n        }\n        else {\n            this.end.row = row;\n            this.end.column = column;\n        }\n    };\n    this.inside = function (row, column) {\n        if (this.compare(row, column) == 0) {\n            if (this.isEnd(row, column) || this.isStart(row, column)) {\n                return false;\n            }\n            else {\n                return true;\n            }\n        }\n        return false;\n    };\n    this.insideStart = function (row, column) {\n        if (this.compare(row, column) == 0) {\n            if (this.isEnd(row, column)) {\n                return false;\n            }\n            else {\n                return true;\n            }\n        }\n        return false;\n    };\n    this.insideEnd = function (row, column) {\n        if (this.compare(row, column) == 0) {\n            if (this.isStart(row, column)) {\n                return false;\n            }\n            else {\n                return true;\n            }\n        }\n        return false;\n    };\n    this.compare = function (row, column) {\n        if (!this.isMultiLine()) {\n            if (row === this.start.row) {\n                return column < this.start.column ? -1 : (column > this.end.column ? 1 : 0);\n            }\n        }\n        if (row < this.start.row)\n            return -1;\n        if (row > this.end.row)\n            return 1;\n        if (this.start.row === row)\n            return column >= this.start.column ? 0 : -1;\n        if (this.end.row === row)\n            return column <= this.end.column ? 0 : 1;\n        return 0;\n    };\n    this.compareStart = function (row, column) {\n        if (this.start.row == row && this.start.column == column) {\n            return -1;\n        }\n        else {\n            return this.compare(row, column);\n        }\n    };\n    this.compareEnd = function (row, column) {\n        if (this.end.row == row && this.end.column == column) {\n            return 1;\n        }\n        else {\n            return this.compare(row, column);\n        }\n    };\n    this.compareInside = function (row, column) {\n        if (this.end.row == row && this.end.column == column) {\n            return 1;\n        }\n        else if (this.start.row == row && this.start.column == column) {\n            return -1;\n        }\n        else {\n            return this.compare(row, column);\n        }\n    };\n    this.clipRows = function (firstRow, lastRow) {\n        if (this.end.row > lastRow)\n            var end = { row: lastRow + 1, column: 0 };\n        else if (this.end.row < firstRow)\n            var end = { row: firstRow, column: 0 };\n        if (this.start.row > lastRow)\n            var start = { row: lastRow + 1, column: 0 };\n        else if (this.start.row < firstRow)\n            var start = { row: firstRow, column: 0 };\n        return Range.fromPoints(start || this.start, end || this.end);\n    };\n    this.extend = function (row, column) {\n        var cmp = this.compare(row, column);\n        if (cmp == 0)\n            return this;\n        else if (cmp == -1)\n            var start = { row: row, column: column };\n        else\n            var end = { row: row, column: column };\n        return Range.fromPoints(start || this.start, end || this.end);\n    };\n    this.isEmpty = function () {\n        return (this.start.row === this.end.row && this.start.column === this.end.column);\n    };\n    this.isMultiLine = function () {\n        return (this.start.row !== this.end.row);\n    };\n    this.clone = function () {\n        return Range.fromPoints(this.start, this.end);\n    };\n    this.collapseRows = function () {\n        if (this.end.column == 0)\n            return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0);\n        else\n            return new Range(this.start.row, 0, this.end.row, 0);\n    };\n    this.toScreenRange = function (session) {\n        var screenPosStart = session.documentToScreenPosition(this.start);\n        var screenPosEnd = session.documentToScreenPosition(this.end);\n        return new Range(screenPosStart.row, screenPosStart.column, screenPosEnd.row, screenPosEnd.column);\n    };\n    this.moveBy = function (row, column) {\n        this.start.row += row;\n        this.start.column += column;\n        this.end.row += row;\n        this.end.column += column;\n    };\n}).call(Range.prototype);\nRange.fromPoints = function (start, end) {\n    return new Range(start.row, start.column, end.row, end.column);\n};\nRange.comparePoints = comparePoints;\nRange.comparePoints = function (p1, p2) {\n    return p1.row - p2.row || p1.column - p2.column;\n};\nexports.Range = Range;\n\n});\n\nace.define(\"ace/anchor\",[], function(require, exports, module){\"use strict\";\nvar oop = require(\"./lib/oop\");\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar Anchor = exports.Anchor = function (doc, row, column) {\n    this.$onChange = this.onChange.bind(this);\n    this.attach(doc);\n    if (typeof column == \"undefined\")\n        this.setPosition(row.row, row.column);\n    else\n        this.setPosition(row, column);\n};\n(function () {\n    oop.implement(this, EventEmitter);\n    this.getPosition = function () {\n        return this.$clipPositionToDocument(this.row, this.column);\n    };\n    this.getDocument = function () {\n        return this.document;\n    };\n    this.$insertRight = false;\n    this.onChange = function (delta) {\n        if (delta.start.row == delta.end.row && delta.start.row != this.row)\n            return;\n        if (delta.start.row > this.row)\n            return;\n        var point = $getTransformedPoint(delta, { row: this.row, column: this.column }, this.$insertRight);\n        this.setPosition(point.row, point.column, true);\n    };\n    function $pointsInOrder(point1, point2, equalPointsInOrder) {\n        var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;\n        return (point1.row < point2.row) || (point1.row == point2.row && bColIsAfter);\n    }\n    function $getTransformedPoint(delta, point, moveIfEqual) {\n        var deltaIsInsert = delta.action == \"insert\";\n        var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row - delta.start.row);\n        var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);\n        var deltaStart = delta.start;\n        var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.\n        if ($pointsInOrder(point, deltaStart, moveIfEqual)) {\n            return {\n                row: point.row,\n                column: point.column\n            };\n        }\n        if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {\n            return {\n                row: point.row + deltaRowShift,\n                column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)\n            };\n        }\n        return {\n            row: deltaStart.row,\n            column: deltaStart.column\n        };\n    }\n    this.setPosition = function (row, column, noClip) {\n        var pos;\n        if (noClip) {\n            pos = {\n                row: row,\n                column: column\n            };\n        }\n        else {\n            pos = this.$clipPositionToDocument(row, column);\n        }\n        if (this.row == pos.row && this.column == pos.column)\n            return;\n        var old = {\n            row: this.row,\n            column: this.column\n        };\n        this.row = pos.row;\n        this.column = pos.column;\n        this._signal(\"change\", {\n            old: old,\n            value: pos\n        });\n    };\n    this.detach = function () {\n        this.document.off(\"change\", this.$onChange);\n    };\n    this.attach = function (doc) {\n        this.document = doc || this.document;\n        this.document.on(\"change\", this.$onChange);\n    };\n    this.$clipPositionToDocument = function (row, column) {\n        var pos = {};\n        if (row >= this.document.getLength()) {\n            pos.row = Math.max(0, this.document.getLength() - 1);\n            pos.column = this.document.getLine(pos.row).length;\n        }\n        else if (row < 0) {\n            pos.row = 0;\n            pos.column = 0;\n        }\n        else {\n            pos.row = row;\n            pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));\n        }\n        if (column < 0)\n            pos.column = 0;\n        return pos;\n    };\n}).call(Anchor.prototype);\n\n});\n\nace.define(\"ace/document\",[], function(require, exports, module){\"use strict\";\nvar oop = require(\"./lib/oop\");\nvar applyDelta = require(\"./apply_delta\").applyDelta;\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar Range = require(\"./range\").Range;\nvar Anchor = require(\"./anchor\").Anchor;\nvar Document = function (textOrLines) {\n    this.$lines = [\"\"];\n    if (textOrLines.length === 0) {\n        this.$lines = [\"\"];\n    }\n    else if (Array.isArray(textOrLines)) {\n        this.insertMergedLines({ row: 0, column: 0 }, textOrLines);\n    }\n    else {\n        this.insert({ row: 0, column: 0 }, textOrLines);\n    }\n};\n(function () {\n    oop.implement(this, EventEmitter);\n    this.setValue = function (text) {\n        var len = this.getLength() - 1;\n        this.remove(new Range(0, 0, len, this.getLine(len).length));\n        this.insert({ row: 0, column: 0 }, text || \"\");\n    };\n    this.getValue = function () {\n        return this.getAllLines().join(this.getNewLineCharacter());\n    };\n    this.createAnchor = function (row, column) {\n        return new Anchor(this, row, column);\n    };\n    if (\"aaa\".split(/a/).length === 0) {\n        this.$split = function (text) {\n            return text.replace(/\\r\\n|\\r/g, \"\\n\").split(\"\\n\");\n        };\n    }\n    else {\n        this.$split = function (text) {\n            return text.split(/\\r\\n|\\r|\\n/);\n        };\n    }\n    this.$detectNewLine = function (text) {\n        var match = text.match(/^.*?(\\r\\n|\\r|\\n)/m);\n        this.$autoNewLine = match ? match[1] : \"\\n\";\n        this._signal(\"changeNewLineMode\");\n    };\n    this.getNewLineCharacter = function () {\n        switch (this.$newLineMode) {\n            case \"windows\":\n                return \"\\r\\n\";\n            case \"unix\":\n                return \"\\n\";\n            default:\n                return this.$autoNewLine || \"\\n\";\n        }\n    };\n    this.$autoNewLine = \"\";\n    this.$newLineMode = \"auto\";\n    this.setNewLineMode = function (newLineMode) {\n        if (this.$newLineMode === newLineMode)\n            return;\n        this.$newLineMode = newLineMode;\n        this._signal(\"changeNewLineMode\");\n    };\n    this.getNewLineMode = function () {\n        return this.$newLineMode;\n    };\n    this.isNewLine = function (text) {\n        return (text == \"\\r\\n\" || text == \"\\r\" || text == \"\\n\");\n    };\n    this.getLine = function (row) {\n        return this.$lines[row] || \"\";\n    };\n    this.getLines = function (firstRow, lastRow) {\n        return this.$lines.slice(firstRow, lastRow + 1);\n    };\n    this.getAllLines = function () {\n        return this.getLines(0, this.getLength());\n    };\n    this.getLength = function () {\n        return this.$lines.length;\n    };\n    this.getTextRange = function (range) {\n        return this.getLinesForRange(range).join(this.getNewLineCharacter());\n    };\n    this.getLinesForRange = function (range) {\n        var lines;\n        if (range.start.row === range.end.row) {\n            lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];\n        }\n        else {\n            lines = this.getLines(range.start.row, range.end.row);\n            lines[0] = (lines[0] || \"\").substring(range.start.column);\n            var l = lines.length - 1;\n            if (range.end.row - range.start.row == l)\n                lines[l] = lines[l].substring(0, range.end.column);\n        }\n        return lines;\n    };\n    this.insertLines = function (row, lines) {\n        console.warn(\"Use of document.insertLines is deprecated. Use the insertFullLines method instead.\");\n        return this.insertFullLines(row, lines);\n    };\n    this.removeLines = function (firstRow, lastRow) {\n        console.warn(\"Use of document.removeLines is deprecated. Use the removeFullLines method instead.\");\n        return this.removeFullLines(firstRow, lastRow);\n    };\n    this.insertNewLine = function (position) {\n        console.warn(\"Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.\");\n        return this.insertMergedLines(position, [\"\", \"\"]);\n    };\n    this.insert = function (position, text) {\n        if (this.getLength() <= 1)\n            this.$detectNewLine(text);\n        return this.insertMergedLines(position, this.$split(text));\n    };\n    this.insertInLine = function (position, text) {\n        var start = this.clippedPos(position.row, position.column);\n        var end = this.pos(position.row, position.column + text.length);\n        this.applyDelta({\n            start: start,\n            end: end,\n            action: \"insert\",\n            lines: [text]\n        }, true);\n        return this.clonePos(end);\n    };\n    this.clippedPos = function (row, column) {\n        var length = this.getLength();\n        if (row === undefined) {\n            row = length;\n        }\n        else if (row < 0) {\n            row = 0;\n        }\n        else if (row >= length) {\n            row = length - 1;\n            column = undefined;\n        }\n        var line = this.getLine(row);\n        if (column == undefined)\n            column = line.length;\n        column = Math.min(Math.max(column, 0), line.length);\n        return { row: row, column: column };\n    };\n    this.clonePos = function (pos) {\n        return { row: pos.row, column: pos.column };\n    };\n    this.pos = function (row, column) {\n        return { row: row, column: column };\n    };\n    this.$clipPosition = function (position) {\n        var length = this.getLength();\n        if (position.row >= length) {\n            position.row = Math.max(0, length - 1);\n            position.column = this.getLine(length - 1).length;\n        }\n        else {\n            position.row = Math.max(0, position.row);\n            position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);\n        }\n        return position;\n    };\n    this.insertFullLines = function (row, lines) {\n        row = Math.min(Math.max(row, 0), this.getLength());\n        var column = 0;\n        if (row < this.getLength()) {\n            lines = lines.concat([\"\"]);\n            column = 0;\n        }\n        else {\n            lines = [\"\"].concat(lines);\n            row--;\n            column = this.$lines[row].length;\n        }\n        this.insertMergedLines({ row: row, column: column }, lines);\n    };\n    this.insertMergedLines = function (position, lines) {\n        var start = this.clippedPos(position.row, position.column);\n        var end = {\n            row: start.row + lines.length - 1,\n            column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length\n        };\n        this.applyDelta({\n            start: start,\n            end: end,\n            action: \"insert\",\n            lines: lines\n        });\n        return this.clonePos(end);\n    };\n    this.remove = function (range) {\n        var start = this.clippedPos(range.start.row, range.start.column);\n        var end = this.clippedPos(range.end.row, range.end.column);\n        this.applyDelta({\n            start: start,\n            end: end,\n            action: \"remove\",\n            lines: this.getLinesForRange({ start: start, end: end })\n        });\n        return this.clonePos(start);\n    };\n    this.removeInLine = function (row, startColumn, endColumn) {\n        var start = this.clippedPos(row, startColumn);\n        var end = this.clippedPos(row, endColumn);\n        this.applyDelta({\n            start: start,\n            end: end,\n            action: \"remove\",\n            lines: this.getLinesForRange({ start: start, end: end })\n        }, true);\n        return this.clonePos(start);\n    };\n    this.removeFullLines = function (firstRow, lastRow) {\n        firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);\n        lastRow = Math.min(Math.max(0, lastRow), this.getLength() - 1);\n        var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;\n        var deleteLastNewLine = lastRow < this.getLength() - 1;\n        var startRow = (deleteFirstNewLine ? firstRow - 1 : firstRow);\n        var startCol = (deleteFirstNewLine ? this.getLine(startRow).length : 0);\n        var endRow = (deleteLastNewLine ? lastRow + 1 : lastRow);\n        var endCol = (deleteLastNewLine ? 0 : this.getLine(endRow).length);\n        var range = new Range(startRow, startCol, endRow, endCol);\n        var deletedLines = this.$lines.slice(firstRow, lastRow + 1);\n        this.applyDelta({\n            start: range.start,\n            end: range.end,\n            action: \"remove\",\n            lines: this.getLinesForRange(range)\n        });\n        return deletedLines;\n    };\n    this.removeNewLine = function (row) {\n        if (row < this.getLength() - 1 && row >= 0) {\n            this.applyDelta({\n                start: this.pos(row, this.getLine(row).length),\n                end: this.pos(row + 1, 0),\n                action: \"remove\",\n                lines: [\"\", \"\"]\n            });\n        }\n    };\n    this.replace = function (range, text) {\n        if (!(range instanceof Range))\n            range = Range.fromPoints(range.start, range.end);\n        if (text.length === 0 && range.isEmpty())\n            return range.start;\n        if (text == this.getTextRange(range))\n            return range.end;\n        this.remove(range);\n        var end;\n        if (text) {\n            end = this.insert(range.start, text);\n        }\n        else {\n            end = range.start;\n        }\n        return end;\n    };\n    this.applyDeltas = function (deltas) {\n        for (var i = 0; i < deltas.length; i++) {\n            this.applyDelta(deltas[i]);\n        }\n    };\n    this.revertDeltas = function (deltas) {\n        for (var i = deltas.length - 1; i >= 0; i--) {\n            this.revertDelta(deltas[i]);\n        }\n    };\n    this.applyDelta = function (delta, doNotValidate) {\n        var isInsert = delta.action == \"insert\";\n        if (isInsert ? delta.lines.length <= 1 && !delta.lines[0]\n            : !Range.comparePoints(delta.start, delta.end)) {\n            return;\n        }\n        if (isInsert && delta.lines.length > 20000) {\n            this.$splitAndapplyLargeDelta(delta, 20000);\n        }\n        else {\n            applyDelta(this.$lines, delta, doNotValidate);\n            this._signal(\"change\", delta);\n        }\n    };\n    this.$safeApplyDelta = function (delta) {\n        var docLength = this.$lines.length;\n        if (delta.action == \"remove\" && delta.start.row < docLength && delta.end.row < docLength\n            || delta.action == \"insert\" && delta.start.row <= docLength) {\n            this.applyDelta(delta);\n        }\n    };\n    this.$splitAndapplyLargeDelta = function (delta, MAX) {\n        var lines = delta.lines;\n        var l = lines.length - MAX + 1;\n        var row = delta.start.row;\n        var column = delta.start.column;\n        for (var from = 0, to = 0; from < l; from = to) {\n            to += MAX - 1;\n            var chunk = lines.slice(from, to);\n            chunk.push(\"\");\n            this.applyDelta({\n                start: this.pos(row + from, column),\n                end: this.pos(row + to, column = 0),\n                action: delta.action,\n                lines: chunk\n            }, true);\n        }\n        delta.lines = lines.slice(from);\n        delta.start.row = row + from;\n        delta.start.column = column;\n        this.applyDelta(delta, true);\n    };\n    this.revertDelta = function (delta) {\n        this.$safeApplyDelta({\n            start: this.clonePos(delta.start),\n            end: this.clonePos(delta.end),\n            action: (delta.action == \"insert\" ? \"remove\" : \"insert\"),\n            lines: delta.lines.slice()\n        });\n    };\n    this.indexToPosition = function (index, startRow) {\n        var lines = this.$lines || this.getAllLines();\n        var newlineLength = this.getNewLineCharacter().length;\n        for (var i = startRow || 0, l = lines.length; i < l; i++) {\n            index -= lines[i].length + newlineLength;\n            if (index < 0)\n                return { row: i, column: index + lines[i].length + newlineLength };\n        }\n        return { row: l - 1, column: index + lines[l - 1].length + newlineLength };\n    };\n    this.positionToIndex = function (pos, startRow) {\n        var lines = this.$lines || this.getAllLines();\n        var newlineLength = this.getNewLineCharacter().length;\n        var index = 0;\n        var row = Math.min(pos.row, lines.length);\n        for (var i = startRow || 0; i < row; ++i)\n            index += lines[i].length + newlineLength;\n        return index + pos.column;\n    };\n}).call(Document.prototype);\nexports.Document = Document;\n\n});\n\nace.define(\"ace/lib/lang\",[], function(require, exports, module){\"use strict\";\nexports.last = function (a) {\n    return a[a.length - 1];\n};\nexports.stringReverse = function (string) {\n    return string.split(\"\").reverse().join(\"\");\n};\nexports.stringRepeat = function (string, count) {\n    var result = '';\n    while (count > 0) {\n        if (count & 1)\n            result += string;\n        if (count >>= 1)\n            string += string;\n    }\n    return result;\n};\nvar trimBeginRegexp = /^\\s\\s*/;\nvar trimEndRegexp = /\\s\\s*$/;\nexports.stringTrimLeft = function (string) {\n    return string.replace(trimBeginRegexp, '');\n};\nexports.stringTrimRight = function (string) {\n    return string.replace(trimEndRegexp, '');\n};\nexports.copyObject = function (obj) {\n    var copy = {};\n    for (var key in obj) {\n        copy[key] = obj[key];\n    }\n    return copy;\n};\nexports.copyArray = function (array) {\n    var copy = [];\n    for (var i = 0, l = array.length; i < l; i++) {\n        if (array[i] && typeof array[i] == \"object\")\n            copy[i] = this.copyObject(array[i]);\n        else\n            copy[i] = array[i];\n    }\n    return copy;\n};\nexports.deepCopy = function deepCopy(obj) {\n    if (typeof obj !== \"object\" || !obj)\n        return obj;\n    var copy;\n    if (Array.isArray(obj)) {\n        copy = [];\n        for (var key = 0; key < obj.length; key++) {\n            copy[key] = deepCopy(obj[key]);\n        }\n        return copy;\n    }\n    if (Object.prototype.toString.call(obj) !== \"[object Object]\")\n        return obj;\n    copy = {};\n    for (var key in obj)\n        copy[key] = deepCopy(obj[key]);\n    return copy;\n};\nexports.arrayToMap = function (arr) {\n    var map = {};\n    for (var i = 0; i < arr.length; i++) {\n        map[arr[i]] = 1;\n    }\n    return map;\n};\nexports.createMap = function (props) {\n    var map = Object.create(null);\n    for (var i in props) {\n        map[i] = props[i];\n    }\n    return map;\n};\nexports.arrayRemove = function (array, value) {\n    for (var i = 0; i <= array.length; i++) {\n        if (value === array[i]) {\n            array.splice(i, 1);\n        }\n    }\n};\nexports.escapeRegExp = function (str) {\n    return str.replace(/([.*+?^${}()|[\\]\\/\\\\])/g, '\\\\$1');\n};\nexports.escapeHTML = function (str) {\n    return (\"\" + str).replace(/&/g, \"&#38;\").replace(/\"/g, \"&#34;\").replace(/'/g, \"&#39;\").replace(/</g, \"&#60;\");\n};\nexports.getMatchOffsets = function (string, regExp) {\n    var matches = [];\n    string.replace(regExp, function (str) {\n        matches.push({\n            offset: arguments[arguments.length - 2],\n            length: str.length\n        });\n    });\n    return matches;\n};\nexports.deferredCall = function (fcn) {\n    var timer = null;\n    var callback = function () {\n        timer = null;\n        fcn();\n    };\n    var deferred = function (timeout) {\n        deferred.cancel();\n        timer = setTimeout(callback, timeout || 0);\n        return deferred;\n    };\n    deferred.schedule = deferred;\n    deferred.call = function () {\n        this.cancel();\n        fcn();\n        return deferred;\n    };\n    deferred.cancel = function () {\n        clearTimeout(timer);\n        timer = null;\n        return deferred;\n    };\n    deferred.isPending = function () {\n        return timer;\n    };\n    return deferred;\n};\nexports.delayedCall = function (fcn, defaultTimeout) {\n    var timer = null;\n    var callback = function () {\n        timer = null;\n        fcn();\n    };\n    var _self = function (timeout) {\n        if (timer == null)\n            timer = setTimeout(callback, timeout || defaultTimeout);\n    };\n    _self.delay = function (timeout) {\n        timer && clearTimeout(timer);\n        timer = setTimeout(callback, timeout || defaultTimeout);\n    };\n    _self.schedule = _self;\n    _self.call = function () {\n        this.cancel();\n        fcn();\n    };\n    _self.cancel = function () {\n        timer && clearTimeout(timer);\n        timer = null;\n    };\n    _self.isPending = function () {\n        return timer;\n    };\n    return _self;\n};\n\n});\n\nace.define(\"ace/worker/mirror\",[], function(require, exports, module) {\n\"use strict\";\n\nvar Document = require(\"../document\").Document;\nvar lang = require(\"../lib/lang\");\n    \nvar Mirror = exports.Mirror = function(sender) {\n    this.sender = sender;\n    var doc = this.doc = new Document(\"\");\n    \n    var deferredUpdate = this.deferredUpdate = lang.delayedCall(this.onUpdate.bind(this));\n    \n    var _self = this;\n    sender.on(\"change\", function(e) {\n        var data = e.data;\n        if (data[0].start) {\n            doc.applyDeltas(data);\n        } else {\n            for (var i = 0; i < data.length; i += 2) {\n                var d, err; \n                if (Array.isArray(data[i+1])) {\n                    d = {action: \"insert\", start: data[i], lines: data[i+1]};\n                } else {\n                    d = {action: \"remove\", start: data[i], end: data[i+1]};\n                }\n                \n                if ((d.action == \"insert\" ? d.start : d.end).row >= doc.$lines.length) {\n                    err = new Error(\"Invalid delta\");\n                    err.data = {\n                        path: _self.$path,\n                        linesLength: doc.$lines.length,\n                        start: d.start,\n                        end: d.end\n                    };\n                    throw err;\n                }\n\n                doc.applyDelta(d, true);\n            }\n        }\n        if (_self.$timeout)\n            return deferredUpdate.schedule(_self.$timeout);\n        _self.onUpdate();\n    });\n};\n\n(function() {\n    \n    this.$timeout = 500;\n    \n    this.setTimeout = function(timeout) {\n        this.$timeout = timeout;\n    };\n    \n    this.setValue = function(value) {\n        this.doc.setValue(value);\n        this.deferredUpdate.schedule(this.$timeout);\n    };\n    \n    this.getValue = function(callbackId) {\n        this.sender.callback(this.doc.getValue(), callbackId);\n    };\n    \n    this.onUpdate = function() {\n    };\n    \n    this.isPending = function() {\n        return this.deferredUpdate.isPending();\n    };\n    \n}).call(Mirror.prototype);\n\n});\n\nace.define(\"ace/mode/lua/luaparse\",[], function(require, exports, module) {\n\n(function (root, name, factory) {\n   factory(exports)\n}(this, 'luaparse', function (exports) {\n  'use strict';\n\n  exports.version = \"0.3.1\";\n\n  var input, options, length, features, encodingMode;\n  var defaultOptions = exports.defaultOptions = {\n      wait: false\n    , comments: true\n    , scope: false\n    , locations: false\n    , ranges: false\n    , onCreateNode: null\n    , onCreateScope: null\n    , onDestroyScope: null\n    , onLocalDeclaration: null\n    , luaVersion: '5.3'\n    , encodingMode: 'none'\n  };\n\n  function encodeUTF8(codepoint, highMask) {\n    highMask = highMask || 0;\n\n    if (codepoint < 0x80) {\n      return String.fromCharCode(codepoint);\n    } else if (codepoint < 0x800) {\n      return String.fromCharCode(\n        highMask | 0xc0 |  (codepoint >>  6)        ,\n        highMask | 0x80 | ( codepoint        & 0x3f)\n      );\n    } else if (codepoint < 0x10000) {\n      return String.fromCharCode(\n        highMask | 0xe0 |  (codepoint >> 12)        ,\n        highMask | 0x80 | ((codepoint >>  6) & 0x3f),\n        highMask | 0x80 | ( codepoint        & 0x3f)\n      );\n    } else /* istanbul ignore else */ if (codepoint < 0x110000) {\n      return String.fromCharCode(\n        highMask | 0xf0 |  (codepoint >> 18)        ,\n        highMask | 0x80 | ((codepoint >> 12) & 0x3f),\n        highMask | 0x80 | ((codepoint >>  6) & 0x3f),\n        highMask | 0x80 | ( codepoint        & 0x3f)\n      );\n    } else {\n      return null;\n    }\n  }\n\n  function toHex(num, digits) {\n    var result = num.toString(16);\n    while (result.length < digits)\n      result = '0' + result;\n    return result;\n  }\n\n  function checkChars(rx) {\n    return function (s) {\n      var m = rx.exec(s);\n      if (!m)\n        return s;\n      raise(null, errors.invalidCodeUnit, toHex(m[0].charCodeAt(0), 4).toUpperCase());\n    };\n  }\n\n  var encodingModes = {\n    'pseudo-latin1': {\n      fixup: checkChars(/[^\\x00-\\xff]/),\n      encodeByte: function (value) {\n        if (value === null)\n          return '';\n        return String.fromCharCode(value);\n      },\n      encodeUTF8: function (codepoint) {\n        return encodeUTF8(codepoint);\n      },\n    },\n    'x-user-defined': {\n      fixup: checkChars(/[^\\x00-\\x7f\\uf780-\\uf7ff]/),\n      encodeByte: function (value) {\n        if (value === null)\n          return '';\n        if (value >= 0x80)\n          return String.fromCharCode(value | 0xf700);\n        return String.fromCharCode(value);\n      },\n      encodeUTF8: function (codepoint) {\n        return encodeUTF8(codepoint, 0xf700);\n      }\n    },\n    'none': {\n      discardStrings: true,\n      fixup: function (s) {\n        return s;\n      },\n      encodeByte: function (value) {\n        return '';\n      },\n      encodeUTF8: function (codepoint) {\n        return '';\n      }\n    }\n  };\n\n  var EOF = 1, StringLiteral = 2, Keyword = 4, Identifier = 8\n    , NumericLiteral = 16, Punctuator = 32, BooleanLiteral = 64\n    , NilLiteral = 128, VarargLiteral = 256;\n\n  exports.tokenTypes = { EOF: EOF, StringLiteral: StringLiteral\n    , Keyword: Keyword, Identifier: Identifier, NumericLiteral: NumericLiteral\n    , Punctuator: Punctuator, BooleanLiteral: BooleanLiteral\n    , NilLiteral: NilLiteral, VarargLiteral: VarargLiteral\n  };\n\n  var errors = exports.errors = {\n      unexpected: 'unexpected %1 \\'%2\\' near \\'%3\\''\n    , unexpectedEOF: 'unexpected symbol near \\'<eof>\\''\n    , expected: '\\'%1\\' expected near \\'%2\\''\n    , expectedToken: '%1 expected near \\'%2\\''\n    , unfinishedString: 'unfinished string near \\'%1\\''\n    , malformedNumber: 'malformed number near \\'%1\\''\n    , decimalEscapeTooLarge: 'decimal escape too large near \\'%1\\''\n    , invalidEscape: 'invalid escape sequence near \\'%1\\''\n    , hexadecimalDigitExpected: 'hexadecimal digit expected near \\'%1\\''\n    , braceExpected: 'missing \\'%1\\' near \\'%2\\''\n    , tooLargeCodepoint: 'UTF-8 value too large near \\'%1\\''\n    , unfinishedLongString: 'unfinished long string (starting at line %1) near \\'%2\\''\n    , unfinishedLongComment: 'unfinished long comment (starting at line %1) near \\'%2\\''\n    , ambiguousSyntax: 'ambiguous syntax (function call x new statement) near \\'%1\\''\n    , noLoopToBreak: 'no loop to break near \\'%1\\''\n    , labelAlreadyDefined: 'label \\'%1\\' already defined on line %2'\n    , labelNotVisible: 'no visible label \\'%1\\' for <goto>'\n    , gotoJumpInLocalScope: '<goto %1> jumps into the scope of local \\'%2\\''\n    , cannotUseVararg: 'cannot use \\'...\\' outside a vararg function near \\'%1\\''\n    , invalidCodeUnit: 'code unit U+%1 is not allowed in the current encoding mode'\n  };\n\n  var ast = exports.ast = {\n      labelStatement: function(label) {\n      return {\n          type: 'LabelStatement'\n        , label: label\n      };\n    }\n\n    , breakStatement: function() {\n      return {\n          type: 'BreakStatement'\n      };\n    }\n\n    , gotoStatement: function(label) {\n      return {\n          type: 'GotoStatement'\n        , label: label\n      };\n    }\n\n    , returnStatement: function(args) {\n      return {\n          type: 'ReturnStatement'\n        , 'arguments': args\n      };\n    }\n\n    , ifStatement: function(clauses) {\n      return {\n          type: 'IfStatement'\n        , clauses: clauses\n      };\n    }\n    , ifClause: function(condition, body) {\n      return {\n          type: 'IfClause'\n        , condition: condition\n        , body: body\n      };\n    }\n    , elseifClause: function(condition, body) {\n      return {\n          type: 'ElseifClause'\n        , condition: condition\n        , body: body\n      };\n    }\n    , elseClause: function(body) {\n      return {\n          type: 'ElseClause'\n        , body: body\n      };\n    }\n\n    , whileStatement: function(condition, body) {\n      return {\n          type: 'WhileStatement'\n        , condition: condition\n        , body: body\n      };\n    }\n\n    , doStatement: function(body) {\n      return {\n          type: 'DoStatement'\n        , body: body\n      };\n    }\n\n    , repeatStatement: function(condition, body) {\n      return {\n          type: 'RepeatStatement'\n        , condition: condition\n        , body: body\n      };\n    }\n\n    , localStatement: function(variables, init) {\n      return {\n          type: 'LocalStatement'\n        , variables: variables\n        , init: init\n      };\n    }\n\n    , assignmentStatement: function(variables, init) {\n      return {\n          type: 'AssignmentStatement'\n        , variables: variables\n        , init: init\n      };\n    }\n\n    , callStatement: function(expression) {\n      return {\n          type: 'CallStatement'\n        , expression: expression\n      };\n    }\n\n    , functionStatement: function(identifier, parameters, isLocal, body) {\n      return {\n          type: 'FunctionDeclaration'\n        , identifier: identifier\n        , isLocal: isLocal\n        , parameters: parameters\n        , body: body\n      };\n    }\n\n    , forNumericStatement: function(variable, start, end, step, body) {\n      return {\n          type: 'ForNumericStatement'\n        , variable: variable\n        , start: start\n        , end: end\n        , step: step\n        , body: body\n      };\n    }\n\n    , forGenericStatement: function(variables, iterators, body) {\n      return {\n          type: 'ForGenericStatement'\n        , variables: variables\n        , iterators: iterators\n        , body: body\n      };\n    }\n\n    , chunk: function(body) {\n      return {\n          type: 'Chunk'\n        , body: body\n      };\n    }\n\n    , identifier: function(name) {\n      return {\n          type: 'Identifier'\n        , name: name\n      };\n    }\n\n    , literal: function(type, value, raw) {\n      type = (type === StringLiteral) ? 'StringLiteral'\n        : (type === NumericLiteral) ? 'NumericLiteral'\n        : (type === BooleanLiteral) ? 'BooleanLiteral'\n        : (type === NilLiteral) ? 'NilLiteral'\n        : 'VarargLiteral';\n\n      return {\n          type: type\n        , value: value\n        , raw: raw\n      };\n    }\n\n    , tableKey: function(key, value) {\n      return {\n          type: 'TableKey'\n        , key: key\n        , value: value\n      };\n    }\n    , tableKeyString: function(key, value) {\n      return {\n          type: 'TableKeyString'\n        , key: key\n        , value: value\n      };\n    }\n    , tableValue: function(value) {\n      return {\n          type: 'TableValue'\n        , value: value\n      };\n    }\n\n\n    , tableConstructorExpression: function(fields) {\n      return {\n          type: 'TableConstructorExpression'\n        , fields: fields\n      };\n    }\n    , binaryExpression: function(operator, left, right) {\n      var type = ('and' === operator || 'or' === operator) ?\n        'LogicalExpression' :\n        'BinaryExpression';\n\n      return {\n          type: type\n        , operator: operator\n        , left: left\n        , right: right\n      };\n    }\n    , unaryExpression: function(operator, argument) {\n      return {\n          type: 'UnaryExpression'\n        , operator: operator\n        , argument: argument\n      };\n    }\n    , memberExpression: function(base, indexer, identifier) {\n      return {\n          type: 'MemberExpression'\n        , indexer: indexer\n        , identifier: identifier\n        , base: base\n      };\n    }\n\n    , indexExpression: function(base, index) {\n      return {\n          type: 'IndexExpression'\n        , base: base\n        , index: index\n      };\n    }\n\n    , callExpression: function(base, args) {\n      return {\n          type: 'CallExpression'\n        , base: base\n        , 'arguments': args\n      };\n    }\n\n    , tableCallExpression: function(base, args) {\n      return {\n          type: 'TableCallExpression'\n        , base: base\n        , 'arguments': args\n      };\n    }\n\n    , stringCallExpression: function(base, argument) {\n      return {\n          type: 'StringCallExpression'\n        , base: base\n        , argument: argument\n      };\n    }\n\n    , comment: function(value, raw) {\n      return {\n          type: 'Comment'\n        , value: value\n        , raw: raw\n      };\n    }\n  };\n\n  function finishNode(node) {\n    if (trackLocations) {\n      var location = locations.pop();\n      location.complete();\n      location.bless(node);\n    }\n    if (options.onCreateNode) options.onCreateNode(node);\n    return node;\n  }\n\n  var slice = Array.prototype.slice\n    , toString = Object.prototype.toString\n    ;\n\n  var indexOf = /* istanbul ignore next */ function (array, element) {\n    for (var i = 0, length = array.length; i < length; ++i) {\n      if (array[i] === element) return i;\n    }\n    return -1;\n  };\n  if (Array.prototype.indexOf)\n    indexOf = function (array, element) {\n      return array.indexOf(element);\n    };\n\n  function indexOfObject(array, property, element) {\n    for (var i = 0, length = array.length; i < length; ++i) {\n      if (array[i][property] === element) return i;\n    }\n    return -1;\n  }\n\n  function sprintf(format) {\n    var args = slice.call(arguments, 1);\n    format = format.replace(/%(\\d)/g, function (match, index) {\n      return '' + args[index - 1] || /* istanbul ignore next */ '';\n    });\n    return format;\n  }\n\n  var assign = /* istanbul ignore next */ function (dest) {\n    var args = slice.call(arguments, 1)\n      , src, prop;\n\n    for (var i = 0, length = args.length; i < length; ++i) {\n      src = args[i];\n      for (prop in src)\n        if (Object.prototype.hasOwnProperty.call(src, prop)) {\n          dest[prop] = src[prop];\n        }\n    }\n\n    return dest;\n  };\n  if (Object.assign)\n    assign = Object.assign;\n\n  exports.SyntaxError = SyntaxError;\n\n  function fixupError(e) {\n    if (!Object.create)\n      return e;\n    return Object.create(e, {\n      'line': { 'writable': true, value: e.line },\n      'index': { 'writable': true, value: e.index },\n      'column': { 'writable': true, value: e.column }\n    });\n  }\n\n  function raise(token) {\n    var message = sprintf.apply(null, slice.call(arguments, 1))\n      , error, col;\n\n    if (token === null || typeof token.line === 'undefined') {\n      col = index - lineStart + 1;\n      error = fixupError(new SyntaxError(sprintf('[%1:%2] %3', line, col, message)));\n      error.index = index;\n      error.line = line;\n      error.column = col;\n    } else {\n      col = token.range[0] - token.lineStart;\n      error = fixupError(new SyntaxError(sprintf('[%1:%2] %3', token.line, col, message)));\n      error.line = token.line;\n      error.index = token.range[0];\n      error.column = col;\n    }\n    throw error;\n  }\n\n  function tokenValue(token) {\n    var raw = input.slice(token.range[0], token.range[1]);\n    if (raw)\n      return raw;\n    return token.value;\n  }\n\n  function raiseUnexpectedToken(type, token) {\n    raise(token, errors.expectedToken, type, tokenValue(token));\n  }\n\n  function unexpected(found) {\n    var near = tokenValue(lookahead);\n    if ('undefined' !== typeof found.type) {\n      var type;\n      switch (found.type) {\n        case StringLiteral:   type = 'string';      break;\n        case Keyword:         type = 'keyword';     break;\n        case Identifier:      type = 'identifier';  break;\n        case NumericLiteral:  type = 'number';      break;\n        case Punctuator:      type = 'symbol';      break;\n        case BooleanLiteral:  type = 'boolean';     break;\n        case NilLiteral:\n          return raise(found, errors.unexpected, 'symbol', 'nil', near);\n        case EOF:\n          return raise(found, errors.unexpectedEOF);\n      }\n      return raise(found, errors.unexpected, type, tokenValue(found), near);\n    }\n    return raise(found, errors.unexpected, 'symbol', found, near);\n  }\n\n  var index\n    , token\n    , previousToken\n    , lookahead\n    , comments\n    , tokenStart\n    , line\n    , lineStart;\n\n  exports.lex = lex;\n\n  function lex() {\n    skipWhiteSpace();\n    while (45 === input.charCodeAt(index) &&\n           45 === input.charCodeAt(index + 1)) {\n      scanComment();\n      skipWhiteSpace();\n    }\n    if (index >= length) return {\n        type : EOF\n      , value: '<eof>'\n      , line: line\n      , lineStart: lineStart\n      , range: [index, index]\n    };\n\n    var charCode = input.charCodeAt(index)\n      , next = input.charCodeAt(index + 1);\n    tokenStart = index;\n    if (isIdentifierStart(charCode)) return scanIdentifierOrKeyword();\n\n    switch (charCode) {\n      case 39: case 34: // '\"\n        return scanStringLiteral();\n\n      case 48: case 49: case 50: case 51: case 52: case 53:\n      case 54: case 55: case 56: case 57: // 0-9\n        return scanNumericLiteral();\n\n      case 46: // .\n        if (isDecDigit(next)) return scanNumericLiteral();\n        if (46 === next) {\n          if (46 === input.charCodeAt(index + 2)) return scanVarargLiteral();\n          return scanPunctuator('..');\n        }\n        return scanPunctuator('.');\n\n      case 61: // =\n        if (61 === next) return scanPunctuator('==');\n        return scanPunctuator('=');\n\n      case 62: // >\n        if (features.bitwiseOperators)\n          if (62 === next) return scanPunctuator('>>');\n        if (61 === next) return scanPunctuator('>=');\n        return scanPunctuator('>');\n\n      case 60: // <\n        if (features.bitwiseOperators)\n          if (60 === next) return scanPunctuator('<<');\n        if (61 === next) return scanPunctuator('<=');\n        return scanPunctuator('<');\n\n      case 126: // ~\n        if (61 === next) return scanPunctuator('~=');\n        if (!features.bitwiseOperators)\n          break;\n        return scanPunctuator('~');\n\n      case 58: // :\n        if (features.labels)\n          if (58 === next) return scanPunctuator('::');\n        return scanPunctuator(':');\n\n      case 91: // [\n        if (91 === next || 61 === next) return scanLongStringLiteral();\n        return scanPunctuator('[');\n\n      case 47: // /\n        if (features.integerDivision)\n          if (47 === next) return scanPunctuator('//');\n        return scanPunctuator('/');\n\n      case 38: case 124: // & |\n        if (!features.bitwiseOperators)\n          break;\n      case 42: case 94: case 37: case 44: case 123: case 125:\n      case 93: case 40: case 41: case 59: case 35: case 45:\n      case 43: // * ^ % , { } ] ( ) ; # - +\n        return scanPunctuator(input.charAt(index));\n    }\n\n    return unexpected(input.charAt(index));\n  }\n\n  function consumeEOL() {\n    var charCode = input.charCodeAt(index)\n      , peekCharCode = input.charCodeAt(index + 1);\n\n    if (isLineTerminator(charCode)) {\n      if (10 === charCode && 13 === peekCharCode) ++index;\n      if (13 === charCode && 10 === peekCharCode) ++index;\n      ++line;\n      lineStart = ++index;\n\n      return true;\n    }\n    return false;\n  }\n\n  function skipWhiteSpace() {\n    while (index < length) {\n      var charCode = input.charCodeAt(index);\n      if (isWhiteSpace(charCode)) {\n        ++index;\n      } else if (!consumeEOL()) {\n        break;\n      }\n    }\n  }\n\n  function scanIdentifierOrKeyword() {\n    var value, type;\n    while (isIdentifierPart(input.charCodeAt(++index)));\n    value = encodingMode.fixup(input.slice(tokenStart, index));\n    if (isKeyword(value)) {\n      type = Keyword;\n    } else if ('true' === value || 'false' === value) {\n      type = BooleanLiteral;\n      value = ('true' === value);\n    } else if ('nil' === value) {\n      type = NilLiteral;\n      value = null;\n    } else {\n      type = Identifier;\n    }\n\n    return {\n        type: type\n      , value: value\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  function scanPunctuator(value) {\n    index += value.length;\n    return {\n        type: Punctuator\n      , value: value\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  function scanVarargLiteral() {\n    index += 3;\n    return {\n        type: VarargLiteral\n      , value: '...'\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  function scanStringLiteral() {\n    var delimiter = input.charCodeAt(index++)\n      , beginLine = line\n      , beginLineStart = lineStart\n      , stringStart = index\n      , string = encodingMode.discardStrings ? null : ''\n      , charCode;\n\n    for (;;) {\n      charCode = input.charCodeAt(index++);\n      if (delimiter === charCode) break;\n      if (index > length || isLineTerminator(charCode)) {\n        string += input.slice(stringStart, index - 1);\n        raise(null, errors.unfinishedString, input.slice(tokenStart, index - 1));\n      }\n      if (92 === charCode) { // backslash\n        if (!encodingMode.discardStrings) {\n          var beforeEscape = input.slice(stringStart, index - 1);\n          string += encodingMode.fixup(beforeEscape);\n        }\n        var escapeValue = readEscapeSequence();\n        if (!encodingMode.discardStrings)\n          string += escapeValue;\n        stringStart = index;\n      }\n    }\n    if (!encodingMode.discardStrings) {\n      string += encodingMode.encodeByte(null);\n      string += encodingMode.fixup(input.slice(stringStart, index - 1));\n    }\n\n    return {\n        type: StringLiteral\n      , value: string\n      , line: beginLine\n      , lineStart: beginLineStart\n      , lastLine: line\n      , lastLineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  function scanLongStringLiteral() {\n    var beginLine = line\n      , beginLineStart = lineStart\n      , string = readLongString(false);\n    if (false === string) raise(token, errors.expected, '[', tokenValue(token));\n\n    return {\n        type: StringLiteral\n      , value: encodingMode.discardStrings ? null : encodingMode.fixup(string)\n      , line: beginLine\n      , lineStart: beginLineStart\n      , lastLine: line\n      , lastLineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  function scanNumericLiteral() {\n    var character = input.charAt(index)\n      , next = input.charAt(index + 1);\n\n    var literal = ('0' === character && 'xX'.indexOf(next || null) >= 0) ?\n      readHexLiteral() : readDecLiteral();\n\n    var foundImaginaryUnit = readImaginaryUnitSuffix()\n      , foundInt64Suffix = readInt64Suffix();\n\n    if (foundInt64Suffix && (foundImaginaryUnit || literal.hasFractionPart)) {\n      raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n    }\n\n    return {\n        type: NumericLiteral\n      , value: literal.value\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  function readImaginaryUnitSuffix() {\n    if (!features.imaginaryNumbers) return;\n    if ('iI'.indexOf(input.charAt(index) || null) >= 0) {\n      ++index;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function readInt64Suffix() {\n    if (!features.integerSuffixes) return;\n\n    if ('uU'.indexOf(input.charAt(index) || null) >= 0) {\n      ++index;\n      if ('lL'.indexOf(input.charAt(index) || null) >= 0) {\n        ++index;\n        if ('lL'.indexOf(input.charAt(index) || null) >= 0) {\n          ++index;\n          return 'ULL';\n        } else {\n          raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n        }\n      } else {\n        raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n      }\n    } else if ('lL'.indexOf(input.charAt(index) || null) >= 0) {\n        ++index;\n        if ('lL'.indexOf(input.charAt(index) || null) >= 0) {\n          ++index;\n          return 'LL';\n        } else {\n          raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n        }\n    }\n  }\n\n  function readHexLiteral() {\n    var fraction = 0 // defaults to 0 as it gets summed\n      , binaryExponent = 1 // defaults to 1 as it gets multiplied\n      , binarySign = 1 // positive\n      , digit, fractionStart, exponentStart, digitStart;\n\n    digitStart = index += 2; // Skip 0x part\n    if (!isHexDigit(input.charCodeAt(index)))\n      raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n\n    while (isHexDigit(input.charCodeAt(index))) ++index;\n    digit = parseInt(input.slice(digitStart, index), 16);\n    var foundFraction = false;\n    if ('.' === input.charAt(index)) {\n      foundFraction = true;\n      fractionStart = ++index;\n\n      while (isHexDigit(input.charCodeAt(index))) ++index;\n      fraction = input.slice(fractionStart, index);\n      fraction = (fractionStart === index) ? 0\n        : parseInt(fraction, 16) / Math.pow(16, index - fractionStart);\n    }\n    var foundBinaryExponent = false;\n    if ('pP'.indexOf(input.charAt(index) || null) >= 0) {\n      foundBinaryExponent = true;\n      ++index;\n      if ('+-'.indexOf(input.charAt(index) || null) >= 0)\n        binarySign = ('+' === input.charAt(index++)) ? 1 : -1;\n\n      exponentStart = index;\n      if (!isDecDigit(input.charCodeAt(index)))\n        raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n\n      while (isDecDigit(input.charCodeAt(index))) ++index;\n      binaryExponent = input.slice(exponentStart, index);\n      binaryExponent = Math.pow(2, binaryExponent * binarySign);\n    }\n\n    return {\n      value: (digit + fraction) * binaryExponent,\n      hasFractionPart: foundFraction || foundBinaryExponent\n    };\n  }\n\n  function readDecLiteral() {\n    while (isDecDigit(input.charCodeAt(index))) ++index;\n    var foundFraction = false;\n    if ('.' === input.charAt(index)) {\n      foundFraction = true;\n      ++index;\n      while (isDecDigit(input.charCodeAt(index))) ++index;\n    }\n    var foundExponent = false;\n    if ('eE'.indexOf(input.charAt(index) || null) >= 0) {\n      foundExponent = true;\n      ++index;\n      if ('+-'.indexOf(input.charAt(index) || null) >= 0) ++index;\n      if (!isDecDigit(input.charCodeAt(index)))\n        raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n\n      while (isDecDigit(input.charCodeAt(index))) ++index;\n    }\n\n    return {\n      value: parseFloat(input.slice(tokenStart, index)),\n      hasFractionPart: foundFraction || foundExponent\n    };\n  }\n\n  function readUnicodeEscapeSequence() {\n    var sequenceStart = index++;\n\n    if (input.charAt(index++) !== '{')\n      raise(null, errors.braceExpected, '{', '\\\\' + input.slice(sequenceStart, index));\n    if (!isHexDigit(input.charCodeAt(index)))\n      raise(null, errors.hexadecimalDigitExpected, '\\\\' + input.slice(sequenceStart, index));\n\n    while (input.charCodeAt(index) === 0x30) ++index;\n    var escStart = index;\n\n    while (isHexDigit(input.charCodeAt(index))) {\n      ++index;\n      if (index - escStart > 6)\n        raise(null, errors.tooLargeCodepoint, '\\\\' + input.slice(sequenceStart, index));\n    }\n\n    var b = input.charAt(index++);\n    if (b !== '}') {\n      if ((b === '\"') || (b === \"'\"))\n        raise(null, errors.braceExpected, '}', '\\\\' + input.slice(sequenceStart, index--));\n      else\n        raise(null, errors.hexadecimalDigitExpected, '\\\\' + input.slice(sequenceStart, index));\n    }\n\n    var codepoint = parseInt(input.slice(escStart, index - 1) || '0', 16);\n    var frag = '\\\\' + input.slice(sequenceStart, index);\n\n    if (codepoint > 0x10ffff) {\n      raise(null, errors.tooLargeCodepoint, frag);\n    }\n\n    return encodingMode.encodeUTF8(codepoint, frag);\n  }\n  function readEscapeSequence() {\n    var sequenceStart = index;\n    switch (input.charAt(index)) {\n      case 'a': ++index; return '\\x07';\n      case 'n': ++index; return '\\n';\n      case 'r': ++index; return '\\r';\n      case 't': ++index; return '\\t';\n      case 'v': ++index; return '\\x0b';\n      case 'b': ++index; return '\\b';\n      case 'f': ++index; return '\\f';\n      case '\\r':\n      case '\\n':\n        consumeEOL();\n        return '\\n';\n\n      case '0': case '1': case '2': case '3': case '4':\n      case '5': case '6': case '7': case '8': case '9':\n        while (isDecDigit(input.charCodeAt(index)) && index - sequenceStart < 3) ++index;\n\n        var frag = input.slice(sequenceStart, index);\n        var ddd = parseInt(frag, 10);\n        if (ddd > 255) {\n          raise(null, errors.decimalEscapeTooLarge, '\\\\' + ddd);\n        }\n        return encodingMode.encodeByte(ddd, '\\\\' + frag);\n\n      case 'z':\n        if (features.skipWhitespaceEscape) {\n          ++index;\n          skipWhiteSpace();\n          return '';\n        }\n        break;\n\n      case 'x':\n        if (features.hexEscapes) {\n          if (isHexDigit(input.charCodeAt(index + 1)) &&\n              isHexDigit(input.charCodeAt(index + 2))) {\n            index += 3;\n            return encodingMode.encodeByte(parseInt(input.slice(sequenceStart + 1, index), 16), '\\\\' + input.slice(sequenceStart, index));\n          }\n          raise(null, errors.hexadecimalDigitExpected, '\\\\' + input.slice(sequenceStart, index + 2));\n        }\n        break;\n\n      case 'u':\n        if (features.unicodeEscapes)\n          return readUnicodeEscapeSequence();\n        break;\n\n      case '\\\\': case '\"': case \"'\":\n        return input.charAt(index++);\n    }\n\n    if (features.strictEscapes)\n      raise(null, errors.invalidEscape, '\\\\' + input.slice(sequenceStart, index + 1));\n    return input.charAt(index++);\n  }\n\n  function scanComment() {\n    tokenStart = index;\n    index += 2; // --\n\n    var character = input.charAt(index)\n      , content = ''\n      , isLong = false\n      , commentStart = index\n      , lineStartComment = lineStart\n      , lineComment = line;\n\n    if ('[' === character) {\n      content = readLongString(true);\n      if (false === content) content = character;\n      else isLong = true;\n    }\n    if (!isLong) {\n      while (index < length) {\n        if (isLineTerminator(input.charCodeAt(index))) break;\n        ++index;\n      }\n      if (options.comments) content = input.slice(commentStart, index);\n    }\n\n    if (options.comments) {\n      var node = ast.comment(content, input.slice(tokenStart, index));\n      if (options.locations) {\n        node.loc = {\n            start: { line: lineComment, column: tokenStart - lineStartComment }\n          , end: { line: line, column: index - lineStart }\n        };\n      }\n      if (options.ranges) {\n        node.range = [tokenStart, index];\n      }\n      if (options.onCreateNode) options.onCreateNode(node);\n      comments.push(node);\n    }\n  }\n\n  function readLongString(isComment) {\n    var level = 0\n      , content = ''\n      , terminator = false\n      , character, stringStart, firstLine = line;\n\n    ++index; // [\n    while ('=' === input.charAt(index + level)) ++level;\n    if ('[' !== input.charAt(index + level)) return false;\n\n    index += level + 1;\n    if (isLineTerminator(input.charCodeAt(index))) consumeEOL();\n\n    stringStart = index;\n    while (index < length) {\n      while (isLineTerminator(input.charCodeAt(index))) consumeEOL();\n\n      character = input.charAt(index++);\n      if (']' === character) {\n        terminator = true;\n        for (var i = 0; i < level; ++i) {\n          if ('=' !== input.charAt(index + i)) terminator = false;\n        }\n        if (']' !== input.charAt(index + level)) terminator = false;\n      }\n      if (terminator) {\n        content += input.slice(stringStart, index - 1);\n        index += level + 1;\n        return content;\n      }\n    }\n\n    raise(null, isComment ?\n                errors.unfinishedLongComment :\n                errors.unfinishedLongString,\n          firstLine, '<eof>');\n  }\n\n  function next() {\n    previousToken = token;\n    token = lookahead;\n    lookahead = lex();\n  }\n\n  function consume(value) {\n    if (value === token.value) {\n      next();\n      return true;\n    }\n    return false;\n  }\n\n  function expect(value) {\n    if (value === token.value) next();\n    else raise(token, errors.expected, value, tokenValue(token));\n  }\n\n  function isWhiteSpace(charCode) {\n    return 9 === charCode || 32 === charCode || 0xB === charCode || 0xC === charCode;\n  }\n\n  function isLineTerminator(charCode) {\n    return 10 === charCode || 13 === charCode;\n  }\n\n  function isDecDigit(charCode) {\n    return charCode >= 48 && charCode <= 57;\n  }\n\n  function isHexDigit(charCode) {\n    return (charCode >= 48 && charCode <= 57) || (charCode >= 97 && charCode <= 102) || (charCode >= 65 && charCode <= 70);\n  }\n\n  function isIdentifierStart(charCode) {\n    if ((charCode >= 65 && charCode <= 90) || (charCode >= 97 && charCode <= 122) || 95 === charCode)\n      return true;\n    if (features.extendedIdentifiers && charCode >= 128)\n      return true;\n    return false;\n  }\n\n  function isIdentifierPart(charCode) {\n    if ((charCode >= 65 && charCode <= 90) || (charCode >= 97 && charCode <= 122) || 95 === charCode || (charCode >= 48 && charCode <= 57))\n      return true;\n    if (features.extendedIdentifiers && charCode >= 128)\n      return true;\n    return false;\n  }\n\n  function isKeyword(id) {\n    switch (id.length) {\n      case 2:\n        return 'do' === id || 'if' === id || 'in' === id || 'or' === id;\n      case 3:\n        return 'and' === id || 'end' === id || 'for' === id || 'not' === id;\n      case 4:\n        if ('else' === id || 'then' === id)\n          return true;\n        if (features.labels && !features.contextualGoto)\n          return ('goto' === id);\n        return false;\n      case 5:\n        return 'break' === id || 'local' === id || 'until' === id || 'while' === id;\n      case 6:\n        return 'elseif' === id || 'repeat' === id || 'return' === id;\n      case 8:\n        return 'function' === id;\n    }\n    return false;\n  }\n\n  function isUnary(token) {\n    if (Punctuator === token.type) return '#-~'.indexOf(token.value) >= 0;\n    if (Keyword === token.type) return 'not' === token.value;\n    return false;\n  }\n\n  function isBlockFollow(token) {\n    if (EOF === token.type) return true;\n    if (Keyword !== token.type) return false;\n    switch (token.value) {\n      case 'else': case 'elseif':\n      case 'end': case 'until':\n        return true;\n      default:\n        return false;\n    }\n  }\n  var scopes\n    , scopeDepth\n    , globals;\n  function createScope() {\n    var scope = scopes[scopeDepth++].slice();\n    scopes.push(scope);\n    if (options.onCreateScope) options.onCreateScope();\n  }\n  function destroyScope() {\n    var scope = scopes.pop();\n    --scopeDepth;\n    if (options.onDestroyScope) options.onDestroyScope();\n  }\n  function scopeIdentifierName(name) {\n    if (options.onLocalDeclaration) options.onLocalDeclaration(name);\n    if (-1 !== indexOf(scopes[scopeDepth], name)) return;\n    scopes[scopeDepth].push(name);\n  }\n  function scopeIdentifier(node) {\n    scopeIdentifierName(node.name);\n    attachScope(node, true);\n  }\n  function attachScope(node, isLocal) {\n    if (!isLocal && -1 === indexOfObject(globals, 'name', node.name))\n      globals.push(node);\n\n    node.isLocal = isLocal;\n  }\n  function scopeHasName(name) {\n    return (-1 !== indexOf(scopes[scopeDepth], name));\n  }\n\n  var locations = []\n    , trackLocations;\n\n  function createLocationMarker() {\n    return new Marker(token);\n  }\n\n  function Marker(token) {\n    if (options.locations) {\n      this.loc = {\n          start: {\n            line: token.line\n          , column: token.range[0] - token.lineStart\n        }\n        , end: {\n            line: 0\n          , column: 0\n        }\n      };\n    }\n    if (options.ranges) this.range = [token.range[0], 0];\n  }\n  Marker.prototype.complete = function() {\n    if (options.locations) {\n      this.loc.end.line = previousToken.lastLine || previousToken.line;\n      this.loc.end.column = previousToken.range[1] - (previousToken.lastLineStart || previousToken.lineStart);\n    }\n    if (options.ranges) {\n      this.range[1] = previousToken.range[1];\n    }\n  };\n\n  Marker.prototype.bless = function (node) {\n    if (this.loc) {\n      var loc = this.loc;\n      node.loc = {\n        start: {\n          line: loc.start.line,\n          column: loc.start.column\n        },\n        end: {\n          line: loc.end.line,\n          column: loc.end.column\n        }\n      };\n    }\n    if (this.range) {\n      node.range = [\n        this.range[0],\n        this.range[1]\n      ];\n    }\n  };\n  function markLocation() {\n    if (trackLocations) locations.push(createLocationMarker());\n  }\n  function pushLocation(marker) {\n    if (trackLocations) locations.push(marker);\n  }\n\n  function FullFlowContext() {\n    this.scopes = [];\n    this.pendingGotos = [];\n  }\n\n  FullFlowContext.prototype.isInLoop = function () {\n    var i = this.scopes.length;\n    while (i --> 0) {\n      if (this.scopes[i].isLoop)\n        return true;\n    }\n    return false;\n  };\n\n  FullFlowContext.prototype.pushScope = function (isLoop) {\n    var scope = {\n      labels: {},\n      locals: [],\n      deferredGotos: [],\n      isLoop: !!isLoop\n    };\n    this.scopes.push(scope);\n  };\n\n  FullFlowContext.prototype.popScope = function () {\n    for (var i = 0; i < this.pendingGotos.length; ++i) {\n      var theGoto = this.pendingGotos[i];\n      if (theGoto.maxDepth >= this.scopes.length)\n        if (--theGoto.maxDepth <= 0)\n          raise(theGoto.token, errors.labelNotVisible, theGoto.target);\n    }\n\n    this.scopes.pop();\n  };\n\n  FullFlowContext.prototype.addGoto = function (target, token) {\n    var localCounts = [];\n\n    for (var i = 0; i < this.scopes.length; ++i) {\n      var scope = this.scopes[i];\n      localCounts.push(scope.locals.length);\n      if (Object.prototype.hasOwnProperty.call(scope.labels, target))\n        return;\n    }\n\n    this.pendingGotos.push({\n      maxDepth: this.scopes.length,\n      target: target,\n      token: token,\n      localCounts: localCounts\n    });\n  };\n\n  FullFlowContext.prototype.addLabel = function (name, token) {\n    var scope = this.currentScope();\n\n    if (Object.prototype.hasOwnProperty.call(scope.labels, name)) {\n      raise(token, errors.labelAlreadyDefined, name, scope.labels[name].line);\n    } else {\n      var newGotos = [];\n\n      for (var i = 0; i < this.pendingGotos.length; ++i) {\n        var theGoto = this.pendingGotos[i];\n\n        if (theGoto.maxDepth >= this.scopes.length && theGoto.target === name) {\n          if (theGoto.localCounts[this.scopes.length - 1] < scope.locals.length) {\n            scope.deferredGotos.push(theGoto);\n          }\n          continue;\n        }\n\n        newGotos.push(theGoto);\n      }\n\n      this.pendingGotos = newGotos;\n    }\n\n    scope.labels[name] = {\n      localCount: scope.locals.length,\n      line: token.line\n    };\n  };\n\n  FullFlowContext.prototype.addLocal = function (name, token) {\n    this.currentScope().locals.push({\n      name: name,\n      token: token\n    });\n  };\n\n  FullFlowContext.prototype.currentScope = function () {\n    return this.scopes[this.scopes.length - 1];\n  };\n\n  FullFlowContext.prototype.raiseDeferredErrors = function () {\n    var scope = this.currentScope();\n    var bads = scope.deferredGotos;\n    for (var i = 0; i < bads.length; ++i) {\n      var theGoto = bads[i];\n      raise(theGoto.token, errors.gotoJumpInLocalScope, theGoto.target, scope.locals[theGoto.localCounts[this.scopes.length - 1]].name);\n    }\n  };\n\n  function LoopFlowContext() {\n    this.level = 0;\n    this.loopLevels = [];\n  }\n\n  LoopFlowContext.prototype.isInLoop = function () {\n    return !!this.loopLevels.length;\n  };\n\n  LoopFlowContext.prototype.pushScope = function (isLoop) {\n    ++this.level;\n    if (isLoop)\n      this.loopLevels.push(this.level);\n  };\n\n  LoopFlowContext.prototype.popScope = function () {\n    var levels = this.loopLevels;\n    var levlen = levels.length;\n    if (levlen) {\n      if (levels[levlen - 1] === this.level)\n        levels.pop();\n    }\n    --this.level;\n  };\n\n  LoopFlowContext.prototype.addGoto =\n  LoopFlowContext.prototype.addLabel =\n  function () { throw new Error('This should never happen'); };\n\n  LoopFlowContext.prototype.addLocal =\n  LoopFlowContext.prototype.raiseDeferredErrors =\n  function () {};\n\n  function makeFlowContext() {\n    return features.labels ? new FullFlowContext() : new LoopFlowContext();\n  }\n\n  function parseChunk() {\n    next();\n    markLocation();\n    if (options.scope) createScope();\n    var flowContext = makeFlowContext();\n    flowContext.allowVararg = true;\n    flowContext.pushScope();\n    var body = parseBlock(flowContext);\n    flowContext.popScope();\n    if (options.scope) destroyScope();\n    if (EOF !== token.type) unexpected(token);\n    if (trackLocations && !body.length) previousToken = token;\n    return finishNode(ast.chunk(body));\n  }\n\n  function parseBlock(flowContext) {\n    var block = []\n      , statement;\n\n    while (!isBlockFollow(token)) {\n      if ('return' === token.value || (!features.relaxedBreak && 'break' === token.value)) {\n        block.push(parseStatement(flowContext));\n        break;\n      }\n      statement = parseStatement(flowContext);\n      consume(';');\n      if (statement) block.push(statement);\n    }\n    return block;\n  }\n\n  function parseStatement(flowContext) {\n    markLocation();\n\n    if (Punctuator === token.type) {\n      if (consume('::')) return parseLabelStatement(flowContext);\n    }\n    if (features.emptyStatement) {\n      if (consume(';')) {\n        if (trackLocations) locations.pop();\n        return;\n      }\n    }\n\n    flowContext.raiseDeferredErrors();\n\n    if (Keyword === token.type) {\n      switch (token.value) {\n        case 'local':    next(); return parseLocalStatement(flowContext);\n        case 'if':       next(); return parseIfStatement(flowContext);\n        case 'return':   next(); return parseReturnStatement(flowContext);\n        case 'function': next();\n          var name = parseFunctionName();\n          return parseFunctionDeclaration(name);\n        case 'while':    next(); return parseWhileStatement(flowContext);\n        case 'for':      next(); return parseForStatement(flowContext);\n        case 'repeat':   next(); return parseRepeatStatement(flowContext);\n        case 'break':    next();\n          if (!flowContext.isInLoop())\n            raise(token, errors.noLoopToBreak, token.value);\n          return parseBreakStatement();\n        case 'do':       next(); return parseDoStatement(flowContext);\n        case 'goto':     next(); return parseGotoStatement(flowContext);\n      }\n    }\n\n    if (features.contextualGoto &&\n        token.type === Identifier && token.value === 'goto' &&\n        lookahead.type === Identifier && lookahead.value !== 'goto') {\n      next(); return parseGotoStatement(flowContext);\n    }\n    if (trackLocations) locations.pop();\n\n    return parseAssignmentOrCallStatement(flowContext);\n  }\n\n  function parseLabelStatement(flowContext) {\n    var nameToken = token\n      , label = parseIdentifier();\n\n    if (options.scope) {\n      scopeIdentifierName('::' + nameToken.value + '::');\n      attachScope(label, true);\n    }\n\n    expect('::');\n\n    flowContext.addLabel(nameToken.value, nameToken);\n    return finishNode(ast.labelStatement(label));\n  }\n\n  function parseBreakStatement() {\n    return finishNode(ast.breakStatement());\n  }\n\n  function parseGotoStatement(flowContext) {\n    var name = token.value\n      , gotoToken = previousToken\n      , label = parseIdentifier();\n\n    flowContext.addGoto(name, gotoToken);\n    return finishNode(ast.gotoStatement(label));\n  }\n\n  function parseDoStatement(flowContext) {\n    if (options.scope) createScope();\n    flowContext.pushScope();\n    var body = parseBlock(flowContext);\n    flowContext.popScope();\n    if (options.scope) destroyScope();\n    expect('end');\n    return finishNode(ast.doStatement(body));\n  }\n\n  function parseWhileStatement(flowContext) {\n    var condition = parseExpectedExpression(flowContext);\n    expect('do');\n    if (options.scope) createScope();\n    flowContext.pushScope(true);\n    var body = parseBlock(flowContext);\n    flowContext.popScope();\n    if (options.scope) destroyScope();\n    expect('end');\n    return finishNode(ast.whileStatement(condition, body));\n  }\n\n  function parseRepeatStatement(flowContext) {\n    if (options.scope) createScope();\n    flowContext.pushScope(true);\n    var body = parseBlock(flowContext);\n    expect('until');\n    flowContext.raiseDeferredErrors();\n    var condition = parseExpectedExpression(flowContext);\n    flowContext.popScope();\n    if (options.scope) destroyScope();\n    return finishNode(ast.repeatStatement(condition, body));\n  }\n\n  function parseReturnStatement(flowContext) {\n    var expressions = [];\n\n    if ('end' !== token.value) {\n      var expression = parseExpression(flowContext);\n      if (null != expression) expressions.push(expression);\n      while (consume(',')) {\n        expression = parseExpectedExpression(flowContext);\n        expressions.push(expression);\n      }\n      consume(';'); // grammar tells us ; is optional here.\n    }\n    return finishNode(ast.returnStatement(expressions));\n  }\n\n  function parseIfStatement(flowContext) {\n    var clauses = []\n      , condition\n      , body\n      , marker;\n    if (trackLocations) {\n      marker = locations[locations.length - 1];\n      locations.push(marker);\n    }\n    condition = parseExpectedExpression(flowContext);\n    expect('then');\n    if (options.scope) createScope();\n    flowContext.pushScope();\n    body = parseBlock(flowContext);\n    flowContext.popScope();\n    if (options.scope) destroyScope();\n    clauses.push(finishNode(ast.ifClause(condition, body)));\n\n    if (trackLocations) marker = createLocationMarker();\n    while (consume('elseif')) {\n      pushLocation(marker);\n      condition = parseExpectedExpression(flowContext);\n      expect('then');\n      if (options.scope) createScope();\n      flowContext.pushScope();\n      body = parseBlock(flowContext);\n      flowContext.popScope();\n      if (options.scope) destroyScope();\n      clauses.push(finishNode(ast.elseifClause(condition, body)));\n      if (trackLocations) marker = createLocationMarker();\n    }\n\n    if (consume('else')) {\n      if (trackLocations) {\n        marker = new Marker(previousToken);\n        locations.push(marker);\n      }\n      if (options.scope) createScope();\n      flowContext.pushScope();\n      body = parseBlock(flowContext);\n      flowContext.popScope();\n      if (options.scope) destroyScope();\n      clauses.push(finishNode(ast.elseClause(body)));\n    }\n\n    expect('end');\n    return finishNode(ast.ifStatement(clauses));\n  }\n\n  function parseForStatement(flowContext) {\n    var variable = parseIdentifier()\n      , body;\n\n    if (options.scope) {\n      createScope();\n      scopeIdentifier(variable);\n    }\n    if (consume('=')) {\n      var start = parseExpectedExpression(flowContext);\n      expect(',');\n      var end = parseExpectedExpression(flowContext);\n      var step = consume(',') ? parseExpectedExpression(flowContext) : null;\n\n      expect('do');\n      flowContext.pushScope(true);\n      body = parseBlock(flowContext);\n      flowContext.popScope();\n      expect('end');\n      if (options.scope) destroyScope();\n\n      return finishNode(ast.forNumericStatement(variable, start, end, step, body));\n    }\n    else {\n      var variables = [variable];\n      while (consume(',')) {\n        variable = parseIdentifier();\n        if (options.scope) scopeIdentifier(variable);\n        variables.push(variable);\n      }\n      expect('in');\n      var iterators = [];\n      do {\n        var expression = parseExpectedExpression(flowContext);\n        iterators.push(expression);\n      } while (consume(','));\n\n      expect('do');\n      flowContext.pushScope(true);\n      body = parseBlock(flowContext);\n      flowContext.popScope();\n      expect('end');\n      if (options.scope) destroyScope();\n\n      return finishNode(ast.forGenericStatement(variables, iterators, body));\n    }\n  }\n\n  function parseLocalStatement(flowContext) {\n    var name\n      , declToken = previousToken;\n\n    if (Identifier === token.type) {\n      var variables = []\n        , init = [];\n\n      do {\n        name = parseIdentifier();\n\n        variables.push(name);\n        flowContext.addLocal(name.name, declToken);\n      } while (consume(','));\n\n      if (consume('=')) {\n        do {\n          var expression = parseExpectedExpression(flowContext);\n          init.push(expression);\n        } while (consume(','));\n      }\n      if (options.scope) {\n        for (var i = 0, l = variables.length; i < l; ++i) {\n          scopeIdentifier(variables[i]);\n        }\n      }\n\n      return finishNode(ast.localStatement(variables, init));\n    }\n    if (consume('function')) {\n      name = parseIdentifier();\n      flowContext.addLocal(name.name, declToken);\n\n      if (options.scope) {\n        scopeIdentifier(name);\n        createScope();\n      }\n      return parseFunctionDeclaration(name, true);\n    } else {\n      raiseUnexpectedToken('<name>', token);\n    }\n  }\n\n  function parseAssignmentOrCallStatement(flowContext) {\n    var previous = token\n      , marker, startMarker;\n    var lvalue, base, name;\n\n    var targets = [];\n\n    if (trackLocations) startMarker = createLocationMarker();\n\n    do {\n      if (trackLocations) marker = createLocationMarker();\n\n      if (Identifier === token.type) {\n        name = token.value;\n        base = parseIdentifier();\n        if (options.scope) attachScope(base, scopeHasName(name));\n        lvalue = true;\n      } else if ('(' === token.value) {\n        next();\n        base = parseExpectedExpression(flowContext);\n        expect(')');\n        lvalue = false;\n      } else {\n        return unexpected(token);\n      }\n\n      both: for (;;) {\n        var newBase;\n\n        switch (StringLiteral === token.type ? '\"' : token.value) {\n        case '.':\n        case '[':\n          lvalue = true;\n          break;\n        case ':':\n        case '(':\n        case '{':\n        case '\"':\n          lvalue = null;\n          break;\n        default:\n          break both;\n        }\n\n        base = parsePrefixExpressionPart(base, marker, flowContext);\n      }\n\n      targets.push(base);\n\n      if (',' !== token.value)\n        break;\n\n      if (!lvalue) {\n        return unexpected(token);\n      }\n\n      next();\n    } while (true);\n\n    if (targets.length === 1 && lvalue === null) {\n      pushLocation(marker);\n      return finishNode(ast.callStatement(targets[0]));\n    } else if (!lvalue) {\n      return unexpected(token);\n    }\n\n    expect('=');\n\n    var values = [];\n\n    do {\n      values.push(parseExpectedExpression(flowContext));\n    } while (consume(','));\n\n    pushLocation(startMarker);\n    return finishNode(ast.assignmentStatement(targets, values));\n  }\n\n  function parseIdentifier() {\n    markLocation();\n    var identifier = token.value;\n    if (Identifier !== token.type) raiseUnexpectedToken('<name>', token);\n    next();\n    return finishNode(ast.identifier(identifier));\n  }\n\n  function parseFunctionDeclaration(name, isLocal) {\n    var flowContext = makeFlowContext();\n    flowContext.pushScope();\n\n    var parameters = [];\n    expect('(');\n    if (!consume(')')) {\n      while (true) {\n        if (Identifier === token.type) {\n          var parameter = parseIdentifier();\n          if (options.scope) scopeIdentifier(parameter);\n\n          parameters.push(parameter);\n\n          if (consume(',')) continue;\n        }\n        else if (VarargLiteral === token.type) {\n          flowContext.allowVararg = true;\n          parameters.push(parsePrimaryExpression(flowContext));\n        } else {\n          raiseUnexpectedToken('<name> or \\'...\\'', token);\n        }\n        expect(')');\n        break;\n      }\n    }\n\n    var body = parseBlock(flowContext);\n    flowContext.popScope();\n    expect('end');\n    if (options.scope) destroyScope();\n\n    isLocal = isLocal || false;\n    return finishNode(ast.functionStatement(name, parameters, isLocal, body));\n  }\n\n  function parseFunctionName() {\n    var base, name, marker;\n\n    if (trackLocations) marker = createLocationMarker();\n    base = parseIdentifier();\n\n    if (options.scope) {\n      attachScope(base, scopeHasName(base.name));\n      createScope();\n    }\n\n    while (consume('.')) {\n      pushLocation(marker);\n      name = parseIdentifier();\n      base = finishNode(ast.memberExpression(base, '.', name));\n    }\n\n    if (consume(':')) {\n      pushLocation(marker);\n      name = parseIdentifier();\n      base = finishNode(ast.memberExpression(base, ':', name));\n      if (options.scope) scopeIdentifierName('self');\n    }\n\n    return base;\n  }\n\n  function parseTableConstructor(flowContext) {\n    var fields = []\n      , key, value;\n\n    while (true) {\n      markLocation();\n      if (Punctuator === token.type && consume('[')) {\n        key = parseExpectedExpression(flowContext);\n        expect(']');\n        expect('=');\n        value = parseExpectedExpression(flowContext);\n        fields.push(finishNode(ast.tableKey(key, value)));\n      } else if (Identifier === token.type) {\n        if ('=' === lookahead.value) {\n          key = parseIdentifier();\n          next();\n          value = parseExpectedExpression(flowContext);\n          fields.push(finishNode(ast.tableKeyString(key, value)));\n        } else {\n          value = parseExpectedExpression(flowContext);\n          fields.push(finishNode(ast.tableValue(value)));\n        }\n      } else {\n        if (null == (value = parseExpression(flowContext))) {\n          locations.pop();\n          break;\n        }\n        fields.push(finishNode(ast.tableValue(value)));\n      }\n      if (',;'.indexOf(token.value) >= 0) {\n        next();\n        continue;\n      }\n      break;\n    }\n    expect('}');\n    return finishNode(ast.tableConstructorExpression(fields));\n  }\n\n  function parseExpression(flowContext) {\n    var expression = parseSubExpression(0, flowContext);\n    return expression;\n  }\n\n  function parseExpectedExpression(flowContext) {\n    var expression = parseExpression(flowContext);\n    if (null == expression) raiseUnexpectedToken('<expression>', token);\n    else return expression;\n  }\n\n  function binaryPrecedence(operator) {\n    var charCode = operator.charCodeAt(0)\n      , length = operator.length;\n\n    if (1 === length) {\n      switch (charCode) {\n        case 94: return 12; // ^\n        case 42: case 47: case 37: return 10; // * / %\n        case 43: case 45: return 9; // + -\n        case 38: return 6; // &\n        case 126: return 5; // ~\n        case 124: return 4; // |\n        case 60: case 62: return 3; // < >\n      }\n    } else if (2 === length) {\n      switch (charCode) {\n        case 47: return 10; // //\n        case 46: return 8; // ..\n        case 60: case 62:\n            if('<<' === operator || '>>' === operator) return 7; // << >>\n            return 3; // <= >=\n        case 61: case 126: return 3; // == ~=\n        case 111: return 1; // or\n      }\n    } else if (97 === charCode && 'and' === operator) return 2;\n    return 0;\n  }\n\n  function parseSubExpression(minPrecedence, flowContext) {\n    var operator = token.value\n      , expression, marker;\n\n    if (trackLocations) marker = createLocationMarker();\n    if (isUnary(token)) {\n      markLocation();\n      next();\n      var argument = parseSubExpression(10, flowContext);\n      if (argument == null) raiseUnexpectedToken('<expression>', token);\n      expression = finishNode(ast.unaryExpression(operator, argument));\n    }\n    if (null == expression) {\n      expression = parsePrimaryExpression(flowContext);\n      if (null == expression) {\n        expression = parsePrefixExpression(flowContext);\n      }\n    }\n    if (null == expression) return null;\n\n    var precedence;\n    while (true) {\n      operator = token.value;\n\n      precedence = (Punctuator === token.type || Keyword === token.type) ?\n        binaryPrecedence(operator) : 0;\n\n      if (precedence === 0 || precedence <= minPrecedence) break;\n      if ('^' === operator || '..' === operator) --precedence;\n      next();\n      var right = parseSubExpression(precedence, flowContext);\n      if (null == right) raiseUnexpectedToken('<expression>', token);\n      if (trackLocations) locations.push(marker);\n      expression = finishNode(ast.binaryExpression(operator, expression, right));\n\n    }\n    return expression;\n  }\n\n  function parsePrefixExpressionPart(base, marker, flowContext) {\n    var expression, identifier;\n\n    if (Punctuator === token.type) {\n      switch (token.value) {\n        case '[':\n          pushLocation(marker);\n          next();\n          expression = parseExpectedExpression(flowContext);\n          expect(']');\n          return finishNode(ast.indexExpression(base, expression));\n        case '.':\n          pushLocation(marker);\n          next();\n          identifier = parseIdentifier();\n          return finishNode(ast.memberExpression(base, '.', identifier));\n        case ':':\n          pushLocation(marker);\n          next();\n          identifier = parseIdentifier();\n          base = finishNode(ast.memberExpression(base, ':', identifier));\n          pushLocation(marker);\n          return parseCallExpression(base, flowContext);\n        case '(': case '{': // args\n          pushLocation(marker);\n          return parseCallExpression(base, flowContext);\n      }\n    } else if (StringLiteral === token.type) {\n      pushLocation(marker);\n      return parseCallExpression(base, flowContext);\n    }\n\n    return null;\n  }\n\n  function parsePrefixExpression(flowContext) {\n    var base, name, marker;\n\n    if (trackLocations) marker = createLocationMarker();\n    if (Identifier === token.type) {\n      name = token.value;\n      base = parseIdentifier();\n      if (options.scope) attachScope(base, scopeHasName(name));\n    } else if (consume('(')) {\n      base = parseExpectedExpression(flowContext);\n      expect(')');\n    } else {\n      return null;\n    }\n    for (;;) {\n      var newBase = parsePrefixExpressionPart(base, marker, flowContext);\n      if (newBase === null)\n        break;\n      base = newBase;\n    }\n\n    return base;\n  }\n\n  function parseCallExpression(base, flowContext) {\n    if (Punctuator === token.type) {\n      switch (token.value) {\n        case '(':\n          if (!features.emptyStatement) {\n            if (token.line !== previousToken.line)\n              raise(null, errors.ambiguousSyntax, token.value);\n          }\n          next();\n          var expressions = [];\n          var expression = parseExpression(flowContext);\n          if (null != expression) expressions.push(expression);\n          while (consume(',')) {\n            expression = parseExpectedExpression(flowContext);\n            expressions.push(expression);\n          }\n\n          expect(')');\n          return finishNode(ast.callExpression(base, expressions));\n\n        case '{':\n          markLocation();\n          next();\n          var table = parseTableConstructor(flowContext);\n          return finishNode(ast.tableCallExpression(base, table));\n      }\n    } else if (StringLiteral === token.type) {\n      return finishNode(ast.stringCallExpression(base, parsePrimaryExpression(flowContext)));\n    }\n\n    raiseUnexpectedToken('function arguments', token);\n  }\n\n  function parsePrimaryExpression(flowContext) {\n    var literals = StringLiteral | NumericLiteral | BooleanLiteral | NilLiteral | VarargLiteral\n      , value = token.value\n      , type = token.type\n      , marker;\n\n    if (trackLocations) marker = createLocationMarker();\n\n    if (type === VarargLiteral && !flowContext.allowVararg) {\n      raise(token, errors.cannotUseVararg, token.value);\n    }\n\n    if (type & literals) {\n      pushLocation(marker);\n      var raw = input.slice(token.range[0], token.range[1]);\n      next();\n      return finishNode(ast.literal(type, value, raw));\n    } else if (Keyword === type && 'function' === value) {\n      pushLocation(marker);\n      next();\n      if (options.scope) createScope();\n      return parseFunctionDeclaration(null);\n    } else if (consume('{')) {\n      pushLocation(marker);\n      return parseTableConstructor(flowContext);\n    }\n  }\n\n  exports.parse = parse;\n\n  var versionFeatures = {\n    '5.1': {\n    },\n    '5.2': {\n      labels: true,\n      emptyStatement: true,\n      hexEscapes: true,\n      skipWhitespaceEscape: true,\n      strictEscapes: true,\n      relaxedBreak: true\n    },\n    '5.3': {\n      labels: true,\n      emptyStatement: true,\n      hexEscapes: true,\n      skipWhitespaceEscape: true,\n      strictEscapes: true,\n      unicodeEscapes: true,\n      bitwiseOperators: true,\n      integerDivision: true,\n      relaxedBreak: true\n    },\n    'LuaJIT': {\n      labels: true,\n      contextualGoto: true,\n      hexEscapes: true,\n      skipWhitespaceEscape: true,\n      strictEscapes: true,\n      unicodeEscapes: true,\n      imaginaryNumbers: true,\n      integerSuffixes: true\n    }\n  };\n\n  function parse(_input, _options) {\n    if ('undefined' === typeof _options && 'object' === typeof _input) {\n      _options = _input;\n      _input = undefined;\n    }\n    if (!_options) _options = {};\n\n    input = _input || '';\n    options = assign({}, defaultOptions, _options);\n    index = 0;\n    line = 1;\n    lineStart = 0;\n    length = input.length;\n    scopes = [[]];\n    scopeDepth = 0;\n    globals = [];\n    locations = [];\n\n    if (!Object.prototype.hasOwnProperty.call(versionFeatures, options.luaVersion)) {\n      throw new Error(sprintf(\"Lua version '%1' not supported\", options.luaVersion));\n    }\n\n    features = assign({}, versionFeatures[options.luaVersion]);\n    if (options.extendedIdentifiers !== void 0)\n      features.extendedIdentifiers = !!options.extendedIdentifiers;\n\n    if (!Object.prototype.hasOwnProperty.call(encodingModes, options.encodingMode)) {\n      throw new Error(sprintf(\"Encoding mode '%1' not supported\", options.encodingMode));\n    }\n\n    encodingMode = encodingModes[options.encodingMode];\n\n    if (options.comments) comments = [];\n    if (!options.wait) return end();\n    return exports;\n  }\n  exports.write = write;\n\n  function write(_input) {\n    input += String(_input);\n    length = input.length;\n    return exports;\n  }\n  exports.end = end;\n\n  function end(_input) {\n    if ('undefined' !== typeof _input) write(_input);\n    if (input && input.substr(0, 2) === '#!') input = input.replace(/^.*/, function (line) {\n      return line.replace(/./g, ' ');\n    });\n\n    length = input.length;\n    trackLocations = options.locations || options.ranges;\n    lookahead = lex();\n\n    var chunk = parseChunk();\n    if (options.comments) chunk.comments = comments;\n    if (options.scope) chunk.globals = globals;\n    if (locations.length > 0)\n      throw new Error('Location tracking failed. This is most likely a bug in luaparse');\n\n    return chunk;\n  }\n\n}));\n\n});\n\nace.define(\"ace/mode/lua_worker\",[], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar Mirror = require(\"../worker/mirror\").Mirror;\nvar luaparse = require(\"../mode/lua/luaparse\");\n\nvar Worker = exports.Worker = function(sender) {\n    Mirror.call(this, sender);\n    this.setTimeout(500);\n};\n\noop.inherits(Worker, Mirror);\n\n(function() {\n\n    this.onUpdate = function() {\n        var value = this.doc.getValue();\n        var errors = [];\n        try {\n            luaparse.parse(value);\n        } catch(e) {\n            if (e instanceof luaparse.SyntaxError) {\n                errors.push({\n                    row: e.line - 1,\n                    column: e.column,\n                    text: e.message,\n                    type: \"error\"\n                });\n            }\n        }\n        this.sender.emit(\"annotate\", errors);\n    };\n\n}).call(Worker.prototype);\n\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}