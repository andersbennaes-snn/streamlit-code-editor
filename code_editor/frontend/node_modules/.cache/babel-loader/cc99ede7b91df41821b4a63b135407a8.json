{"ast":null,"code":"ace.define(\"ace/ext/hardwrap\", [\"require\", \"exports\", \"module\", \"ace/range\", \"ace/editor\", \"ace/config\"], function (require, exports, module) {\n  \"use strict\";\n\n  var Range = require(\"../range\").Range;\n  function hardWrap(editor, options) {\n    var max = options.column || editor.getOption(\"printMarginColumn\");\n    var allowMerge = options.allowMerge != false;\n    var row = Math.min(options.startRow, options.endRow);\n    var endRow = Math.max(options.startRow, options.endRow);\n    var session = editor.session;\n    while (row <= endRow) {\n      var line = session.getLine(row);\n      if (line.length > max) {\n        var space = findSpace(line, max, 5);\n        if (space) {\n          var indentation = /^\\s*/.exec(line)[0];\n          session.replace(new Range(row, space.start, row, space.end), \"\\n\" + indentation);\n        }\n        endRow++;\n      } else if (allowMerge && /\\S/.test(line) && row != endRow) {\n        var nextLine = session.getLine(row + 1);\n        if (nextLine && /\\S/.test(nextLine)) {\n          var trimmedLine = line.replace(/\\s+$/, \"\");\n          var trimmedNextLine = nextLine.replace(/^\\s+/, \"\");\n          var mergedLine = trimmedLine + \" \" + trimmedNextLine;\n          var space = findSpace(mergedLine, max, 5);\n          if (space && space.start > trimmedLine.length || mergedLine.length < max) {\n            var replaceRange = new Range(row, trimmedLine.length, row + 1, nextLine.length - trimmedNextLine.length);\n            session.replace(replaceRange, \" \");\n            row--;\n            endRow--;\n          } else if (trimmedLine.length < line.length) {\n            session.remove(new Range(row, trimmedLine.length, row, line.length));\n          }\n        }\n      }\n      row++;\n    }\n    function findSpace(line, max, min) {\n      if (line.length < max) return;\n      var before = line.slice(0, max);\n      var after = line.slice(max);\n      var spaceAfter = /^(?:(\\s+)|(\\S+)(\\s+))/.exec(after);\n      var spaceBefore = /(?:(\\s+)|(\\s+)(\\S+))$/.exec(before);\n      var start = 0;\n      var end = 0;\n      if (spaceBefore && !spaceBefore[2]) {\n        start = max - spaceBefore[1].length;\n        end = max;\n      }\n      if (spaceAfter && !spaceAfter[2]) {\n        if (!start) start = max;\n        end = max + spaceAfter[1].length;\n      }\n      if (start) {\n        return {\n          start: start,\n          end: end\n        };\n      }\n      if (spaceBefore && spaceBefore[2] && spaceBefore.index > min) {\n        return {\n          start: spaceBefore.index,\n          end: spaceBefore.index + spaceBefore[2].length\n        };\n      }\n      if (spaceAfter && spaceAfter[2]) {\n        start = max + spaceAfter[2].length;\n        return {\n          start: start,\n          end: start + spaceAfter[3].length\n        };\n      }\n    }\n  }\n  function wrapAfterInput(e) {\n    if (e.command.name == \"insertstring\" && /\\S/.test(e.args)) {\n      var editor = e.editor;\n      var cursor = editor.selection.cursor;\n      if (cursor.column <= editor.renderer.$printMarginColumn) return;\n      var lastDelta = editor.session.$undoManager.$lastDelta;\n      hardWrap(editor, {\n        startRow: cursor.row,\n        endRow: cursor.row,\n        allowMerge: false\n      });\n      if (lastDelta != editor.session.$undoManager.$lastDelta) editor.session.markUndoGroup();\n    }\n  }\n  var Editor = require(\"../editor\").Editor;\n  require(\"../config\").defineOptions(Editor.prototype, \"editor\", {\n    hardWrap: {\n      set: function (val) {\n        if (val) {\n          this.commands.on(\"afterExec\", wrapAfterInput);\n        } else {\n          this.commands.off(\"afterExec\", wrapAfterInput);\n        }\n      },\n      value: false\n    }\n  });\n  exports.hardWrap = hardWrap;\n});\nace.define(\"ace/keyboard/vim\", [\"require\", \"exports\", \"module\", \"ace/range\", \"ace/lib/event_emitter\", \"ace/lib/dom\", \"ace/lib/oop\", \"ace/lib/keys\", \"ace/lib/event\", \"ace/search\", \"ace/lib/useragent\", \"ace/search_highlight\", \"ace/commands/multi_select_commands\", \"ace/mode/text\", \"ace/ext/hardwrap\", \"ace/multi_select\"], function (require, exports, module) {\n  // CodeMirror, copyright (c) by Marijn Haverbeke and others\n  'use strict';\n\n  function log() {\n    var d = \"\";\n    function format(p) {\n      if (typeof p != \"object\") return p + \"\";\n      if (\"line\" in p) {\n        return p.line + \":\" + p.ch;\n      }\n      if (\"anchor\" in p) {\n        return format(p.anchor) + \"->\" + format(p.head);\n      }\n      if (Array.isArray(p)) return \"[\" + p.map(function (x) {\n        return format(x);\n      }) + \"]\";\n      return JSON.stringify(p);\n    }\n    for (var i = 0; i < arguments.length; i++) {\n      var p = arguments[i];\n      var f = format(p);\n      d += f + \"  \";\n    }\n    console.log(d);\n  }\n  var Range = require(\"../range\").Range;\n  var EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\n  var domLib = require(\"../lib/dom\");\n  var oop = require(\"../lib/oop\");\n  var KEYS = require(\"../lib/keys\");\n  var event = require(\"../lib/event\");\n  var Search = require(\"../search\").Search;\n  var useragent = require(\"../lib/useragent\");\n  var SearchHighlight = require(\"../search_highlight\").SearchHighlight;\n  var multiSelectCommands = require(\"../commands/multi_select_commands\");\n  var TextModeTokenRe = require(\"../mode/text\").Mode.prototype.tokenRe;\n  var hardWrap = require(\"../ext/hardwrap\").hardWrap;\n  require(\"../multi_select\");\n  var CodeMirror = function (ace) {\n    this.ace = ace;\n    this.state = {};\n    this.marks = {};\n    this.options = {};\n    this.$uid = 0;\n    this.onChange = this.onChange.bind(this);\n    this.onSelectionChange = this.onSelectionChange.bind(this);\n    this.onBeforeEndOperation = this.onBeforeEndOperation.bind(this);\n    this.ace.on('change', this.onChange);\n    this.ace.on('changeSelection', this.onSelectionChange);\n    this.ace.on('beforeEndOperation', this.onBeforeEndOperation);\n  };\n  CodeMirror.Pos = function (line, ch) {\n    if (!(this instanceof Pos)) return new Pos(line, ch);\n    this.line = line;\n    this.ch = ch;\n  };\n  CodeMirror.defineOption = function (name, val, setter) {};\n  CodeMirror.commands = {\n    redo: function (cm) {\n      cm.ace.redo();\n    },\n    undo: function (cm) {\n      cm.ace.undo();\n    },\n    newlineAndIndent: function (cm) {\n      cm.ace.insert(\"\\n\");\n    },\n    goLineLeft: function (cm) {\n      cm.ace.selection.moveCursorLineStart();\n    },\n    goLineRight: function (cm) {\n      cm.ace.selection.moveCursorLineEnd();\n    }\n  };\n  CodeMirror.keyMap = {};\n  CodeMirror.addClass = CodeMirror.rmClass = function () {};\n  CodeMirror.e_stop = CodeMirror.e_preventDefault = event.stopEvent;\n  CodeMirror.keyName = function (e) {\n    var key = KEYS[e.keyCode] || e.key || \"\";\n    if (key.length == 1) key = key.toUpperCase();\n    key = event.getModifierString(e).replace(/(^|-)\\w/g, function (m) {\n      return m.toUpperCase();\n    }) + key;\n    return key;\n  };\n  CodeMirror.keyMap['default'] = function (key) {\n    return function (cm) {\n      var cmd = cm.ace.commands.commandKeyBinding[key.toLowerCase()];\n      return cmd && cm.ace.execCommand(cmd) !== false;\n    };\n  };\n  CodeMirror.lookupKey = function lookupKey(key, map, handle) {\n    if (!map) map = \"default\";\n    if (typeof map == \"string\") map = CodeMirror.keyMap[map];\n    var found = typeof map == \"function\" ? map(key) : map[key];\n    if (found === false) return \"nothing\";\n    if (found === \"...\") return \"multi\";\n    if (found != null && handle(found)) return \"handled\";\n    if (map.fallthrough) {\n      if (!Array.isArray(map.fallthrough)) return lookupKey(key, map.fallthrough, handle);\n      for (var i = 0; i < map.fallthrough.length; i++) {\n        var result = lookupKey(key, map.fallthrough[i], handle);\n        if (result) return result;\n      }\n    }\n  };\n  CodeMirror.findMatchingTag = function (cm, head) {\n    return cm.findMatchingTag(head);\n  };\n  CodeMirror.findEnclosingTag = function (cm, head) {};\n  CodeMirror.signal = function (o, name, e) {\n    return o._signal(name, e);\n  };\n  CodeMirror.on = event.addListener;\n  CodeMirror.off = event.removeListener;\n  CodeMirror.isWordChar = function (ch) {\n    if (ch < \"\\x7f\") return /^\\w$/.test(ch);\n    TextModeTokenRe.lastIndex = 0;\n    return TextModeTokenRe.test(ch);\n  };\n  (function () {\n    oop.implement(CodeMirror.prototype, EventEmitter);\n    this.destroy = function () {\n      this.ace.off('change', this.onChange);\n      this.ace.off('changeSelection', this.onSelectionChange);\n      this.ace.off('beforeEndOperation', this.onBeforeEndOperation);\n      this.removeOverlay();\n    };\n    this.virtualSelectionMode = function () {\n      return this.ace.inVirtualSelectionMode && this.ace.selection.index;\n    };\n    this.onChange = function (delta) {\n      var change = {\n        text: delta.action[0] == 'i' ? delta.lines : []\n      };\n      var curOp = this.curOp = this.curOp || {};\n      if (!curOp.changeHandlers) curOp.changeHandlers = this._eventRegistry[\"change\"] && this._eventRegistry[\"change\"].slice();\n      if (!curOp.lastChange) {\n        curOp.lastChange = curOp.change = change;\n      } else {\n        curOp.lastChange.next = curOp.lastChange = change;\n      }\n      this.$updateMarkers(delta);\n    };\n    this.onSelectionChange = function () {\n      var curOp = this.curOp = this.curOp || {};\n      if (!curOp.cursorActivityHandlers) curOp.cursorActivityHandlers = this._eventRegistry[\"cursorActivity\"] && this._eventRegistry[\"cursorActivity\"].slice();\n      this.curOp.cursorActivity = true;\n      if (this.ace.inMultiSelectMode) {\n        this.ace.keyBinding.removeKeyboardHandler(multiSelectCommands.keyboardHandler);\n      }\n    };\n    this.operation = function (fn, force) {\n      if (!force && this.curOp || force && this.curOp && this.curOp.force) {\n        return fn();\n      }\n      if (force || !this.ace.curOp) {\n        if (this.curOp) this.onBeforeEndOperation();\n      }\n      if (!this.ace.curOp) {\n        var prevOp = this.ace.prevOp;\n        this.ace.startOperation({\n          command: {\n            name: \"vim\",\n            scrollIntoView: \"cursor\"\n          }\n        });\n      }\n      var curOp = this.curOp = this.curOp || {};\n      this.curOp.force = force;\n      var result = fn();\n      if (this.ace.curOp && this.ace.curOp.command.name == \"vim\") {\n        if (this.state.dialog) this.ace.curOp.command.scrollIntoView = this.ace.curOp.vimDialogScroll;\n        this.ace.endOperation();\n        if (!curOp.cursorActivity && !curOp.lastChange && prevOp) this.ace.prevOp = prevOp;\n      }\n      if (force || !this.ace.curOp) {\n        if (this.curOp) this.onBeforeEndOperation();\n      }\n      return result;\n    };\n    this.onBeforeEndOperation = function () {\n      var op = this.curOp;\n      if (op) {\n        if (op.change) {\n          this.signal(\"change\", op.change, op);\n        }\n        if (op && op.cursorActivity) {\n          this.signal(\"cursorActivity\", null, op);\n        }\n        this.curOp = null;\n      }\n    };\n    this.signal = function (eventName, e, handlers) {\n      var listeners = handlers ? handlers[eventName + \"Handlers\"] : (this._eventRegistry || {})[eventName];\n      if (!listeners) return;\n      listeners = listeners.slice();\n      for (var i = 0; i < listeners.length; i++) listeners[i](this, e);\n    };\n    this.firstLine = function () {\n      return 0;\n    };\n    this.lastLine = function () {\n      return this.ace.session.getLength() - 1;\n    };\n    this.lineCount = function () {\n      return this.ace.session.getLength();\n    };\n    this.setCursor = function (line, ch) {\n      if (typeof line === 'object') {\n        ch = line.ch;\n        line = line.line;\n      }\n      var shouldScroll = !this.curOp && !this.ace.inVirtualSelectionMode;\n      if (!this.ace.inVirtualSelectionMode) this.ace.exitMultiSelectMode();\n      this.ace.session.unfold({\n        row: line,\n        column: ch\n      });\n      this.ace.selection.moveTo(line, ch);\n      if (shouldScroll) {\n        this.ace.renderer.scrollCursorIntoView();\n        this.ace.endOperation();\n      }\n    };\n    this.getCursor = function (p) {\n      var sel = this.ace.selection;\n      var pos = p == 'anchor' ? sel.isEmpty() ? sel.lead : sel.anchor : p == 'head' || !p ? sel.lead : sel.getRange()[p];\n      return toCmPos(pos);\n    };\n    this.listSelections = function (p) {\n      var ranges = this.ace.multiSelect.rangeList.ranges;\n      if (!ranges.length || this.ace.inVirtualSelectionMode) return [{\n        anchor: this.getCursor('anchor'),\n        head: this.getCursor('head')\n      }];\n      return ranges.map(function (r) {\n        return {\n          anchor: this.clipPos(toCmPos(r.cursor == r.end ? r.start : r.end)),\n          head: this.clipPos(toCmPos(r.cursor))\n        };\n      }, this);\n    };\n    this.setSelections = function (p, primIndex) {\n      var sel = this.ace.multiSelect;\n      var ranges = p.map(function (x) {\n        var anchor = toAcePos(x.anchor);\n        var head = toAcePos(x.head);\n        var r = Range.comparePoints(anchor, head) < 0 ? new Range.fromPoints(anchor, head) : new Range.fromPoints(head, anchor);\n        r.cursor = Range.comparePoints(r.start, head) ? r.end : r.start;\n        return r;\n      });\n      if (this.ace.inVirtualSelectionMode) {\n        this.ace.selection.fromOrientedRange(ranges[0]);\n        return;\n      }\n      if (!primIndex) {\n        ranges = ranges.reverse();\n      } else if (ranges[primIndex]) {\n        ranges.push(ranges.splice(primIndex, 1)[0]);\n      }\n      sel.toSingleRange(ranges[0].clone());\n      var session = this.ace.session;\n      for (var i = 0; i < ranges.length; i++) {\n        var range = session.$clipRangeToDocument(ranges[i]); // todo why ace doesn't do this?\n        sel.addRange(range);\n      }\n    };\n    this.setSelection = function (a, h, options) {\n      var sel = this.ace.selection;\n      sel.moveTo(a.line, a.ch);\n      sel.selectTo(h.line, h.ch);\n      if (options && options.origin == '*mouse') {\n        this.onBeforeEndOperation();\n      }\n    };\n    this.somethingSelected = function (p) {\n      return !this.ace.selection.isEmpty();\n    };\n    this.clipPos = function (p) {\n      var pos = this.ace.session.$clipPositionToDocument(p.line, p.ch);\n      return toCmPos(pos);\n    };\n    this.foldCode = function (pos) {\n      this.ace.session.$toggleFoldWidget(pos.line, {});\n    };\n    this.markText = function (cursor) {\n      return {\n        clear: function () {},\n        find: function () {}\n      };\n    };\n    this.$updateMarkers = function (delta) {\n      var isInsert = delta.action == \"insert\";\n      var start = delta.start;\n      var end = delta.end;\n      var rowShift = (end.row - start.row) * (isInsert ? 1 : -1);\n      var colShift = (end.column - start.column) * (isInsert ? 1 : -1);\n      if (isInsert) end = start;\n      for (var i in this.marks) {\n        var point = this.marks[i];\n        var cmp = Range.comparePoints(point, start);\n        if (cmp < 0) {\n          continue; // delta starts after the range\n        }\n\n        if (cmp === 0) {\n          if (isInsert) {\n            if (point.bias == 1) {\n              cmp = 1;\n            } else {\n              point.bias = -1;\n              continue;\n            }\n          }\n        }\n        var cmp2 = isInsert ? cmp : Range.comparePoints(point, end);\n        if (cmp2 > 0) {\n          point.row += rowShift;\n          point.column += point.row == end.row ? colShift : 0;\n          continue;\n        }\n        if (!isInsert && cmp2 <= 0) {\n          point.row = start.row;\n          point.column = start.column;\n          if (cmp2 === 0) point.bias = 1;\n        }\n      }\n    };\n    var Marker = function (cm, id, row, column) {\n      this.cm = cm;\n      this.id = id;\n      this.row = row;\n      this.column = column;\n      cm.marks[this.id] = this;\n    };\n    Marker.prototype.clear = function () {\n      delete this.cm.marks[this.id];\n    };\n    Marker.prototype.find = function () {\n      return toCmPos(this);\n    };\n    this.setBookmark = function (cursor, options) {\n      var bm = new Marker(this, this.$uid++, cursor.line, cursor.ch);\n      if (!options || !options.insertLeft) bm.$insertRight = true;\n      this.marks[bm.id] = bm;\n      return bm;\n    };\n    this.moveH = function (increment, unit) {\n      if (unit == 'char') {\n        var sel = this.ace.selection;\n        sel.clearSelection();\n        sel.moveCursorBy(0, increment);\n      }\n    };\n    this.findPosV = function (start, amount, unit, goalColumn) {\n      if (unit == 'page') {\n        var renderer = this.ace.renderer;\n        var config = renderer.layerConfig;\n        amount = amount * Math.floor(config.height / config.lineHeight);\n        unit = 'line';\n      }\n      if (unit == 'line') {\n        var screenPos = this.ace.session.documentToScreenPosition(start.line, start.ch);\n        if (goalColumn != null) screenPos.column = goalColumn;\n        screenPos.row += amount;\n        screenPos.row = Math.min(Math.max(0, screenPos.row), this.ace.session.getScreenLength() - 1);\n        var pos = this.ace.session.screenToDocumentPosition(screenPos.row, screenPos.column);\n        return toCmPos(pos);\n      } else {\n        debugger;\n      }\n    };\n    this.charCoords = function (pos, mode) {\n      if (mode == 'div' || !mode) {\n        var sc = this.ace.session.documentToScreenPosition(pos.line, pos.ch);\n        return {\n          left: sc.column,\n          top: sc.row\n        };\n      }\n      if (mode == 'local') {\n        var renderer = this.ace.renderer;\n        var sc = this.ace.session.documentToScreenPosition(pos.line, pos.ch);\n        var lh = renderer.layerConfig.lineHeight;\n        var cw = renderer.layerConfig.characterWidth;\n        var top = lh * sc.row;\n        return {\n          left: sc.column * cw,\n          top: top,\n          bottom: top + lh\n        };\n      }\n    };\n    this.coordsChar = function (pos, mode) {\n      var renderer = this.ace.renderer;\n      if (mode == 'local') {\n        var row = Math.max(0, Math.floor(pos.top / renderer.lineHeight));\n        var col = Math.max(0, Math.floor(pos.left / renderer.characterWidth));\n        var ch = renderer.session.screenToDocumentPosition(row, col);\n        return toCmPos(ch);\n      } else if (mode == 'div') {\n        throw \"not implemented\";\n      }\n    };\n    this.getSearchCursor = function (query, pos, caseFold) {\n      var caseSensitive = false;\n      var isRegexp = false;\n      if (query instanceof RegExp && !query.global) {\n        caseSensitive = !query.ignoreCase;\n        query = query.source;\n        isRegexp = true;\n      }\n      if (query == \"\\\\n\") {\n        query = \"\\n\";\n        isRegexp = false;\n      }\n      var search = new Search();\n      if (pos.ch == undefined) pos.ch = Number.MAX_VALUE;\n      var acePos = {\n        row: pos.line,\n        column: pos.ch\n      };\n      var cm = this;\n      var last = null;\n      return {\n        findNext: function () {\n          return this.find(false);\n        },\n        findPrevious: function () {\n          return this.find(true);\n        },\n        find: function (back) {\n          search.setOptions({\n            needle: query,\n            caseSensitive: caseSensitive,\n            wrap: false,\n            backwards: back,\n            regExp: isRegexp,\n            start: last || acePos\n          });\n          var range = search.find(cm.ace.session);\n          last = range;\n          return last && [!last.isEmpty()];\n        },\n        from: function () {\n          return last && toCmPos(last.start);\n        },\n        to: function () {\n          return last && toCmPos(last.end);\n        },\n        replace: function (text) {\n          if (last) {\n            last.end = cm.ace.session.doc.replace(last, text);\n          }\n        }\n      };\n    };\n    this.scrollTo = function (x, y) {\n      var renderer = this.ace.renderer;\n      var config = renderer.layerConfig;\n      var maxHeight = config.maxHeight;\n      maxHeight -= (renderer.$size.scrollerHeight - renderer.lineHeight) * renderer.$scrollPastEnd;\n      if (y != null) this.ace.session.setScrollTop(Math.max(0, Math.min(y, maxHeight)));\n      if (x != null) this.ace.session.setScrollLeft(Math.max(0, Math.min(x, config.width)));\n    };\n    this.scrollInfo = function () {\n      return 0;\n    };\n    this.scrollIntoView = function (pos, margin) {\n      if (pos) {\n        var renderer = this.ace.renderer;\n        var viewMargin = {\n          \"top\": 0,\n          \"bottom\": margin\n        };\n        renderer.scrollCursorIntoView(toAcePos(pos), renderer.lineHeight * 2 / renderer.$size.scrollerHeight, viewMargin);\n      }\n    };\n    this.getLine = function (row) {\n      return this.ace.session.getLine(row);\n    };\n    this.getRange = function (s, e) {\n      return this.ace.session.getTextRange(new Range(s.line, s.ch, e.line, e.ch));\n    };\n    this.replaceRange = function (text, s, e) {\n      if (!e) e = s;\n      var range = new Range(s.line, s.ch, e.line, e.ch);\n      this.ace.session.$clipRangeToDocument(range);\n      return this.ace.session.replace(range, text);\n    };\n    this.replaceSelection = this.replaceSelections = function (p) {\n      var sel = this.ace.selection;\n      if (this.ace.inVirtualSelectionMode) {\n        this.ace.session.replace(sel.getRange(), p[0] || \"\");\n        return;\n      }\n      sel.inVirtualSelectionMode = true;\n      var ranges = sel.rangeList.ranges;\n      if (!ranges.length) ranges = [this.ace.multiSelect.getRange()];\n      for (var i = ranges.length; i--;) this.ace.session.replace(ranges[i], p[i] || \"\");\n      sel.inVirtualSelectionMode = false;\n    };\n    this.getSelection = function () {\n      return this.ace.getSelectedText();\n    };\n    this.getSelections = function () {\n      return this.listSelections().map(function (x) {\n        return this.getRange(x.anchor, x.head);\n      }, this);\n    };\n    this.getInputField = function () {\n      return this.ace.textInput.getElement();\n    };\n    this.getWrapperElement = function () {\n      return this.ace.container;\n    };\n    var optMap = {\n      indentWithTabs: \"useSoftTabs\",\n      indentUnit: \"tabSize\",\n      tabSize: \"tabSize\",\n      firstLineNumber: \"firstLineNumber\",\n      readOnly: \"readOnly\"\n    };\n    this.setOption = function (name, val) {\n      this.state[name] = val;\n      switch (name) {\n        case 'indentWithTabs':\n          name = optMap[name];\n          val = !val;\n          break;\n        case 'keyMap':\n          this.state.$keyMap = val;\n          return;\n          break;\n        default:\n          name = optMap[name];\n      }\n      if (name) this.ace.setOption(name, val);\n    };\n    this.getOption = function (name) {\n      var val;\n      var aceOpt = optMap[name];\n      if (aceOpt) val = this.ace.getOption(aceOpt);\n      switch (name) {\n        case 'indentWithTabs':\n          name = optMap[name];\n          return !val;\n        case 'keyMap':\n          return this.state.$keyMap || 'vim';\n      }\n      return aceOpt ? val : this.state[name];\n    };\n    this.toggleOverwrite = function (on) {\n      this.state.overwrite = on;\n      return this.ace.setOverwrite(on);\n    };\n    this.addOverlay = function (o) {\n      if (!this.$searchHighlight || !this.$searchHighlight.session) {\n        var highlight = new SearchHighlight(null, \"ace_highlight-marker\", \"text\");\n        var marker = this.ace.session.addDynamicMarker(highlight);\n        highlight.id = marker.id;\n        highlight.session = this.ace.session;\n        highlight.destroy = function (o) {\n          highlight.session.off(\"change\", highlight.updateOnChange);\n          highlight.session.off(\"changeEditor\", highlight.destroy);\n          highlight.session.removeMarker(highlight.id);\n          highlight.session = null;\n        };\n        highlight.updateOnChange = function (delta) {\n          var row = delta.start.row;\n          if (row == delta.end.row) highlight.cache[row] = undefined;else highlight.cache.splice(row, highlight.cache.length);\n        };\n        highlight.session.on(\"changeEditor\", highlight.destroy);\n        highlight.session.on(\"change\", highlight.updateOnChange);\n      }\n      var re = new RegExp(o.query.source, \"gmi\");\n      this.$searchHighlight = o.highlight = highlight;\n      this.$searchHighlight.setRegexp(re);\n      this.ace.renderer.updateBackMarkers();\n    };\n    this.removeOverlay = function (o) {\n      if (this.$searchHighlight && this.$searchHighlight.session) {\n        this.$searchHighlight.destroy();\n      }\n    };\n    this.getScrollInfo = function () {\n      var renderer = this.ace.renderer;\n      var config = renderer.layerConfig;\n      return {\n        left: renderer.scrollLeft,\n        top: renderer.scrollTop,\n        height: config.maxHeight,\n        width: config.width,\n        clientHeight: config.height,\n        clientWidth: config.width\n      };\n    };\n    this.getValue = function () {\n      return this.ace.getValue();\n    };\n    this.setValue = function (v) {\n      return this.ace.setValue(v, -1);\n    };\n    this.getTokenTypeAt = function (pos) {\n      var token = this.ace.session.getTokenAt(pos.line, pos.ch);\n      return token && /comment|string/.test(token.type) ? \"string\" : \"\";\n    };\n    this.findMatchingBracket = function (pos) {\n      var m = this.ace.session.findMatchingBracket(toAcePos(pos));\n      return {\n        to: m && toCmPos(m)\n      };\n    };\n    this.findMatchingTag = function (pos) {\n      var m = this.ace.session.getMatchingTags(toAcePos(pos));\n      if (!m) return;\n      return {\n        open: {\n          from: toCmPos(m.openTag.start),\n          to: toCmPos(m.openTag.end)\n        },\n        close: {\n          from: toCmPos(m.closeTag.start),\n          to: toCmPos(m.closeTag.end)\n        }\n      };\n    };\n    this.indentLine = function (line, method) {\n      if (method === true) this.ace.session.indentRows(line, line, \"\\t\");else if (method === false) this.ace.session.outdentRows(new Range(line, 0, line, 0));\n    };\n    this.indexFromPos = function (pos) {\n      return this.ace.session.doc.positionToIndex(toAcePos(pos));\n    };\n    this.posFromIndex = function (index) {\n      return toCmPos(this.ace.session.doc.indexToPosition(index));\n    };\n    this.focus = function (index) {\n      return this.ace.textInput.focus();\n    };\n    this.blur = function (index) {\n      return this.ace.blur();\n    };\n    this.defaultTextHeight = function (index) {\n      return this.ace.renderer.layerConfig.lineHeight;\n    };\n    this.scanForBracket = function (pos, dir, _, options) {\n      var re = options.bracketRegex.source;\n      var tokenRe = /paren|text|operator|tag/;\n      if (dir == 1) {\n        var m = this.ace.session.$findClosingBracket(re.slice(1, 2), toAcePos(pos), tokenRe);\n      } else {\n        var m = this.ace.session.$findOpeningBracket(re.slice(-2, -1), {\n          row: pos.line,\n          column: pos.ch + 1\n        }, tokenRe);\n      }\n      return m && {\n        pos: toCmPos(m)\n      };\n    };\n    this.refresh = function () {\n      return this.ace.resize(true);\n    };\n    this.getMode = function () {\n      return {\n        name: this.getOption(\"mode\")\n      };\n    };\n    this.execCommand = function (name) {\n      if (CodeMirror.commands.hasOwnProperty(name)) return CodeMirror.commands[name](this);\n      if (name == \"indentAuto\") return this.ace.execCommand(\"autoindent\");\n      console.log(name + \" is not implemented\");\n    };\n    this.getLineNumber = function (handle) {\n      return handle.row;\n    };\n    this.getLineHandle = function (row) {\n      return {\n        text: this.ace.session.getLine(row),\n        row: row\n      };\n    };\n  }).call(CodeMirror.prototype);\n  function toAcePos(cmPos) {\n    return {\n      row: cmPos.line,\n      column: cmPos.ch\n    };\n  }\n  function toCmPos(acePos) {\n    return new Pos(acePos.row, acePos.column);\n  }\n  var StringStream = CodeMirror.StringStream = function (string, tabSize) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n  };\n  StringStream.prototype = {\n    eol: function () {\n      return this.pos >= this.string.length;\n    },\n    sol: function () {\n      return this.pos == this.lineStart;\n    },\n    peek: function () {\n      return this.string.charAt(this.pos) || undefined;\n    },\n    next: function () {\n      if (this.pos < this.string.length) return this.string.charAt(this.pos++);\n    },\n    eat: function (match) {\n      var ch = this.string.charAt(this.pos);\n      if (typeof match == \"string\") var ok = ch == match;else var ok = ch && (match.test ? match.test(ch) : match(ch));\n      if (ok) {\n        ++this.pos;\n        return ch;\n      }\n    },\n    eatWhile: function (match) {\n      var start = this.pos;\n      while (this.eat(match)) {}\n      return this.pos > start;\n    },\n    eatSpace: function () {\n      var start = this.pos;\n      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n      return this.pos > start;\n    },\n    skipToEnd: function () {\n      this.pos = this.string.length;\n    },\n    skipTo: function (ch) {\n      var found = this.string.indexOf(ch, this.pos);\n      if (found > -1) {\n        this.pos = found;\n        return true;\n      }\n    },\n    backUp: function (n) {\n      this.pos -= n;\n    },\n    column: function () {\n      throw \"not implemented\";\n    },\n    indentation: function () {\n      throw \"not implemented\";\n    },\n    match: function (pattern, consume, caseInsensitive) {\n      if (typeof pattern == \"string\") {\n        var cased = function (str) {\n          return caseInsensitive ? str.toLowerCase() : str;\n        };\n        var substr = this.string.substr(this.pos, pattern.length);\n        if (cased(substr) == cased(pattern)) {\n          if (consume !== false) this.pos += pattern.length;\n          return true;\n        }\n      } else {\n        var match = this.string.slice(this.pos).match(pattern);\n        if (match && match.index > 0) return null;\n        if (match && consume !== false) this.pos += match[0].length;\n        return match;\n      }\n    },\n    current: function () {\n      return this.string.slice(this.start, this.pos);\n    },\n    hideFirstChars: function (n, inner) {\n      this.lineStart += n;\n      try {\n        return inner();\n      } finally {\n        this.lineStart -= n;\n      }\n    }\n  };\n  CodeMirror.defineExtension = function (name, fn) {\n    CodeMirror.prototype[name] = fn;\n  };\n  domLib.importCssString(\".normal-mode .ace_cursor{\\n    border: none;\\n    background-color: rgba(255,0,0,0.5);\\n}\\n.normal-mode .ace_hidden-cursors .ace_cursor{\\n  background-color: transparent;\\n  border: 1px solid red;\\n  opacity: 0.7\\n}\\n.ace_dialog {\\n  position: absolute;\\n  left: 0; right: 0;\\n  background: inherit;\\n  z-index: 15;\\n  padding: .1em .8em;\\n  overflow: hidden;\\n  color: inherit;\\n}\\n.ace_dialog-top {\\n  border-bottom: 1px solid #444;\\n  top: 0;\\n}\\n.ace_dialog-bottom {\\n  border-top: 1px solid #444;\\n  bottom: 0;\\n}\\n.ace_dialog input {\\n  border: none;\\n  outline: none;\\n  background: transparent;\\n  width: 20em;\\n  color: inherit;\\n  font-family: monospace;\\n}\", \"vimMode\", false);\n  (function () {\n    function dialogDiv(cm, template, bottom) {\n      var wrap = cm.ace.container;\n      var dialog;\n      dialog = wrap.appendChild(document.createElement(\"div\"));\n      if (bottom) dialog.className = \"ace_dialog ace_dialog-bottom\";else dialog.className = \"ace_dialog ace_dialog-top\";\n      if (typeof template == \"string\") {\n        dialog.innerHTML = template;\n      } else {\n        // Assuming it's a detached DOM element.\n        dialog.appendChild(template);\n      }\n      return dialog;\n    }\n    function closeNotification(cm, newVal) {\n      if (cm.state.currentNotificationClose) cm.state.currentNotificationClose();\n      cm.state.currentNotificationClose = newVal;\n    }\n    CodeMirror.defineExtension(\"openDialog\", function (template, callback, options) {\n      if (this.virtualSelectionMode()) return;\n      if (!options) options = {};\n      closeNotification(this, null);\n      var dialog = dialogDiv(this, template, options.bottom);\n      var closed = false,\n        me = this;\n      this.state.dialog = dialog;\n      function close(newVal) {\n        if (typeof newVal == 'string') {\n          inp.value = newVal;\n        } else {\n          if (closed) return;\n          if (newVal && newVal.type == \"blur\") {\n            if (document.activeElement === inp) return;\n          }\n          if (me.state.dialog == dialog) {\n            me.state.dialog = null;\n            me.focus();\n          }\n          closed = true;\n          dialog.remove();\n          if (options.onClose) options.onClose(dialog);\n          var cm = me;\n          if (cm.state.vim) {\n            cm.state.vim.status = null;\n            cm.ace._signal(\"changeStatus\");\n            cm.ace.renderer.$loop.schedule(cm.ace.renderer.CHANGE_CURSOR);\n          }\n        }\n      }\n      var inp = dialog.getElementsByTagName(\"input\")[0],\n        button;\n      if (inp) {\n        if (options.value) {\n          inp.value = options.value;\n          if (options.selectValueOnOpen !== false) inp.select();\n        }\n        if (options.onInput) CodeMirror.on(inp, \"input\", function (e) {\n          options.onInput(e, inp.value, close);\n        });\n        if (options.onKeyUp) CodeMirror.on(inp, \"keyup\", function (e) {\n          options.onKeyUp(e, inp.value, close);\n        });\n        CodeMirror.on(inp, \"keydown\", function (e) {\n          if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) {\n            return;\n          }\n          if (e.keyCode == 13) callback(inp.value);\n          if (e.keyCode == 27 || options.closeOnEnter !== false && e.keyCode == 13) {\n            CodeMirror.e_stop(e);\n            close();\n          }\n        });\n        if (options.closeOnBlur !== false) CodeMirror.on(inp, \"blur\", close);\n        inp.focus();\n      } else if (button = dialog.getElementsByTagName(\"button\")[0]) {\n        CodeMirror.on(button, \"click\", function () {\n          close();\n          me.focus();\n        });\n        if (options.closeOnBlur !== false) CodeMirror.on(button, \"blur\", close);\n        button.focus();\n      }\n      return close;\n    });\n    CodeMirror.defineExtension(\"openNotification\", function (template, options) {\n      if (this.virtualSelectionMode()) return;\n      closeNotification(this, close);\n      var dialog = dialogDiv(this, template, options && options.bottom);\n      var closed = false,\n        doneTimer;\n      var duration = options && typeof options.duration !== \"undefined\" ? options.duration : 5000;\n      function close() {\n        if (closed) return;\n        closed = true;\n        clearTimeout(doneTimer);\n        dialog.remove();\n      }\n      CodeMirror.on(dialog, 'click', function (e) {\n        CodeMirror.e_preventDefault(e);\n        close();\n      });\n      if (duration) doneTimer = setTimeout(close, duration);\n      return close;\n    });\n  })();\n  var Pos = CodeMirror.Pos;\n  function transformCursor(cm, range) {\n    var vim = cm.state.vim;\n    if (!vim || vim.insertMode) return range.head;\n    var head = vim.sel.head;\n    if (!head) return range.head;\n    if (vim.visualBlock) {\n      if (range.head.line != head.line) {\n        return;\n      }\n    }\n    if (range.from() == range.anchor && !range.empty()) {\n      if (range.head.line == head.line && range.head.ch != head.ch) return new Pos(range.head.line, range.head.ch - 1);\n    }\n    return range.head;\n  }\n  function updateSelectionForSurrogateCharacters(cm, curStart, curEnd) {\n    if (curStart.line === curEnd.line && curStart.ch >= curEnd.ch - 1) {\n      var text = cm.getLine(curStart.line);\n      var charCode = text.charCodeAt(curStart.ch);\n      if (0xD800 <= charCode && charCode <= 0xD8FF) {\n        curEnd.ch += 1;\n      }\n    }\n    return {\n      start: curStart,\n      end: curEnd\n    };\n  }\n  var defaultKeymap = [{\n    keys: '<Left>',\n    type: 'keyToKey',\n    toKeys: 'h'\n  }, {\n    keys: '<Right>',\n    type: 'keyToKey',\n    toKeys: 'l'\n  }, {\n    keys: '<Up>',\n    type: 'keyToKey',\n    toKeys: 'k'\n  }, {\n    keys: '<Down>',\n    type: 'keyToKey',\n    toKeys: 'j'\n  }, {\n    keys: 'g<Up>',\n    type: 'keyToKey',\n    toKeys: 'gk'\n  }, {\n    keys: 'g<Down>',\n    type: 'keyToKey',\n    toKeys: 'gj'\n  }, {\n    keys: '<Space>',\n    type: 'keyToKey',\n    toKeys: 'l'\n  }, {\n    keys: '<BS>',\n    type: 'keyToKey',\n    toKeys: 'h',\n    context: 'normal'\n  }, {\n    keys: '<Del>',\n    type: 'keyToKey',\n    toKeys: 'x',\n    context: 'normal'\n  }, {\n    keys: '<C-Space>',\n    type: 'keyToKey',\n    toKeys: 'W'\n  }, {\n    keys: '<C-BS>',\n    type: 'keyToKey',\n    toKeys: 'B',\n    context: 'normal'\n  }, {\n    keys: '<S-Space>',\n    type: 'keyToKey',\n    toKeys: 'w'\n  }, {\n    keys: '<S-BS>',\n    type: 'keyToKey',\n    toKeys: 'b',\n    context: 'normal'\n  }, {\n    keys: '<C-n>',\n    type: 'keyToKey',\n    toKeys: 'j'\n  }, {\n    keys: '<C-p>',\n    type: 'keyToKey',\n    toKeys: 'k'\n  }, {\n    keys: '<C-[>',\n    type: 'keyToKey',\n    toKeys: '<Esc>'\n  }, {\n    keys: '<C-c>',\n    type: 'keyToKey',\n    toKeys: '<Esc>'\n  }, {\n    keys: '<C-[>',\n    type: 'keyToKey',\n    toKeys: '<Esc>',\n    context: 'insert'\n  }, {\n    keys: '<C-c>',\n    type: 'keyToKey',\n    toKeys: '<Esc>',\n    context: 'insert'\n  }, {\n    keys: '<C-Esc>',\n    type: 'keyToKey',\n    toKeys: '<Esc>'\n  }, {\n    keys: '<C-Esc>',\n    type: 'keyToKey',\n    toKeys: '<Esc>',\n    context: 'insert'\n  }, {\n    keys: 's',\n    type: 'keyToKey',\n    toKeys: 'cl',\n    context: 'normal'\n  }, {\n    keys: 's',\n    type: 'keyToKey',\n    toKeys: 'c',\n    context: 'visual'\n  }, {\n    keys: 'S',\n    type: 'keyToKey',\n    toKeys: 'cc',\n    context: 'normal'\n  }, {\n    keys: 'S',\n    type: 'keyToKey',\n    toKeys: 'VdO',\n    context: 'visual'\n  }, {\n    keys: '<Home>',\n    type: 'keyToKey',\n    toKeys: '0'\n  }, {\n    keys: '<End>',\n    type: 'keyToKey',\n    toKeys: '$'\n  }, {\n    keys: '<PageUp>',\n    type: 'keyToKey',\n    toKeys: '<C-b>'\n  }, {\n    keys: '<PageDown>',\n    type: 'keyToKey',\n    toKeys: '<C-f>'\n  }, {\n    keys: '<CR>',\n    type: 'keyToKey',\n    toKeys: 'j^',\n    context: 'normal'\n  }, {\n    keys: '<Ins>',\n    type: 'keyToKey',\n    toKeys: 'i',\n    context: 'normal'\n  }, {\n    keys: '<Ins>',\n    type: 'action',\n    action: 'toggleOverwrite',\n    context: 'insert'\n  }, {\n    keys: 'H',\n    type: 'motion',\n    motion: 'moveToTopLine',\n    motionArgs: {\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'M',\n    type: 'motion',\n    motion: 'moveToMiddleLine',\n    motionArgs: {\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'L',\n    type: 'motion',\n    motion: 'moveToBottomLine',\n    motionArgs: {\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'h',\n    type: 'motion',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 'l',\n    type: 'motion',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: 'j',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: true,\n      linewise: true\n    }\n  }, {\n    keys: 'k',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: false,\n      linewise: true\n    }\n  }, {\n    keys: 'gj',\n    type: 'motion',\n    motion: 'moveByDisplayLines',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: 'gk',\n    type: 'motion',\n    motion: 'moveByDisplayLines',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 'w',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: false\n    }\n  }, {\n    keys: 'W',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: false,\n      bigWord: true\n    }\n  }, {\n    keys: 'e',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'E',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: true,\n      bigWord: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'b',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: false\n    }\n  }, {\n    keys: 'B',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: false,\n      bigWord: true\n    }\n  }, {\n    keys: 'ge',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'gE',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: true,\n      bigWord: true,\n      inclusive: true\n    }\n  }, {\n    keys: '{',\n    type: 'motion',\n    motion: 'moveByParagraph',\n    motionArgs: {\n      forward: false,\n      toJumplist: true\n    }\n  }, {\n    keys: '}',\n    type: 'motion',\n    motion: 'moveByParagraph',\n    motionArgs: {\n      forward: true,\n      toJumplist: true\n    }\n  }, {\n    keys: '(',\n    type: 'motion',\n    motion: 'moveBySentence',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: ')',\n    type: 'motion',\n    motion: 'moveBySentence',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '<C-f>',\n    type: 'motion',\n    motion: 'moveByPage',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '<C-b>',\n    type: 'motion',\n    motion: 'moveByPage',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: '<C-d>',\n    type: 'motion',\n    motion: 'moveByScroll',\n    motionArgs: {\n      forward: true,\n      explicitRepeat: true\n    }\n  }, {\n    keys: '<C-u>',\n    type: 'motion',\n    motion: 'moveByScroll',\n    motionArgs: {\n      forward: false,\n      explicitRepeat: true\n    }\n  }, {\n    keys: 'gg',\n    type: 'motion',\n    motion: 'moveToLineOrEdgeOfDocument',\n    motionArgs: {\n      forward: false,\n      explicitRepeat: true,\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'G',\n    type: 'motion',\n    motion: 'moveToLineOrEdgeOfDocument',\n    motionArgs: {\n      forward: true,\n      explicitRepeat: true,\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: \"g$\",\n    type: \"motion\",\n    motion: \"moveToEndOfDisplayLine\"\n  }, {\n    keys: \"g^\",\n    type: \"motion\",\n    motion: \"moveToStartOfDisplayLine\"\n  }, {\n    keys: \"g0\",\n    type: \"motion\",\n    motion: \"moveToStartOfDisplayLine\"\n  }, {\n    keys: '0',\n    type: 'motion',\n    motion: 'moveToStartOfLine'\n  }, {\n    keys: '^',\n    type: 'motion',\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: '+',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: true,\n      toFirstChar: true\n    }\n  }, {\n    keys: '-',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: false,\n      toFirstChar: true\n    }\n  }, {\n    keys: '_',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: true,\n      toFirstChar: true,\n      repeatOffset: -1\n    }\n  }, {\n    keys: '$',\n    type: 'motion',\n    motion: 'moveToEol',\n    motionArgs: {\n      inclusive: true\n    }\n  }, {\n    keys: '%',\n    type: 'motion',\n    motion: 'moveToMatchedSymbol',\n    motionArgs: {\n      inclusive: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'f<character>',\n    type: 'motion',\n    motion: 'moveToCharacter',\n    motionArgs: {\n      forward: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'F<character>',\n    type: 'motion',\n    motion: 'moveToCharacter',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 't<character>',\n    type: 'motion',\n    motion: 'moveTillCharacter',\n    motionArgs: {\n      forward: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'T<character>',\n    type: 'motion',\n    motion: 'moveTillCharacter',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: ';',\n    type: 'motion',\n    motion: 'repeatLastCharacterSearch',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: ',',\n    type: 'motion',\n    motion: 'repeatLastCharacterSearch',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: '\\'<character>',\n    type: 'motion',\n    motion: 'goToMark',\n    motionArgs: {\n      toJumplist: true,\n      linewise: true\n    }\n  }, {\n    keys: '`<character>',\n    type: 'motion',\n    motion: 'goToMark',\n    motionArgs: {\n      toJumplist: true\n    }\n  }, {\n    keys: ']`',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '[`',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: ']\\'',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: true,\n      linewise: true\n    }\n  }, {\n    keys: '[\\'',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: false,\n      linewise: true\n    }\n  }, {\n    keys: ']p',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: true,\n      isEdit: true,\n      matchIndent: true\n    }\n  }, {\n    keys: '[p',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: false,\n      isEdit: true,\n      matchIndent: true\n    }\n  }, {\n    keys: ']<character>',\n    type: 'motion',\n    motion: 'moveToSymbol',\n    motionArgs: {\n      forward: true,\n      toJumplist: true\n    }\n  }, {\n    keys: '[<character>',\n    type: 'motion',\n    motion: 'moveToSymbol',\n    motionArgs: {\n      forward: false,\n      toJumplist: true\n    }\n  }, {\n    keys: '|',\n    type: 'motion',\n    motion: 'moveToColumn'\n  }, {\n    keys: 'o',\n    type: 'motion',\n    motion: 'moveToOtherHighlightedEnd',\n    context: 'visual'\n  }, {\n    keys: 'O',\n    type: 'motion',\n    motion: 'moveToOtherHighlightedEnd',\n    motionArgs: {\n      sameLine: true\n    },\n    context: 'visual'\n  }, {\n    keys: 'd',\n    type: 'operator',\n    operator: 'delete'\n  }, {\n    keys: 'y',\n    type: 'operator',\n    operator: 'yank'\n  }, {\n    keys: 'c',\n    type: 'operator',\n    operator: 'change'\n  }, {\n    keys: '=',\n    type: 'operator',\n    operator: 'indentAuto'\n  }, {\n    keys: '>',\n    type: 'operator',\n    operator: 'indent',\n    operatorArgs: {\n      indentRight: true\n    }\n  }, {\n    keys: '<',\n    type: 'operator',\n    operator: 'indent',\n    operatorArgs: {\n      indentRight: false\n    }\n  }, {\n    keys: 'g~',\n    type: 'operator',\n    operator: 'changeCase'\n  }, {\n    keys: 'gu',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: true\n    },\n    isEdit: true\n  }, {\n    keys: 'gU',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: false\n    },\n    isEdit: true\n  }, {\n    keys: 'n',\n    type: 'motion',\n    motion: 'findNext',\n    motionArgs: {\n      forward: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'N',\n    type: 'motion',\n    motion: 'findNext',\n    motionArgs: {\n      forward: false,\n      toJumplist: true\n    }\n  }, {\n    keys: 'gn',\n    type: 'motion',\n    motion: 'findAndSelectNextInclusive',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: 'gN',\n    type: 'motion',\n    motion: 'findAndSelectNextInclusive',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 'x',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: true\n    },\n    operatorMotionArgs: {\n      visualLine: false\n    }\n  }, {\n    keys: 'X',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: false\n    },\n    operatorMotionArgs: {\n      visualLine: true\n    }\n  }, {\n    keys: 'D',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveToEol',\n    motionArgs: {\n      inclusive: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'D',\n    type: 'operator',\n    operator: 'delete',\n    operatorArgs: {\n      linewise: true\n    },\n    context: 'visual'\n  }, {\n    keys: 'Y',\n    type: 'operatorMotion',\n    operator: 'yank',\n    motion: 'expandToLine',\n    motionArgs: {\n      linewise: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'Y',\n    type: 'operator',\n    operator: 'yank',\n    operatorArgs: {\n      linewise: true\n    },\n    context: 'visual'\n  }, {\n    keys: 'C',\n    type: 'operatorMotion',\n    operator: 'change',\n    motion: 'moveToEol',\n    motionArgs: {\n      inclusive: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'C',\n    type: 'operator',\n    operator: 'change',\n    operatorArgs: {\n      linewise: true\n    },\n    context: 'visual'\n  }, {\n    keys: '~',\n    type: 'operatorMotion',\n    operator: 'changeCase',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: true\n    },\n    operatorArgs: {\n      shouldMoveCursor: true\n    },\n    context: 'normal'\n  }, {\n    keys: '~',\n    type: 'operator',\n    operator: 'changeCase',\n    context: 'visual'\n  }, {\n    keys: '<C-u>',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveToStartOfLine',\n    context: 'insert'\n  }, {\n    keys: '<C-w>',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: false\n    },\n    context: 'insert'\n  }, {\n    keys: '<C-w>',\n    type: 'idle',\n    context: 'normal'\n  }, {\n    keys: '<C-i>',\n    type: 'action',\n    action: 'jumpListWalk',\n    actionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '<C-o>',\n    type: 'action',\n    action: 'jumpListWalk',\n    actionArgs: {\n      forward: false\n    }\n  }, {\n    keys: '<C-e>',\n    type: 'action',\n    action: 'scroll',\n    actionArgs: {\n      forward: true,\n      linewise: true\n    }\n  }, {\n    keys: '<C-y>',\n    type: 'action',\n    action: 'scroll',\n    actionArgs: {\n      forward: false,\n      linewise: true\n    }\n  }, {\n    keys: 'a',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'charAfter'\n    },\n    context: 'normal'\n  }, {\n    keys: 'A',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'eol'\n    },\n    context: 'normal'\n  }, {\n    keys: 'A',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'endOfSelectedArea'\n    },\n    context: 'visual'\n  }, {\n    keys: 'i',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'inplace'\n    },\n    context: 'normal'\n  }, {\n    keys: 'gi',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'lastEdit'\n    },\n    context: 'normal'\n  }, {\n    keys: 'I',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'firstNonBlank'\n    },\n    context: 'normal'\n  }, {\n    keys: 'gI',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'bol'\n    },\n    context: 'normal'\n  }, {\n    keys: 'I',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'startOfSelectedArea'\n    },\n    context: 'visual'\n  }, {\n    keys: 'o',\n    type: 'action',\n    action: 'newLineAndEnterInsertMode',\n    isEdit: true,\n    interlaceInsertRepeat: true,\n    actionArgs: {\n      after: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'O',\n    type: 'action',\n    action: 'newLineAndEnterInsertMode',\n    isEdit: true,\n    interlaceInsertRepeat: true,\n    actionArgs: {\n      after: false\n    },\n    context: 'normal'\n  }, {\n    keys: 'v',\n    type: 'action',\n    action: 'toggleVisualMode'\n  }, {\n    keys: 'V',\n    type: 'action',\n    action: 'toggleVisualMode',\n    actionArgs: {\n      linewise: true\n    }\n  }, {\n    keys: '<C-v>',\n    type: 'action',\n    action: 'toggleVisualMode',\n    actionArgs: {\n      blockwise: true\n    }\n  }, {\n    keys: '<C-q>',\n    type: 'action',\n    action: 'toggleVisualMode',\n    actionArgs: {\n      blockwise: true\n    }\n  }, {\n    keys: 'gv',\n    type: 'action',\n    action: 'reselectLastSelection'\n  }, {\n    keys: 'J',\n    type: 'action',\n    action: 'joinLines',\n    isEdit: true\n  }, {\n    keys: 'gJ',\n    type: 'action',\n    action: 'joinLines',\n    actionArgs: {\n      keepSpaces: true\n    },\n    isEdit: true\n  }, {\n    keys: 'p',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: true,\n      isEdit: true\n    }\n  }, {\n    keys: 'P',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: false,\n      isEdit: true\n    }\n  }, {\n    keys: 'r<character>',\n    type: 'action',\n    action: 'replace',\n    isEdit: true\n  }, {\n    keys: '@<character>',\n    type: 'action',\n    action: 'replayMacro'\n  }, {\n    keys: 'q<character>',\n    type: 'action',\n    action: 'enterMacroRecordMode'\n  }, {\n    keys: 'R',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      replace: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'R',\n    type: 'operator',\n    operator: 'change',\n    operatorArgs: {\n      linewise: true,\n      fullLine: true\n    },\n    context: 'visual',\n    exitVisualBlock: true\n  }, {\n    keys: 'u',\n    type: 'action',\n    action: 'undo',\n    context: 'normal'\n  }, {\n    keys: 'u',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: true\n    },\n    context: 'visual',\n    isEdit: true\n  }, {\n    keys: 'U',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: false\n    },\n    context: 'visual',\n    isEdit: true\n  }, {\n    keys: '<C-r>',\n    type: 'action',\n    action: 'redo'\n  }, {\n    keys: 'm<character>',\n    type: 'action',\n    action: 'setMark'\n  }, {\n    keys: '\"<character>',\n    type: 'action',\n    action: 'setRegister'\n  }, {\n    keys: 'zz',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'center'\n    }\n  }, {\n    keys: 'z.',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'center'\n    },\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: 'zt',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'top'\n    }\n  }, {\n    keys: 'z<CR>',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'top'\n    },\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: 'zb',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'bottom'\n    }\n  }, {\n    keys: 'z-',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'bottom'\n    },\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: '.',\n    type: 'action',\n    action: 'repeatLastEdit'\n  }, {\n    keys: '<C-a>',\n    type: 'action',\n    action: 'incrementNumberToken',\n    isEdit: true,\n    actionArgs: {\n      increase: true,\n      backtrack: false\n    }\n  }, {\n    keys: '<C-x>',\n    type: 'action',\n    action: 'incrementNumberToken',\n    isEdit: true,\n    actionArgs: {\n      increase: false,\n      backtrack: false\n    }\n  }, {\n    keys: '<C-t>',\n    type: 'action',\n    action: 'indent',\n    actionArgs: {\n      indentRight: true\n    },\n    context: 'insert'\n  }, {\n    keys: '<C-d>',\n    type: 'action',\n    action: 'indent',\n    actionArgs: {\n      indentRight: false\n    },\n    context: 'insert'\n  }, {\n    keys: 'a<character>',\n    type: 'motion',\n    motion: 'textObjectManipulation'\n  }, {\n    keys: 'i<character>',\n    type: 'motion',\n    motion: 'textObjectManipulation',\n    motionArgs: {\n      textObjectInner: true\n    }\n  }, {\n    keys: '/',\n    type: 'search',\n    searchArgs: {\n      forward: true,\n      querySrc: 'prompt',\n      toJumplist: true\n    }\n  }, {\n    keys: '?',\n    type: 'search',\n    searchArgs: {\n      forward: false,\n      querySrc: 'prompt',\n      toJumplist: true\n    }\n  }, {\n    keys: '*',\n    type: 'search',\n    searchArgs: {\n      forward: true,\n      querySrc: 'wordUnderCursor',\n      wholeWordOnly: true,\n      toJumplist: true\n    }\n  }, {\n    keys: '#',\n    type: 'search',\n    searchArgs: {\n      forward: false,\n      querySrc: 'wordUnderCursor',\n      wholeWordOnly: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'g*',\n    type: 'search',\n    searchArgs: {\n      forward: true,\n      querySrc: 'wordUnderCursor',\n      toJumplist: true\n    }\n  }, {\n    keys: 'g#',\n    type: 'search',\n    searchArgs: {\n      forward: false,\n      querySrc: 'wordUnderCursor',\n      toJumplist: true\n    }\n  }, {\n    keys: ':',\n    type: 'ex'\n  }];\n  var defaultKeymapLength = defaultKeymap.length;\n  var defaultExCommandMap = [{\n    name: 'colorscheme',\n    shortName: 'colo'\n  }, {\n    name: 'map'\n  }, {\n    name: 'imap',\n    shortName: 'im'\n  }, {\n    name: 'nmap',\n    shortName: 'nm'\n  }, {\n    name: 'vmap',\n    shortName: 'vm'\n  }, {\n    name: 'unmap'\n  }, {\n    name: 'write',\n    shortName: 'w'\n  }, {\n    name: 'undo',\n    shortName: 'u'\n  }, {\n    name: 'redo',\n    shortName: 'red'\n  }, {\n    name: 'set',\n    shortName: 'se'\n  }, {\n    name: 'setlocal',\n    shortName: 'setl'\n  }, {\n    name: 'setglobal',\n    shortName: 'setg'\n  }, {\n    name: 'sort',\n    shortName: 'sor'\n  }, {\n    name: 'substitute',\n    shortName: 's',\n    possiblyAsync: true\n  }, {\n    name: 'nohlsearch',\n    shortName: 'noh'\n  }, {\n    name: 'yank',\n    shortName: 'y'\n  }, {\n    name: 'delmarks',\n    shortName: 'delm'\n  }, {\n    name: 'registers',\n    shortName: 'reg',\n    excludeFromCommandHistory: true\n  }, {\n    name: 'vglobal',\n    shortName: 'v'\n  }, {\n    name: 'global',\n    shortName: 'g'\n  }];\n  function enterVimMode(cm) {\n    cm.setOption('disableInput', true);\n    cm.setOption('showCursorWhenSelecting', false);\n    CodeMirror.signal(cm, \"vim-mode-change\", {\n      mode: \"normal\"\n    });\n    cm.on('cursorActivity', onCursorActivity);\n    maybeInitVimState(cm);\n    CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n  }\n  function leaveVimMode(cm) {\n    cm.setOption('disableInput', false);\n    cm.off('cursorActivity', onCursorActivity);\n    CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    cm.state.vim = null;\n    if (highlightTimeout) clearTimeout(highlightTimeout);\n  }\n  function detachVimMap(cm, next) {\n    if (this == CodeMirror.keyMap.vim) {\n      cm.options.$customCursor = null;\n      CodeMirror.rmClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n    }\n    if (!next || next.attach != attachVimMap) leaveVimMode(cm);\n  }\n  function attachVimMap(cm, prev) {\n    if (this == CodeMirror.keyMap.vim) {\n      if (cm.curOp) cm.curOp.selectionChanged = true;\n      cm.options.$customCursor = transformCursor;\n      CodeMirror.addClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n    }\n    if (!prev || prev.attach != attachVimMap) enterVimMode(cm);\n  }\n  CodeMirror.defineOption('vimMode', false, function (cm, val, prev) {\n    if (val && cm.getOption(\"keyMap\") != \"vim\") cm.setOption(\"keyMap\", \"vim\");else if (!val && prev != CodeMirror.Init && /^vim/.test(cm.getOption(\"keyMap\"))) cm.setOption(\"keyMap\", \"default\");\n  });\n  function cmKey(key, cm) {\n    if (!cm) {\n      return undefined;\n    }\n    if (this[key]) {\n      return this[key];\n    }\n    var vimKey = cmKeyToVimKey(key);\n    if (!vimKey) {\n      return false;\n    }\n    var cmd = vimApi.findKey(cm, vimKey);\n    if (typeof cmd == 'function') {\n      CodeMirror.signal(cm, 'vim-keypress', vimKey);\n    }\n    return cmd;\n  }\n  var modifiers = {\n    Shift: 'S',\n    Ctrl: 'C',\n    Alt: 'A',\n    Cmd: 'D',\n    Mod: 'A',\n    CapsLock: ''\n  };\n  var specialKeys = {\n    Enter: 'CR',\n    Backspace: 'BS',\n    Delete: 'Del',\n    Insert: 'Ins'\n  };\n  function cmKeyToVimKey(key) {\n    if (key.charAt(0) == '\\'') {\n      return key.charAt(1);\n    }\n    var pieces = key.split(/-(?!$)/);\n    var lastPiece = pieces[pieces.length - 1];\n    if (pieces.length == 1 && pieces[0].length == 1) {\n      return false;\n    } else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {\n      return false;\n    }\n    var hasCharacter = false;\n    for (var i = 0; i < pieces.length; i++) {\n      var piece = pieces[i];\n      if (piece in modifiers) {\n        pieces[i] = modifiers[piece];\n      } else {\n        hasCharacter = true;\n      }\n      if (piece in specialKeys) {\n        pieces[i] = specialKeys[piece];\n      }\n    }\n    if (!hasCharacter) {\n      return false;\n    }\n    if (isUpperCase(lastPiece)) {\n      pieces[pieces.length - 1] = lastPiece.toLowerCase();\n    }\n    return '<' + pieces.join('-') + '>';\n  }\n  function getOnPasteFn(cm) {\n    var vim = cm.state.vim;\n    if (!vim.onPasteFn) {\n      vim.onPasteFn = function () {\n        if (!vim.insertMode) {\n          cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n          actions.enterInsertMode(cm, {}, vim);\n        }\n      };\n    }\n    return vim.onPasteFn;\n  }\n  var numberRegex = /[\\d]/;\n  var wordCharTest = [CodeMirror.isWordChar, function (ch) {\n      return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n    }],\n    bigWordCharTest = [function (ch) {\n      return /\\S/.test(ch);\n    }];\n  function makeKeyRange(start, size) {\n    var keys = [];\n    for (var i = start; i < start + size; i++) {\n      keys.push(String.fromCharCode(i));\n    }\n    return keys;\n  }\n  var upperCaseAlphabet = makeKeyRange(65, 26);\n  var lowerCaseAlphabet = makeKeyRange(97, 26);\n  var numbers = makeKeyRange(48, 10);\n  var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);\n  var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '\"', '.', ':', '_', '/', '+']);\n  var upperCaseChars;\n  try {\n    upperCaseChars = new RegExp(\"^[\\\\p{Lu}]$\", \"u\");\n  } catch (_) {\n    upperCaseChars = /^[A-Z]$/;\n  }\n  function isLine(cm, line) {\n    return line >= cm.firstLine() && line <= cm.lastLine();\n  }\n  function isLowerCase(k) {\n    return /^[a-z]$/.test(k);\n  }\n  function isMatchableSymbol(k) {\n    return '()[]{}'.indexOf(k) != -1;\n  }\n  function isNumber(k) {\n    return numberRegex.test(k);\n  }\n  function isUpperCase(k) {\n    return upperCaseChars.test(k);\n  }\n  function isWhiteSpaceString(k) {\n    return /^\\s*$/.test(k);\n  }\n  function isEndOfSentenceSymbol(k) {\n    return '.?!'.indexOf(k) != -1;\n  }\n  function inArray(val, arr) {\n    for (var i = 0; i < arr.length; i++) {\n      if (arr[i] == val) {\n        return true;\n      }\n    }\n    return false;\n  }\n  var options = {};\n  function defineOption(name, defaultValue, type, aliases, callback) {\n    if (defaultValue === undefined && !callback) {\n      throw Error('defaultValue is required unless callback is provided');\n    }\n    if (!type) {\n      type = 'string';\n    }\n    options[name] = {\n      type: type,\n      defaultValue: defaultValue,\n      callback: callback\n    };\n    if (aliases) {\n      for (var i = 0; i < aliases.length; i++) {\n        options[aliases[i]] = options[name];\n      }\n    }\n    if (defaultValue) {\n      setOption(name, defaultValue);\n    }\n  }\n  function setOption(name, value, cm, cfg) {\n    var option = options[name];\n    cfg = cfg || {};\n    var scope = cfg.scope;\n    if (!option) {\n      return new Error('Unknown option: ' + name);\n    }\n    if (option.type == 'boolean') {\n      if (value && value !== true) {\n        return new Error('Invalid argument: ' + name + '=' + value);\n      } else if (value !== false) {\n        value = true;\n      }\n    }\n    if (option.callback) {\n      if (scope !== 'local') {\n        option.callback(value, undefined);\n      }\n      if (scope !== 'global' && cm) {\n        option.callback(value, cm);\n      }\n    } else {\n      if (scope !== 'local') {\n        option.value = option.type == 'boolean' ? !!value : value;\n      }\n      if (scope !== 'global' && cm) {\n        cm.state.vim.options[name] = {\n          value: value\n        };\n      }\n    }\n  }\n  function getOption(name, cm, cfg) {\n    var option = options[name];\n    cfg = cfg || {};\n    var scope = cfg.scope;\n    if (!option) {\n      return new Error('Unknown option: ' + name);\n    }\n    if (option.callback) {\n      var local = cm && option.callback(undefined, cm);\n      if (scope !== 'global' && local !== undefined) {\n        return local;\n      }\n      if (scope !== 'local') {\n        return option.callback();\n      }\n      return;\n    } else {\n      var local = scope !== 'global' && cm && cm.state.vim.options[name];\n      return (local || scope !== 'local' && option || {}).value;\n    }\n  }\n  defineOption('filetype', undefined, 'string', ['ft'], function (name, cm) {\n    if (cm === undefined) {\n      return;\n    }\n    if (name === undefined) {\n      var mode = cm.getOption('mode');\n      return mode == 'null' ? '' : mode;\n    } else {\n      var mode = name == '' ? 'null' : name;\n      cm.setOption('mode', mode);\n    }\n  });\n  var createCircularJumpList = function () {\n    var size = 100;\n    var pointer = -1;\n    var head = 0;\n    var tail = 0;\n    var buffer = new Array(size);\n    function add(cm, oldCur, newCur) {\n      var current = pointer % size;\n      var curMark = buffer[current];\n      function useNextSlot(cursor) {\n        var next = ++pointer % size;\n        var trashMark = buffer[next];\n        if (trashMark) {\n          trashMark.clear();\n        }\n        buffer[next] = cm.setBookmark(cursor);\n      }\n      if (curMark) {\n        var markPos = curMark.find();\n        if (markPos && !cursorEqual(markPos, oldCur)) {\n          useNextSlot(oldCur);\n        }\n      } else {\n        useNextSlot(oldCur);\n      }\n      useNextSlot(newCur);\n      head = pointer;\n      tail = pointer - size + 1;\n      if (tail < 0) {\n        tail = 0;\n      }\n    }\n    function move(cm, offset) {\n      pointer += offset;\n      if (pointer > head) {\n        pointer = head;\n      } else if (pointer < tail) {\n        pointer = tail;\n      }\n      var mark = buffer[(size + pointer) % size];\n      if (mark && !mark.find()) {\n        var inc = offset > 0 ? 1 : -1;\n        var newCur;\n        var oldCur = cm.getCursor();\n        do {\n          pointer += inc;\n          mark = buffer[(size + pointer) % size];\n          if (mark && (newCur = mark.find()) && !cursorEqual(oldCur, newCur)) {\n            break;\n          }\n        } while (pointer < head && pointer > tail);\n      }\n      return mark;\n    }\n    function find(cm, offset) {\n      var oldPointer = pointer;\n      var mark = move(cm, offset);\n      pointer = oldPointer;\n      return mark && mark.find();\n    }\n    return {\n      cachedCursor: undefined,\n      add: add,\n      find: find,\n      move: move\n    };\n  };\n  var createInsertModeChanges = function (c) {\n    if (c) {\n      return {\n        changes: c.changes,\n        expectCursorActivityForChange: c.expectCursorActivityForChange\n      };\n    }\n    return {\n      changes: [],\n      expectCursorActivityForChange: false\n    };\n  };\n  function MacroModeState() {\n    this.latestRegister = undefined;\n    this.isPlaying = false;\n    this.isRecording = false;\n    this.replaySearchQueries = [];\n    this.onRecordingDone = undefined;\n    this.lastInsertModeChanges = createInsertModeChanges();\n  }\n  MacroModeState.prototype = {\n    exitMacroRecordMode: function () {\n      var macroModeState = vimGlobalState.macroModeState;\n      if (macroModeState.onRecordingDone) {\n        macroModeState.onRecordingDone(); // close dialog\n      }\n\n      macroModeState.onRecordingDone = undefined;\n      macroModeState.isRecording = false;\n    },\n    enterMacroRecordMode: function (cm, registerName) {\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register) {\n        register.clear();\n        this.latestRegister = registerName;\n        if (cm.openDialog) {\n          var template = dom('span', {\n            class: 'cm-vim-message'\n          }, 'recording @' + registerName);\n          this.onRecordingDone = cm.openDialog(template, null, {\n            bottom: true\n          });\n        }\n        this.isRecording = true;\n      }\n    }\n  };\n  function maybeInitVimState(cm) {\n    if (!cm.state.vim) {\n      cm.state.vim = {\n        inputState: new InputState(),\n        lastEditInputState: undefined,\n        lastEditActionCommand: undefined,\n        lastHPos: -1,\n        lastHSPos: -1,\n        lastMotion: null,\n        marks: {},\n        insertMode: false,\n        insertModeRepeat: undefined,\n        visualMode: false,\n        visualLine: false,\n        visualBlock: false,\n        lastSelection: null,\n        lastPastedText: null,\n        sel: {},\n        options: {}\n      };\n    }\n    return cm.state.vim;\n  }\n  var vimGlobalState;\n  function resetVimGlobalState() {\n    vimGlobalState = {\n      searchQuery: null,\n      searchIsReversed: false,\n      lastSubstituteReplacePart: undefined,\n      jumpList: createCircularJumpList(),\n      macroModeState: new MacroModeState(),\n      lastCharacterSearch: {\n        increment: 0,\n        forward: true,\n        selectedCharacter: ''\n      },\n      registerController: new RegisterController({}),\n      searchHistoryController: new HistoryController(),\n      exCommandHistoryController: new HistoryController()\n    };\n    for (var optionName in options) {\n      var option = options[optionName];\n      option.value = option.defaultValue;\n    }\n  }\n  var lastInsertModeKeyTimer;\n  var vimApi = {\n    enterVimMode: enterVimMode,\n    leaveVimMode: leaveVimMode,\n    buildKeyMap: function () {},\n    getRegisterController: function () {\n      return vimGlobalState.registerController;\n    },\n    resetVimGlobalState_: resetVimGlobalState,\n    getVimGlobalState_: function () {\n      return vimGlobalState;\n    },\n    maybeInitVimState_: maybeInitVimState,\n    suppressErrorLogging: false,\n    InsertModeKey: InsertModeKey,\n    map: function (lhs, rhs, ctx) {\n      exCommandDispatcher.map(lhs, rhs, ctx);\n    },\n    unmap: function (lhs, ctx) {\n      return exCommandDispatcher.unmap(lhs, ctx);\n    },\n    noremap: function (lhs, rhs, ctx) {\n      function toCtxArray(ctx) {\n        return ctx ? [ctx] : ['normal', 'insert', 'visual'];\n      }\n      var ctxsToMap = toCtxArray(ctx);\n      var actualLength = defaultKeymap.length,\n        origLength = defaultKeymapLength;\n      for (var i = actualLength - origLength; i < actualLength && ctxsToMap.length; i++) {\n        var mapping = defaultKeymap[i];\n        if (mapping.keys == rhs && (!ctx || !mapping.context || mapping.context === ctx) && mapping.type.substr(0, 2) !== 'ex' && mapping.type.substr(0, 3) !== 'key') {\n          var newMapping = {};\n          for (var key in mapping) {\n            newMapping[key] = mapping[key];\n          }\n          newMapping.keys = lhs;\n          if (ctx && !newMapping.context) {\n            newMapping.context = ctx;\n          }\n          this._mapCommand(newMapping);\n          var mappedCtxs = toCtxArray(mapping.context);\n          ctxsToMap = ctxsToMap.filter(function (el) {\n            return mappedCtxs.indexOf(el) === -1;\n          });\n        }\n      }\n    },\n    mapclear: function (ctx) {\n      var actualLength = defaultKeymap.length,\n        origLength = defaultKeymapLength;\n      var userKeymap = defaultKeymap.slice(0, actualLength - origLength);\n      defaultKeymap = defaultKeymap.slice(actualLength - origLength);\n      if (ctx) {\n        for (var i = userKeymap.length - 1; i >= 0; i--) {\n          var mapping = userKeymap[i];\n          if (ctx !== mapping.context) {\n            if (mapping.context) {\n              this._mapCommand(mapping);\n            } else {\n              var contexts = ['normal', 'insert', 'visual'];\n              for (var j in contexts) {\n                if (contexts[j] !== ctx) {\n                  var newMapping = {};\n                  for (var key in mapping) {\n                    newMapping[key] = mapping[key];\n                  }\n                  newMapping.context = contexts[j];\n                  this._mapCommand(newMapping);\n                }\n              }\n            }\n          }\n        }\n      }\n    },\n    setOption: setOption,\n    getOption: getOption,\n    defineOption: defineOption,\n    defineEx: function (name, prefix, func) {\n      if (!prefix) {\n        prefix = name;\n      } else if (name.indexOf(prefix) !== 0) {\n        throw new Error('(Vim.defineEx) \"' + prefix + '\" is not a prefix of \"' + name + '\", command not registered');\n      }\n      exCommands[name] = func;\n      exCommandDispatcher.commandMap_[prefix] = {\n        name: name,\n        shortName: prefix,\n        type: 'api'\n      };\n    },\n    handleKey: function (cm, key, origin) {\n      var command = this.findKey(cm, key, origin);\n      if (typeof command === 'function') {\n        return command();\n      }\n    },\n    multiSelectHandleKey: multiSelectHandleKey,\n    findKey: function (cm, key, origin) {\n      var vim = maybeInitVimState(cm);\n      function handleMacroRecording() {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isRecording) {\n          if (key == 'q') {\n            macroModeState.exitMacroRecordMode();\n            clearInputState(cm);\n            return true;\n          }\n          if (origin != 'mapping') {\n            logKey(macroModeState, key);\n          }\n        }\n      }\n      function handleEsc() {\n        if (key == '<Esc>') {\n          if (vim.visualMode) {\n            exitVisualMode(cm);\n          } else if (vim.insertMode) {\n            exitInsertMode(cm);\n          } else {\n            return;\n          }\n          clearInputState(cm);\n          return true;\n        }\n      }\n      function doKeyToKey(keys) {\n        var match;\n        while (keys) {\n          match = /<\\w+-.+?>|<\\w+>|./.exec(keys);\n          key = match[0];\n          keys = keys.substring(match.index + key.length);\n          vimApi.handleKey(cm, key, 'mapping');\n        }\n      }\n      function handleKeyInsertMode() {\n        if (handleEsc()) {\n          return true;\n        }\n        var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n        var keysAreChars = key.length == 1;\n        var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n        while (keys.length > 1 && match.type != 'full') {\n          var keys = vim.inputState.keyBuffer = keys.slice(1);\n          var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n          if (thisMatch.type != 'none') {\n            match = thisMatch;\n          }\n        }\n        if (match.type == 'none') {\n          clearInputState(cm);\n          return false;\n        } else if (match.type == 'partial') {\n          if (lastInsertModeKeyTimer) {\n            window.clearTimeout(lastInsertModeKeyTimer);\n          }\n          lastInsertModeKeyTimer = window.setTimeout(function () {\n            if (vim.insertMode && vim.inputState.keyBuffer) {\n              clearInputState(cm);\n            }\n          }, getOption('insertModeEscKeysTimeout'));\n          return !keysAreChars;\n        }\n        if (lastInsertModeKeyTimer) {\n          window.clearTimeout(lastInsertModeKeyTimer);\n        }\n        if (keysAreChars) {\n          var selections = cm.listSelections();\n          for (var i = 0; i < selections.length; i++) {\n            var here = selections[i].head;\n            cm.replaceRange('', offsetCursor(here, 0, -(keys.length - 1)), here, '+input');\n          }\n          vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n        }\n        clearInputState(cm);\n        return match.command;\n      }\n      function handleKeyNonInsertMode() {\n        if (handleMacroRecording() || handleEsc()) {\n          return true;\n        }\n        var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n        if (/^[1-9]\\d*$/.test(keys)) {\n          return true;\n        }\n        var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n        if (!keysMatcher) {\n          clearInputState(cm);\n          return false;\n        }\n        var context = vim.visualMode ? 'visual' : 'normal';\n        var mainKey = keysMatcher[2] || keysMatcher[1];\n        if (vim.inputState.operatorShortcut && vim.inputState.operatorShortcut.slice(-1) == mainKey) {\n          mainKey = vim.inputState.operatorShortcut;\n        }\n        var match = commandDispatcher.matchCommand(mainKey, defaultKeymap, vim.inputState, context);\n        if (match.type == 'none') {\n          clearInputState(cm);\n          return false;\n        } else if (match.type == 'partial') {\n          return true;\n        } else if (match.type == 'clear') {\n          clearInputState(cm);\n          return true;\n        }\n        vim.inputState.keyBuffer = '';\n        keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n        if (keysMatcher[1] && keysMatcher[1] != '0') {\n          vim.inputState.pushRepeatDigit(keysMatcher[1]);\n        }\n        return match.command;\n      }\n      var command;\n      if (vim.insertMode) {\n        command = handleKeyInsertMode();\n      } else {\n        command = handleKeyNonInsertMode();\n      }\n      if (command === false) {\n        return undefined; //ace_patch\n      } else if (command === true) {\n        return function () {\n          return true;\n        };\n      } else {\n        return function () {\n          if ((command.operator || command.isEdit) && cm.getOption('readOnly')) return; // ace_patch\n          return cm.operation(function () {\n            cm.curOp.isVimOp = true;\n            try {\n              if (command.type == 'keyToKey') {\n                doKeyToKey(command.toKeys);\n              } else {\n                commandDispatcher.processCommand(cm, vim, command);\n              }\n            } catch (e) {\n              cm.state.vim = undefined;\n              maybeInitVimState(cm);\n              if (!vimApi.suppressErrorLogging) {\n                console['log'](e);\n              }\n              throw e;\n            }\n            return true;\n          });\n        };\n      }\n    },\n    handleEx: function (cm, input) {\n      exCommandDispatcher.processCommand(cm, input);\n    },\n    defineMotion: defineMotion,\n    defineAction: defineAction,\n    defineOperator: defineOperator,\n    mapCommand: mapCommand,\n    _mapCommand: _mapCommand,\n    defineRegister: defineRegister,\n    exitVisualMode: exitVisualMode,\n    exitInsertMode: exitInsertMode\n  };\n  function InputState() {\n    this.prefixRepeat = [];\n    this.motionRepeat = [];\n    this.operator = null;\n    this.operatorArgs = null;\n    this.motion = null;\n    this.motionArgs = null;\n    this.keyBuffer = []; // For matching multi-key commands.\n    this.registerName = null; // Defaults to the unnamed register.\n  }\n\n  InputState.prototype.pushRepeatDigit = function (n) {\n    if (!this.operator) {\n      this.prefixRepeat = this.prefixRepeat.concat(n);\n    } else {\n      this.motionRepeat = this.motionRepeat.concat(n);\n    }\n  };\n  InputState.prototype.getRepeat = function () {\n    var repeat = 0;\n    if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n      repeat = 1;\n      if (this.prefixRepeat.length > 0) {\n        repeat *= parseInt(this.prefixRepeat.join(''), 10);\n      }\n      if (this.motionRepeat.length > 0) {\n        repeat *= parseInt(this.motionRepeat.join(''), 10);\n      }\n    }\n    return repeat;\n  };\n  function clearInputState(cm, reason) {\n    cm.state.vim.inputState = new InputState();\n    CodeMirror.signal(cm, 'vim-command-done', reason);\n  }\n  function Register(text, linewise, blockwise) {\n    this.clear();\n    this.keyBuffer = [text || ''];\n    this.insertModeChanges = [];\n    this.searchQueries = [];\n    this.linewise = !!linewise;\n    this.blockwise = !!blockwise;\n  }\n  Register.prototype = {\n    setText: function (text, linewise, blockwise) {\n      this.keyBuffer = [text || ''];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    },\n    pushText: function (text, linewise) {\n      if (linewise) {\n        if (!this.linewise) {\n          this.keyBuffer.push('\\n');\n        }\n        this.linewise = true;\n      }\n      this.keyBuffer.push(text);\n    },\n    pushInsertModeChanges: function (changes) {\n      this.insertModeChanges.push(createInsertModeChanges(changes));\n    },\n    pushSearchQuery: function (query) {\n      this.searchQueries.push(query);\n    },\n    clear: function () {\n      this.keyBuffer = [];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = false;\n    },\n    toString: function () {\n      return this.keyBuffer.join('');\n    }\n  };\n  function defineRegister(name, register) {\n    var registers = vimGlobalState.registerController.registers;\n    if (!name || name.length != 1) {\n      throw Error('Register name must be 1 character');\n    }\n    registers[name] = register;\n    validRegisters.push(name);\n  }\n  function RegisterController(registers) {\n    this.registers = registers;\n    this.unnamedRegister = registers['\"'] = new Register();\n    registers['.'] = new Register();\n    registers[':'] = new Register();\n    registers['/'] = new Register();\n    registers['+'] = new Register();\n  }\n  RegisterController.prototype = {\n    pushText: function (registerName, operator, text, linewise, blockwise) {\n      if (registerName === '_') return;\n      if (linewise && text.charAt(text.length - 1) !== '\\n') {\n        text += '\\n';\n      }\n      var register = this.isValidRegister(registerName) ? this.getRegister(registerName) : null;\n      if (!register) {\n        switch (operator) {\n          case 'yank':\n            this.registers['0'] = new Register(text, linewise, blockwise);\n            break;\n          case 'delete':\n          case 'change':\n            if (text.indexOf('\\n') == -1) {\n              this.registers['-'] = new Register(text, linewise);\n            } else {\n              this.shiftNumericRegisters_();\n              this.registers['1'] = new Register(text, linewise);\n            }\n            break;\n        }\n        this.unnamedRegister.setText(text, linewise, blockwise);\n        return;\n      }\n      var append = isUpperCase(registerName);\n      if (append) {\n        register.pushText(text, linewise);\n      } else {\n        register.setText(text, linewise, blockwise);\n      }\n      if (registerName === '+') {\n        navigator.clipboard.writeText(text);\n      }\n      this.unnamedRegister.setText(register.toString(), linewise);\n    },\n    getRegister: function (name) {\n      if (!this.isValidRegister(name)) {\n        return this.unnamedRegister;\n      }\n      name = name.toLowerCase();\n      if (!this.registers[name]) {\n        this.registers[name] = new Register();\n      }\n      return this.registers[name];\n    },\n    isValidRegister: function (name) {\n      return name && inArray(name, validRegisters);\n    },\n    shiftNumericRegisters_: function () {\n      for (var i = 9; i >= 2; i--) {\n        this.registers[i] = this.getRegister('' + (i - 1));\n      }\n    }\n  };\n  function HistoryController() {\n    this.historyBuffer = [];\n    this.iterator = 0;\n    this.initialPrefix = null;\n  }\n  HistoryController.prototype = {\n    nextMatch: function (input, up) {\n      var historyBuffer = this.historyBuffer;\n      var dir = up ? -1 : 1;\n      if (this.initialPrefix === null) this.initialPrefix = input;\n      for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i += dir) {\n        var element = historyBuffer[i];\n        for (var j = 0; j <= element.length; j++) {\n          if (this.initialPrefix == element.substring(0, j)) {\n            this.iterator = i;\n            return element;\n          }\n        }\n      }\n      if (i >= historyBuffer.length) {\n        this.iterator = historyBuffer.length;\n        return this.initialPrefix;\n      }\n      if (i < 0) return input;\n    },\n    pushInput: function (input) {\n      var index = this.historyBuffer.indexOf(input);\n      if (index > -1) this.historyBuffer.splice(index, 1);\n      if (input.length) this.historyBuffer.push(input);\n    },\n    reset: function () {\n      this.initialPrefix = null;\n      this.iterator = this.historyBuffer.length;\n    }\n  };\n  var commandDispatcher = {\n    matchCommand: function (keys, keyMap, inputState, context) {\n      var matches = commandMatches(keys, keyMap, context, inputState);\n      if (!matches.full && !matches.partial) {\n        return {\n          type: 'none'\n        };\n      } else if (!matches.full && matches.partial) {\n        return {\n          type: 'partial'\n        };\n      }\n      var bestMatch;\n      for (var i = 0; i < matches.full.length; i++) {\n        var match = matches.full[i];\n        if (!bestMatch) {\n          bestMatch = match;\n        }\n      }\n      if (bestMatch.keys.slice(-11) == '<character>') {\n        var character = lastChar(keys);\n        if (!character || character.length > 1) return {\n          type: 'clear'\n        };\n        inputState.selectedCharacter = character;\n      }\n      return {\n        type: 'full',\n        command: bestMatch\n      };\n    },\n    processCommand: function (cm, vim, command) {\n      vim.inputState.repeatOverride = command.repeatOverride;\n      switch (command.type) {\n        case 'motion':\n          this.processMotion(cm, vim, command);\n          break;\n        case 'operator':\n          this.processOperator(cm, vim, command);\n          break;\n        case 'operatorMotion':\n          this.processOperatorMotion(cm, vim, command);\n          break;\n        case 'action':\n          this.processAction(cm, vim, command);\n          break;\n        case 'search':\n          this.processSearch(cm, vim, command);\n          break;\n        case 'ex':\n        case 'keyToEx':\n          this.processEx(cm, vim, command);\n          break;\n        default:\n          break;\n      }\n    },\n    processMotion: function (cm, vim, command) {\n      vim.inputState.motion = command.motion;\n      vim.inputState.motionArgs = copyArgs(command.motionArgs);\n      this.evalInput(cm, vim);\n    },\n    processOperator: function (cm, vim, command) {\n      var inputState = vim.inputState;\n      if (inputState.operator) {\n        if (inputState.operator == command.operator) {\n          inputState.motion = 'expandToLine';\n          inputState.motionArgs = {\n            linewise: true\n          };\n          this.evalInput(cm, vim);\n          return;\n        } else {\n          clearInputState(cm);\n        }\n      }\n      inputState.operator = command.operator;\n      inputState.operatorArgs = copyArgs(command.operatorArgs);\n      if (command.keys.length > 1) {\n        inputState.operatorShortcut = command.keys;\n      }\n      if (command.exitVisualBlock) {\n        vim.visualBlock = false;\n        updateCmSelection(cm);\n      }\n      if (vim.visualMode) {\n        this.evalInput(cm, vim);\n      }\n    },\n    processOperatorMotion: function (cm, vim, command) {\n      var visualMode = vim.visualMode;\n      var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n      if (operatorMotionArgs) {\n        if (visualMode && operatorMotionArgs.visualLine) {\n          vim.visualLine = true;\n        }\n      }\n      this.processOperator(cm, vim, command);\n      if (!visualMode) {\n        this.processMotion(cm, vim, command);\n      }\n    },\n    processAction: function (cm, vim, command) {\n      var inputState = vim.inputState;\n      var repeat = inputState.getRepeat();\n      var repeatIsExplicit = !!repeat;\n      var actionArgs = copyArgs(command.actionArgs) || {};\n      if (inputState.selectedCharacter) {\n        actionArgs.selectedCharacter = inputState.selectedCharacter;\n      }\n      if (command.operator) {\n        this.processOperator(cm, vim, command);\n      }\n      if (command.motion) {\n        this.processMotion(cm, vim, command);\n      }\n      if (command.motion || command.operator) {\n        this.evalInput(cm, vim);\n      }\n      actionArgs.repeat = repeat || 1;\n      actionArgs.repeatIsExplicit = repeatIsExplicit;\n      actionArgs.registerName = inputState.registerName;\n      clearInputState(cm);\n      vim.lastMotion = null;\n      if (command.isEdit) {\n        this.recordLastEdit(vim, inputState, command);\n      }\n      actions[command.action](cm, actionArgs, vim);\n    },\n    processSearch: function (cm, vim, command) {\n      if (!cm.getSearchCursor) {\n        return;\n      }\n      var forward = command.searchArgs.forward;\n      var wholeWordOnly = command.searchArgs.wholeWordOnly;\n      getSearchState(cm).setReversed(!forward);\n      var promptPrefix = forward ? '/' : '?';\n      var originalQuery = getSearchState(cm).getQuery();\n      var originalScrollPos = cm.getScrollInfo();\n      function handleQuery(query, ignoreCase, smartCase) {\n        vimGlobalState.searchHistoryController.pushInput(query);\n        vimGlobalState.searchHistoryController.reset();\n        try {\n          updateSearchQuery(cm, query, ignoreCase, smartCase);\n        } catch (e) {\n          showConfirm(cm, 'Invalid regex: ' + query);\n          clearInputState(cm);\n          return;\n        }\n        commandDispatcher.processMotion(cm, vim, {\n          type: 'motion',\n          motion: 'findNext',\n          motionArgs: {\n            forward: true,\n            toJumplist: command.searchArgs.toJumplist\n          }\n        });\n      }\n      function onPromptClose(query) {\n        handleQuery(query, true /** ignoreCase */, true /** smartCase */);\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isRecording) {\n          logSearchQuery(macroModeState, query);\n        }\n      }\n      function onPromptKeyUp(e, query, close) {\n        var keyName = CodeMirror.keyName(e),\n          up,\n          offset;\n        if (keyName == 'Up' || keyName == 'Down') {\n          up = keyName == 'Up' ? true : false;\n          offset = e.target ? e.target.selectionEnd : 0;\n          query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n          close(query);\n          if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n        } else {\n          if (keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift') vimGlobalState.searchHistoryController.reset();\n        }\n        var parsedQuery;\n        try {\n          parsedQuery = updateSearchQuery(cm, query, true /** ignoreCase */, true /** smartCase */);\n        } catch (e) {}\n        if (parsedQuery) {\n          cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\n        } else {\n          clearSearchHighlight(cm);\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n        }\n      }\n      function onPromptKeyDown(e, query, close) {\n        var keyName = CodeMirror.keyName(e);\n        if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' || keyName == 'Backspace' && query == '') {\n          vimGlobalState.searchHistoryController.pushInput(query);\n          vimGlobalState.searchHistoryController.reset();\n          updateSearchQuery(cm, originalQuery);\n          clearSearchHighlight(cm);\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          CodeMirror.e_stop(e);\n          clearInputState(cm);\n          close();\n          cm.focus();\n        } else if (keyName == 'Up' || keyName == 'Down') {\n          CodeMirror.e_stop(e);\n        } else if (keyName == 'Ctrl-U') {\n          CodeMirror.e_stop(e);\n          close('');\n        }\n      }\n      switch (command.searchArgs.querySrc) {\n        case 'prompt':\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isPlaying) {\n            var query = macroModeState.replaySearchQueries.shift();\n            handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n          } else {\n            showPrompt(cm, {\n              onClose: onPromptClose,\n              prefix: promptPrefix,\n              desc: '(JavaScript regexp)',\n              onKeyUp: onPromptKeyUp,\n              onKeyDown: onPromptKeyDown\n            });\n          }\n          break;\n        case 'wordUnderCursor':\n          var word = expandWordUnderCursor(cm, false /** inclusive */, true /** forward */, false /** bigWord */, true /** noSymbol */);\n          var isKeyword = true;\n          if (!word) {\n            word = expandWordUnderCursor(cm, false /** inclusive */, true /** forward */, false /** bigWord */, false /** noSymbol */);\n            isKeyword = false;\n          }\n          if (!word) {\n            return;\n          }\n          var query = cm.getLine(word.start.line).substring(word.start.ch, word.end.ch);\n          if (isKeyword && wholeWordOnly) {\n            query = '\\\\b' + query + '\\\\b';\n          } else {\n            query = escapeRegex(query);\n          }\n          vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n          cm.setCursor(word.start);\n          handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n          break;\n      }\n    },\n    processEx: function (cm, vim, command) {\n      function onPromptClose(input) {\n        vimGlobalState.exCommandHistoryController.pushInput(input);\n        vimGlobalState.exCommandHistoryController.reset();\n        exCommandDispatcher.processCommand(cm, input);\n        if (cm.state.vim) clearInputState(cm);\n      }\n      function onPromptKeyDown(e, input, close) {\n        var keyName = CodeMirror.keyName(e),\n          up,\n          offset;\n        if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' || keyName == 'Backspace' && input == '') {\n          vimGlobalState.exCommandHistoryController.pushInput(input);\n          vimGlobalState.exCommandHistoryController.reset();\n          CodeMirror.e_stop(e);\n          clearInputState(cm);\n          close();\n          cm.focus();\n        }\n        if (keyName == 'Up' || keyName == 'Down') {\n          CodeMirror.e_stop(e);\n          up = keyName == 'Up' ? true : false;\n          offset = e.target ? e.target.selectionEnd : 0;\n          input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n          close(input);\n          if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n        } else if (keyName == 'Ctrl-U') {\n          CodeMirror.e_stop(e);\n          close('');\n        } else {\n          if (keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift') vimGlobalState.exCommandHistoryController.reset();\n        }\n      }\n      if (command.type == 'keyToEx') {\n        exCommandDispatcher.processCommand(cm, command.exArgs.input);\n      } else {\n        if (vim.visualMode) {\n          showPrompt(cm, {\n            onClose: onPromptClose,\n            prefix: ':',\n            value: '\\'<,\\'>',\n            onKeyDown: onPromptKeyDown,\n            selectValueOnOpen: false\n          });\n        } else {\n          showPrompt(cm, {\n            onClose: onPromptClose,\n            prefix: ':',\n            onKeyDown: onPromptKeyDown\n          });\n        }\n      }\n    },\n    evalInput: function (cm, vim) {\n      var inputState = vim.inputState;\n      var motion = inputState.motion;\n      var motionArgs = inputState.motionArgs || {};\n      var operator = inputState.operator;\n      var operatorArgs = inputState.operatorArgs || {};\n      var registerName = inputState.registerName;\n      var sel = vim.sel;\n      var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head) : cm.getCursor('head'));\n      var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n      var oldHead = copyCursor(origHead);\n      var oldAnchor = copyCursor(origAnchor);\n      var newHead, newAnchor;\n      var repeat;\n      if (operator) {\n        this.recordLastEdit(vim, inputState);\n      }\n      if (inputState.repeatOverride !== undefined) {\n        repeat = inputState.repeatOverride;\n      } else {\n        repeat = inputState.getRepeat();\n      }\n      if (repeat > 0 && motionArgs.explicitRepeat) {\n        motionArgs.repeatIsExplicit = true;\n      } else if (motionArgs.noRepeat || !motionArgs.explicitRepeat && repeat === 0) {\n        repeat = 1;\n        motionArgs.repeatIsExplicit = false;\n      }\n      if (inputState.selectedCharacter) {\n        motionArgs.selectedCharacter = operatorArgs.selectedCharacter = inputState.selectedCharacter;\n      }\n      motionArgs.repeat = repeat;\n      clearInputState(cm);\n      if (motion) {\n        var motionResult = motions[motion](cm, origHead, motionArgs, vim, inputState);\n        vim.lastMotion = motions[motion];\n        if (!motionResult) {\n          return;\n        }\n        if (motionArgs.toJumplist) {\n          if (!operator && cm.ace.curOp != null) cm.ace.curOp.command.scrollIntoView = \"center-animate\"; // ace_patch\n          var jumpList = vimGlobalState.jumpList;\n          var cachedCursor = jumpList.cachedCursor;\n          if (cachedCursor) {\n            recordJumpPosition(cm, cachedCursor, motionResult);\n            delete jumpList.cachedCursor;\n          } else {\n            recordJumpPosition(cm, origHead, motionResult);\n          }\n        }\n        if (motionResult instanceof Array) {\n          newAnchor = motionResult[0];\n          newHead = motionResult[1];\n        } else {\n          newHead = motionResult;\n        }\n        if (!newHead) {\n          newHead = copyCursor(origHead);\n        }\n        if (vim.visualMode) {\n          if (!(vim.visualBlock && newHead.ch === Infinity)) {\n            newHead = clipCursorToContent(cm, newHead, oldHead);\n          }\n          if (newAnchor) {\n            newAnchor = clipCursorToContent(cm, newAnchor);\n          }\n          newAnchor = newAnchor || oldAnchor;\n          sel.anchor = newAnchor;\n          sel.head = newHead;\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorIsBefore(newAnchor, newHead) ? newAnchor : newHead);\n          updateMark(cm, vim, '>', cursorIsBefore(newAnchor, newHead) ? newHead : newAnchor);\n        } else if (!operator) {\n          if (cm.ace.curOp) cm.ace.curOp.vimDialogScroll = \"center-animate\"; // ace_patch\n          newHead = clipCursorToContent(cm, newHead, oldHead);\n          cm.setCursor(newHead.line, newHead.ch);\n        }\n      }\n      if (operator) {\n        if (operatorArgs.lastSel) {\n          newAnchor = oldAnchor;\n          var lastSel = operatorArgs.lastSel;\n          var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n          var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n          if (lastSel.visualLine) {\n            newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n          } else if (lastSel.visualBlock) {\n            newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n          } else if (lastSel.head.line == lastSel.anchor.line) {\n            newHead = new Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n          } else {\n            newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n          }\n          vim.visualMode = true;\n          vim.visualLine = lastSel.visualLine;\n          vim.visualBlock = lastSel.visualBlock;\n          sel = vim.sel = {\n            anchor: newAnchor,\n            head: newHead\n          };\n          updateCmSelection(cm);\n        } else if (vim.visualMode) {\n          operatorArgs.lastSel = {\n            anchor: copyCursor(sel.anchor),\n            head: copyCursor(sel.head),\n            visualBlock: vim.visualBlock,\n            visualLine: vim.visualLine\n          };\n        }\n        var curStart, curEnd, linewise, mode;\n        var cmSel;\n        if (vim.visualMode) {\n          curStart = cursorMin(sel.head, sel.anchor);\n          curEnd = cursorMax(sel.head, sel.anchor);\n          linewise = vim.visualLine || operatorArgs.linewise;\n          mode = vim.visualBlock ? 'block' : linewise ? 'line' : 'char';\n          var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n          cmSel = makeCmSelection(cm, {\n            anchor: newPositions.start,\n            head: newPositions.end\n          }, mode);\n          if (linewise) {\n            var ranges = cmSel.ranges;\n            if (mode == 'block') {\n              for (var i = 0; i < ranges.length; i++) {\n                ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n              }\n            } else if (mode == 'line') {\n              ranges[0].head = new Pos(ranges[0].head.line + 1, 0);\n            }\n          }\n        } else {\n          curStart = copyCursor(newAnchor || oldAnchor);\n          curEnd = copyCursor(newHead || oldHead);\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curStart;\n            curStart = curEnd;\n            curEnd = tmp;\n          }\n          linewise = motionArgs.linewise || operatorArgs.linewise;\n          if (linewise) {\n            expandSelectionToLine(cm, curStart, curEnd);\n          } else if (motionArgs.forward) {\n            clipToLine(cm, curStart, curEnd);\n          }\n          mode = 'char';\n          var exclusive = !motionArgs.inclusive || linewise;\n          var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n          cmSel = makeCmSelection(cm, {\n            anchor: newPositions.start,\n            head: newPositions.end\n          }, mode, exclusive);\n        }\n        cm.setSelections(cmSel.ranges, cmSel.primary);\n        vim.lastMotion = null;\n        operatorArgs.repeat = repeat; // For indent in visual mode.\n        operatorArgs.registerName = registerName;\n        operatorArgs.linewise = linewise;\n        var operatorMoveTo = operators[operator](cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n        if (vim.visualMode) {\n          exitVisualMode(cm, operatorMoveTo != null);\n        }\n        if (operatorMoveTo) {\n          cm.setCursor(operatorMoveTo);\n        }\n      }\n    },\n    recordLastEdit: function (vim, inputState, actionCommand) {\n      var macroModeState = vimGlobalState.macroModeState;\n      if (macroModeState.isPlaying) {\n        return;\n      }\n      vim.lastEditInputState = inputState;\n      vim.lastEditActionCommand = actionCommand;\n      macroModeState.lastInsertModeChanges.changes = [];\n      macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n      macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;\n    }\n  };\n  var motions = {\n    moveToTopLine: function (cm, _head, motionArgs) {\n      var line = getUserVisibleLines(cm).top + motionArgs.repeat - 1;\n      return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    moveToMiddleLine: function (cm) {\n      var range = getUserVisibleLines(cm);\n      var line = Math.floor((range.top + range.bottom) * 0.5);\n      return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    moveToBottomLine: function (cm, _head, motionArgs) {\n      var line = getUserVisibleLines(cm).bottom - motionArgs.repeat + 1;\n      return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    expandToLine: function (_cm, head, motionArgs) {\n      var cur = head;\n      return new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n    },\n    findNext: function (cm, _head, motionArgs) {\n      var state = getSearchState(cm);\n      var query = state.getQuery();\n      if (!query) {\n        return;\n      }\n      var prev = !motionArgs.forward;\n      prev = state.isReversed() ? !prev : prev;\n      highlightSearchMatches(cm, query);\n      return findNext(cm, prev /** prev */, query, motionArgs.repeat);\n    },\n    findAndSelectNextInclusive: function (cm, _head, motionArgs, vim, prevInputState) {\n      var state = getSearchState(cm);\n      var query = state.getQuery();\n      if (!query) {\n        return;\n      }\n      var prev = !motionArgs.forward;\n      prev = state.isReversed() ? !prev : prev;\n      var next = findNextFromAndToInclusive(cm, prev, query, motionArgs.repeat, vim);\n      if (!next) {\n        return;\n      }\n      if (prevInputState.operator) {\n        return next;\n      }\n      var from = next[0];\n      var to = new Pos(next[1].line, next[1].ch - 1);\n      if (vim.visualMode) {\n        if (vim.visualLine || vim.visualBlock) {\n          vim.visualLine = false;\n          vim.visualBlock = false;\n          CodeMirror.signal(cm, \"vim-mode-change\", {\n            mode: \"visual\",\n            subMode: \"\"\n          });\n        }\n        var anchor = vim.sel.anchor;\n        if (anchor) {\n          if (state.isReversed()) {\n            if (motionArgs.forward) {\n              return [anchor, from];\n            }\n            return [anchor, to];\n          } else {\n            if (motionArgs.forward) {\n              return [anchor, to];\n            }\n            return [anchor, from];\n          }\n        }\n      } else {\n        vim.visualMode = true;\n        vim.visualLine = false;\n        vim.visualBlock = false;\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"visual\",\n          subMode: \"\"\n        });\n      }\n      return prev ? [to, from] : [from, to];\n    },\n    goToMark: function (cm, _head, motionArgs, vim) {\n      var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\n      if (pos) {\n        return motionArgs.linewise ? {\n          line: pos.line,\n          ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line))\n        } : pos;\n      }\n      return null;\n    },\n    moveToOtherHighlightedEnd: function (cm, _head, motionArgs, vim) {\n      if (vim.visualBlock && motionArgs.sameLine) {\n        var sel = vim.sel;\n        return [clipCursorToContent(cm, new Pos(sel.anchor.line, sel.head.ch)), clipCursorToContent(cm, new Pos(sel.head.line, sel.anchor.ch))];\n      } else {\n        return [vim.sel.head, vim.sel.anchor];\n      }\n    },\n    jumpToMark: function (cm, head, motionArgs, vim) {\n      var best = head;\n      for (var i = 0; i < motionArgs.repeat; i++) {\n        var cursor = best;\n        for (var key in vim.marks) {\n          if (!isLowerCase(key)) {\n            continue;\n          }\n          var mark = vim.marks[key].find();\n          var isWrongDirection = motionArgs.forward ? cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n          if (isWrongDirection) {\n            continue;\n          }\n          if (motionArgs.linewise && mark.line == cursor.line) {\n            continue;\n          }\n          var equal = cursorEqual(cursor, best);\n          var between = motionArgs.forward ? cursorIsBetween(cursor, mark, best) : cursorIsBetween(best, mark, cursor);\n          if (equal || between) {\n            best = mark;\n          }\n        }\n      }\n      if (motionArgs.linewise) {\n        best = new Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n      }\n      return best;\n    },\n    moveByCharacters: function (_cm, head, motionArgs) {\n      var cur = head;\n      var repeat = motionArgs.repeat;\n      var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n      return new Pos(cur.line, ch);\n    },\n    moveByLines: function (cm, head, motionArgs, vim) {\n      var cur = head;\n      var endCh = cur.ch;\n      switch (vim.lastMotion) {\n        case this.moveByLines:\n        case this.moveByDisplayLines:\n        case this.moveByScroll:\n        case this.moveToColumn:\n        case this.moveToEol:\n          endCh = vim.lastHPos;\n          break;\n        default:\n          vim.lastHPos = endCh;\n      }\n      var repeat = motionArgs.repeat + (motionArgs.repeatOffset || 0);\n      var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n      var first = cm.firstLine();\n      var last = cm.lastLine();\n      if (line < first && cur.line == first) {\n        return this.moveToStartOfLine(cm, head, motionArgs, vim);\n      } else if (line > last && cur.line == last) {\n        return moveToEol(cm, head, motionArgs, vim, true);\n      }\n      var fold = cm.ace.session.getFoldLine(line);\n      if (fold) {\n        if (motionArgs.forward) {\n          if (line > fold.start.row) line = fold.end.row + 1;\n        } else {\n          line = fold.start.row;\n        }\n      }\n      if (motionArgs.toFirstChar) {\n        endCh = findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n        vim.lastHPos = endCh;\n      }\n      vim.lastHSPos = cm.charCoords(new Pos(line, endCh), 'div').left;\n      return new Pos(line, endCh);\n    },\n    moveByDisplayLines: function (cm, head, motionArgs, vim) {\n      var cur = head;\n      switch (vim.lastMotion) {\n        case this.moveByDisplayLines:\n        case this.moveByScroll:\n        case this.moveByLines:\n        case this.moveToColumn:\n        case this.moveToEol:\n          break;\n        default:\n          vim.lastHSPos = cm.charCoords(cur, 'div').left;\n      }\n      var repeat = motionArgs.repeat;\n      var res = cm.findPosV(cur, motionArgs.forward ? repeat : -repeat, 'line', vim.lastHSPos);\n      if (res.hitSide) {\n        if (motionArgs.forward) {\n          var lastCharCoords = cm.charCoords(res, 'div');\n          var goalCoords = {\n            top: lastCharCoords.top + 8,\n            left: vim.lastHSPos\n          };\n          var res = cm.coordsChar(goalCoords, 'div');\n        } else {\n          var resCoords = cm.charCoords(new Pos(cm.firstLine(), 0), 'div');\n          resCoords.left = vim.lastHSPos;\n          res = cm.coordsChar(resCoords, 'div');\n        }\n      }\n      vim.lastHPos = res.ch;\n      return res;\n    },\n    moveByPage: function (cm, head, motionArgs) {\n      var curStart = head;\n      var repeat = motionArgs.repeat;\n      return cm.findPosV(curStart, motionArgs.forward ? repeat : -repeat, 'page');\n    },\n    moveByParagraph: function (cm, head, motionArgs) {\n      var dir = motionArgs.forward ? 1 : -1;\n      return findParagraph(cm, head, motionArgs.repeat, dir);\n    },\n    moveBySentence: function (cm, head, motionArgs) {\n      var dir = motionArgs.forward ? 1 : -1;\n      return findSentence(cm, head, motionArgs.repeat, dir);\n    },\n    moveByScroll: function (cm, head, motionArgs, vim) {\n      var scrollbox = cm.getScrollInfo();\n      var curEnd = null;\n      var repeat = motionArgs.repeat;\n      if (!repeat) {\n        repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n      }\n      var orig = cm.charCoords(head, 'local');\n      motionArgs.repeat = repeat;\n      curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n      if (!curEnd) {\n        return null;\n      }\n      var dest = cm.charCoords(curEnd, 'local');\n      cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n      return curEnd;\n    },\n    moveByWords: function (cm, head, motionArgs) {\n      return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward, !!motionArgs.wordEnd, !!motionArgs.bigWord);\n    },\n    moveTillCharacter: function (cm, _head, motionArgs) {\n      var repeat = motionArgs.repeat;\n      var curEnd = moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter);\n      var increment = motionArgs.forward ? -1 : 1;\n      recordLastCharacterSearch(increment, motionArgs);\n      if (!curEnd) return null;\n      curEnd.ch += increment;\n      return curEnd;\n    },\n    moveToCharacter: function (cm, head, motionArgs) {\n      var repeat = motionArgs.repeat;\n      recordLastCharacterSearch(0, motionArgs);\n      return moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter) || head;\n    },\n    moveToSymbol: function (cm, head, motionArgs) {\n      var repeat = motionArgs.repeat;\n      return findSymbol(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter) || head;\n    },\n    moveToColumn: function (cm, head, motionArgs, vim) {\n      var repeat = motionArgs.repeat;\n      vim.lastHPos = repeat - 1;\n      vim.lastHSPos = cm.charCoords(head, 'div').left;\n      return moveToColumn(cm, repeat);\n    },\n    moveToEol: function (cm, head, motionArgs, vim) {\n      return moveToEol(cm, head, motionArgs, vim, false);\n    },\n    moveToFirstNonWhiteSpaceCharacter: function (cm, head) {\n      var cursor = head;\n      return new Pos(cursor.line, findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n    },\n    moveToMatchedSymbol: function (cm, head) {\n      var cursor = head;\n      var line = cursor.line;\n      var ch = cursor.ch;\n      var lineText = cm.getLine(line);\n      var symbol;\n      for (; ch < lineText.length; ch++) {\n        symbol = lineText.charAt(ch);\n        if (symbol && isMatchableSymbol(symbol)) {\n          var style = cm.getTokenTypeAt(new Pos(line, ch + 1));\n          if (style !== \"string\" && style !== \"comment\") {\n            break;\n          }\n        }\n      }\n      if (ch < lineText.length) {\n        var re = /[<>]/.test(lineText[ch]) ? /[(){}[\\]<>]/ : /[(){}[\\]]/; //ace_patch?\n        var matched = cm.findMatchingBracket(new Pos(line, ch + 1), {\n          bracketRegex: re\n        });\n        return matched.to;\n      } else {\n        return cursor;\n      }\n    },\n    moveToStartOfLine: function (_cm, head) {\n      return new Pos(head.line, 0);\n    },\n    moveToLineOrEdgeOfDocument: function (cm, _head, motionArgs) {\n      var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n      if (motionArgs.repeatIsExplicit) {\n        lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n      }\n      return new Pos(lineNum, findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n    },\n    moveToStartOfDisplayLine: function (cm) {\n      cm.execCommand(\"goLineLeft\");\n      return cm.getCursor();\n    },\n    moveToEndOfDisplayLine: function (cm) {\n      cm.execCommand(\"goLineRight\");\n      var head = cm.getCursor();\n      if (head.sticky == \"before\") head.ch--;\n      return head;\n    },\n    textObjectManipulation: function (cm, head, motionArgs, vim) {\n      var mirroredPairs = {\n        '(': ')',\n        ')': '(',\n        '{': '}',\n        '}': '{',\n        '[': ']',\n        ']': '[',\n        '<': '>',\n        '>': '<'\n      };\n      var selfPaired = {\n        '\\'': true,\n        '\"': true,\n        '`': true\n      };\n      var character = motionArgs.selectedCharacter;\n      if (character == 'b') {\n        character = '(';\n      } else if (character == 'B') {\n        character = '{';\n      }\n      var inclusive = !motionArgs.textObjectInner;\n      var tmp;\n      if (mirroredPairs[character]) {\n        tmp = selectCompanionObject(cm, head, character, inclusive);\n      } else if (selfPaired[character]) {\n        tmp = findBeginningAndEnd(cm, head, character, inclusive);\n      } else if (character === 'W') {\n        tmp = expandWordUnderCursor(cm, inclusive, true /** forward */, true /** bigWord */);\n      } else if (character === 'w') {\n        tmp = expandWordUnderCursor(cm, inclusive, true /** forward */, false /** bigWord */);\n      } else if (character === 'p') {\n        tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n        motionArgs.linewise = true;\n        if (vim.visualMode) {\n          if (!vim.visualLine) {\n            vim.visualLine = true;\n          }\n        } else {\n          var operatorArgs = vim.inputState.operatorArgs;\n          if (operatorArgs) {\n            operatorArgs.linewise = true;\n          }\n          tmp.end.line--;\n        }\n      } else if (character === 't') {\n        tmp = expandTagUnderCursor(cm, head, inclusive);\n      } else if (character === 's') {\n        var content = cm.getLine(head.line);\n        if (head.ch > 0 && isEndOfSentenceSymbol(content[head.ch])) {\n          head.ch -= 1;\n        }\n        var end = getSentence(cm, head, motionArgs.repeat, 1, inclusive);\n        var start = getSentence(cm, head, motionArgs.repeat, -1, inclusive);\n        if (isWhiteSpaceString(cm.getLine(start.line)[start.ch]) && isWhiteSpaceString(cm.getLine(end.line)[end.ch - 1])) {\n          start = {\n            line: start.line,\n            ch: start.ch + 1\n          };\n        }\n        tmp = {\n          start: start,\n          end: end\n        };\n      } else {\n        return null;\n      }\n      if (!cm.state.vim.visualMode) {\n        return [tmp.start, tmp.end];\n      } else {\n        return expandSelection(cm, tmp.start, tmp.end);\n      }\n    },\n    repeatLastCharacterSearch: function (cm, head, motionArgs) {\n      var lastSearch = vimGlobalState.lastCharacterSearch;\n      var repeat = motionArgs.repeat;\n      var forward = motionArgs.forward === lastSearch.forward;\n      var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n      cm.moveH(-increment, 'char');\n      motionArgs.inclusive = forward ? true : false;\n      var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n      if (!curEnd) {\n        cm.moveH(increment, 'char');\n        return head;\n      }\n      curEnd.ch += increment;\n      return curEnd;\n    }\n  };\n  function defineMotion(name, fn) {\n    motions[name] = fn;\n  }\n  function fillArray(val, times) {\n    var arr = [];\n    for (var i = 0; i < times; i++) {\n      arr.push(val);\n    }\n    return arr;\n  }\n  var operators = {\n    change: function (cm, args, ranges) {\n      var finalHead, text;\n      var vim = cm.state.vim;\n      var anchor = ranges[0].anchor,\n        head = ranges[0].head;\n      if (!vim.visualMode) {\n        text = cm.getRange(anchor, head);\n        var lastState = vim.lastEditInputState || {};\n        if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n          var match = /\\s+$/.exec(text);\n          if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n            head = offsetCursor(head, 0, -match[0].length);\n            text = text.slice(0, -match[0].length);\n          }\n        }\n        var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);\n        var wasLastLine = cm.firstLine() == cm.lastLine();\n        if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {\n          cm.replaceRange('', prevLineEnd, head);\n        } else {\n          cm.replaceRange('', anchor, head);\n        }\n        if (args.linewise) {\n          if (!wasLastLine) {\n            cm.setCursor(prevLineEnd);\n            CodeMirror.commands.newlineAndIndent(cm);\n          }\n          anchor.ch = Number.MAX_VALUE;\n        }\n        finalHead = anchor;\n      } else if (args.fullLine) {\n        head.ch = Number.MAX_VALUE;\n        head.line--;\n        cm.setSelection(anchor, head);\n        text = cm.getSelection();\n        cm.replaceSelection(\"\");\n        finalHead = anchor;\n      } else {\n        text = cm.getSelection();\n        var replacement = fillArray('', ranges.length);\n        cm.replaceSelections(replacement);\n        finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n      }\n      vimGlobalState.registerController.pushText(args.registerName, 'change', text, args.linewise, ranges.length > 1);\n      actions.enterInsertMode(cm, {\n        head: finalHead\n      }, cm.state.vim);\n    },\n    'delete': function (cm, args, ranges) {\n      var finalHead, text;\n      var vim = cm.state.vim;\n      if (!vim.visualBlock) {\n        var anchor = ranges[0].anchor,\n          head = ranges[0].head;\n        if (args.linewise && head.line != cm.firstLine() && anchor.line == cm.lastLine() && anchor.line == head.line - 1) {\n          if (anchor.line == cm.firstLine()) {\n            anchor.ch = 0;\n          } else {\n            anchor = new Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n          }\n        }\n        text = cm.getRange(anchor, head);\n        cm.replaceRange('', anchor, head);\n        finalHead = anchor;\n        if (args.linewise) {\n          finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n        }\n      } else {\n        text = cm.getSelection();\n        var replacement = fillArray('', ranges.length);\n        cm.replaceSelections(replacement);\n        finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n      }\n      vimGlobalState.registerController.pushText(args.registerName, 'delete', text, args.linewise, vim.visualBlock);\n      return clipCursorToContent(cm, finalHead);\n    },\n    indent: function (cm, args, ranges) {\n      var vim = cm.state.vim;\n      if (cm.indentMore) {\n        var repeat = vim.visualMode ? args.repeat : 1;\n        for (var j = 0; j < repeat; j++) {\n          if (args.indentRight) cm.indentMore();else cm.indentLess();\n        }\n      } else {\n        var startLine = ranges[0].anchor.line;\n        var endLine = vim.visualBlock ? ranges[ranges.length - 1].anchor.line : ranges[0].head.line;\n        var repeat = vim.visualMode ? args.repeat : 1;\n        if (args.linewise) {\n          endLine--;\n        }\n        for (var i = startLine; i <= endLine; i++) {\n          for (var j = 0; j < repeat; j++) {\n            cm.indentLine(i, args.indentRight);\n          }\n        }\n      }\n      return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n    },\n    indentAuto: function (cm, _args, ranges) {\n      if (ranges.length > 1) {\n        // ace_patch\n        cm.setSelection(ranges[0].anchor, ranges[ranges.length - 1].head);\n      }\n      cm.execCommand(\"indentAuto\");\n      return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n    },\n    changeCase: function (cm, args, ranges, oldAnchor, newHead) {\n      var selections = cm.getSelections();\n      var swapped = [];\n      var toLower = args.toLower;\n      for (var j = 0; j < selections.length; j++) {\n        var toSwap = selections[j];\n        var text = '';\n        if (toLower === true) {\n          text = toSwap.toLowerCase();\n        } else if (toLower === false) {\n          text = toSwap.toUpperCase();\n        } else {\n          for (var i = 0; i < toSwap.length; i++) {\n            var character = toSwap.charAt(i);\n            text += isUpperCase(character) ? character.toLowerCase() : character.toUpperCase();\n          }\n        }\n        swapped.push(text);\n      }\n      cm.replaceSelections(swapped);\n      if (args.shouldMoveCursor) {\n        return newHead;\n      } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n      } else if (args.linewise) {\n        return oldAnchor;\n      } else {\n        return cursorMin(ranges[0].anchor, ranges[0].head);\n      }\n    },\n    yank: function (cm, args, ranges, oldAnchor) {\n      var vim = cm.state.vim;\n      var text = cm.getSelection();\n      var endPos = vim.visualMode ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor) : oldAnchor;\n      vimGlobalState.registerController.pushText(args.registerName, 'yank', text, args.linewise, vim.visualBlock);\n      return endPos;\n    }\n  };\n  function defineOperator(name, fn) {\n    operators[name] = fn;\n  }\n  var actions = {\n    jumpListWalk: function (cm, actionArgs, vim) {\n      if (vim.visualMode) {\n        return;\n      }\n      var repeat = actionArgs.repeat;\n      var forward = actionArgs.forward;\n      var jumpList = vimGlobalState.jumpList;\n      var mark = jumpList.move(cm, forward ? repeat : -repeat);\n      var markPos = mark ? mark.find() : undefined;\n      markPos = markPos ? markPos : cm.getCursor();\n      cm.setCursor(markPos);\n      cm.ace.curOp.command.scrollIntoView = \"center-animate\"; // ace_patch\n    },\n\n    scroll: function (cm, actionArgs, vim) {\n      if (vim.visualMode) {\n        return;\n      }\n      var repeat = actionArgs.repeat || 1;\n      var lineHeight = cm.defaultTextHeight();\n      var top = cm.getScrollInfo().top;\n      var delta = lineHeight * repeat;\n      var newPos = actionArgs.forward ? top + delta : top - delta;\n      var cursor = copyCursor(cm.getCursor());\n      var cursorCoords = cm.charCoords(cursor, 'local');\n      if (actionArgs.forward) {\n        if (newPos > cursorCoords.top) {\n          cursor.line += (newPos - cursorCoords.top) / lineHeight;\n          cursor.line = Math.ceil(cursor.line);\n          cm.setCursor(cursor);\n          cursorCoords = cm.charCoords(cursor, 'local');\n          cm.scrollTo(null, cursorCoords.top);\n        } else {\n          cm.scrollTo(null, newPos);\n        }\n      } else {\n        var newBottom = newPos + cm.getScrollInfo().clientHeight;\n        if (newBottom < cursorCoords.bottom) {\n          cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n          cursor.line = Math.floor(cursor.line);\n          cm.setCursor(cursor);\n          cursorCoords = cm.charCoords(cursor, 'local');\n          cm.scrollTo(null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n        } else {\n          cm.scrollTo(null, newPos);\n        }\n      }\n    },\n    scrollToCursor: function (cm, actionArgs) {\n      var lineNum = cm.getCursor().line;\n      var charCoords = cm.charCoords(new Pos(lineNum, 0), 'local');\n      var height = cm.getScrollInfo().clientHeight;\n      var y = charCoords.top;\n      switch (actionArgs.position) {\n        case 'center':\n          y = charCoords.bottom - height / 2;\n          break;\n        case 'bottom':\n          var lineLastCharPos = new Pos(lineNum, cm.getLine(lineNum).length - 1);\n          var lineLastCharCoords = cm.charCoords(lineLastCharPos, 'local');\n          var lineHeight = lineLastCharCoords.bottom - y;\n          y = y - height + lineHeight;\n          break;\n      }\n      cm.scrollTo(null, y);\n    },\n    replayMacro: function (cm, actionArgs, vim) {\n      var registerName = actionArgs.selectedCharacter;\n      var repeat = actionArgs.repeat;\n      var macroModeState = vimGlobalState.macroModeState;\n      if (registerName == '@') {\n        registerName = macroModeState.latestRegister;\n      } else {\n        macroModeState.latestRegister = registerName;\n      }\n      while (repeat--) {\n        executeMacroRegister(cm, vim, macroModeState, registerName);\n      }\n    },\n    enterMacroRecordMode: function (cm, actionArgs) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var registerName = actionArgs.selectedCharacter;\n      if (vimGlobalState.registerController.isValidRegister(registerName)) {\n        macroModeState.enterMacroRecordMode(cm, registerName);\n      }\n    },\n    toggleOverwrite: function (cm) {\n      if (!cm.state.overwrite) {\n        cm.toggleOverwrite(true);\n        cm.setOption('keyMap', 'vim-replace');\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"replace\"\n        });\n      } else {\n        cm.toggleOverwrite(false);\n        cm.setOption('keyMap', 'vim-insert');\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"insert\"\n        });\n      }\n    },\n    enterInsertMode: function (cm, actionArgs, vim) {\n      if (cm.getOption('readOnly')) {\n        return;\n      }\n      vim.insertMode = true;\n      vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n      var insertAt = actionArgs ? actionArgs.insertAt : null;\n      var sel = vim.sel;\n      var head = actionArgs.head || cm.getCursor('head');\n      var height = cm.listSelections().length;\n      if (insertAt == 'eol') {\n        head = new Pos(head.line, lineLength(cm, head.line));\n      } else if (insertAt == 'bol') {\n        head = new Pos(head.line, 0);\n      } else if (insertAt == 'charAfter') {\n        var newPosition = updateSelectionForSurrogateCharacters(cm, head, offsetCursor(head, 0, 1));\n        head = newPosition.end;\n      } else if (insertAt == 'firstNonBlank') {\n        var newPosition = updateSelectionForSurrogateCharacters(cm, head, motions.moveToFirstNonWhiteSpaceCharacter(cm, head));\n        head = newPosition.end;\n      } else if (insertAt == 'startOfSelectedArea') {\n        if (!vim.visualMode) return;\n        if (!vim.visualBlock) {\n          if (sel.head.line < sel.anchor.line) {\n            head = sel.head;\n          } else {\n            head = new Pos(sel.anchor.line, 0);\n          }\n        } else {\n          head = new Pos(Math.min(sel.head.line, sel.anchor.line), Math.min(sel.head.ch, sel.anchor.ch));\n          height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n        }\n      } else if (insertAt == 'endOfSelectedArea') {\n        if (!vim.visualMode) return;\n        if (!vim.visualBlock) {\n          if (sel.head.line >= sel.anchor.line) {\n            head = offsetCursor(sel.head, 0, 1);\n          } else {\n            head = new Pos(sel.anchor.line, 0);\n          }\n        } else {\n          head = new Pos(Math.min(sel.head.line, sel.anchor.line), Math.max(sel.head.ch, sel.anchor.ch) + 1);\n          height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n        }\n      } else if (insertAt == 'inplace') {\n        if (vim.visualMode) {\n          return;\n        }\n      } else if (insertAt == 'lastEdit') {\n        head = getLastEditPos(cm) || head;\n      }\n      cm.setOption('disableInput', false);\n      if (actionArgs && actionArgs.replace) {\n        cm.toggleOverwrite(true);\n        cm.setOption('keyMap', 'vim-replace');\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"replace\"\n        });\n      } else {\n        cm.toggleOverwrite(false);\n        cm.setOption('keyMap', 'vim-insert');\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"insert\"\n        });\n      }\n      if (!vimGlobalState.macroModeState.isPlaying) {\n        cm.on('change', onChange);\n        CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n      }\n      if (vim.visualMode) {\n        exitVisualMode(cm);\n      }\n      selectForInsert(cm, head, height);\n    },\n    toggleVisualMode: function (cm, actionArgs, vim) {\n      var repeat = actionArgs.repeat;\n      var anchor = cm.getCursor();\n      var head;\n      if (!vim.visualMode) {\n        vim.visualMode = true;\n        vim.visualLine = !!actionArgs.linewise;\n        vim.visualBlock = !!actionArgs.blockwise;\n        head = clipCursorToContent(cm, new Pos(anchor.line, anchor.ch + repeat - 1));\n        var newPosition = updateSelectionForSurrogateCharacters(cm, anchor, head);\n        vim.sel = {\n          anchor: newPosition.start,\n          head: newPosition.end\n        };\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"visual\",\n          subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"\n        });\n        updateCmSelection(cm);\n        updateMark(cm, vim, '<', cursorMin(anchor, head));\n        updateMark(cm, vim, '>', cursorMax(anchor, head));\n      } else if (vim.visualLine ^ actionArgs.linewise || vim.visualBlock ^ actionArgs.blockwise) {\n        vim.visualLine = !!actionArgs.linewise;\n        vim.visualBlock = !!actionArgs.blockwise;\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"visual\",\n          subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"\n        });\n        updateCmSelection(cm);\n      } else {\n        exitVisualMode(cm);\n      }\n    },\n    reselectLastSelection: function (cm, _actionArgs, vim) {\n      var lastSelection = vim.lastSelection;\n      if (vim.visualMode) {\n        updateLastSelection(cm, vim);\n      }\n      if (lastSelection) {\n        var anchor = lastSelection.anchorMark.find();\n        var head = lastSelection.headMark.find();\n        if (!anchor || !head) {\n          return;\n        }\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        vim.visualMode = true;\n        vim.visualLine = lastSelection.visualLine;\n        vim.visualBlock = lastSelection.visualBlock;\n        updateCmSelection(cm);\n        updateMark(cm, vim, '<', cursorMin(anchor, head));\n        updateMark(cm, vim, '>', cursorMax(anchor, head));\n        CodeMirror.signal(cm, 'vim-mode-change', {\n          mode: 'visual',\n          subMode: vim.visualLine ? 'linewise' : vim.visualBlock ? 'blockwise' : ''\n        });\n      }\n    },\n    joinLines: function (cm, actionArgs, vim) {\n      var curStart, curEnd;\n      if (vim.visualMode) {\n        curStart = cm.getCursor('anchor');\n        curEnd = cm.getCursor('head');\n        if (cursorIsBefore(curEnd, curStart)) {\n          var tmp = curEnd;\n          curEnd = curStart;\n          curStart = tmp;\n        }\n        curEnd.ch = lineLength(cm, curEnd.line) - 1;\n      } else {\n        var repeat = Math.max(actionArgs.repeat, 2);\n        curStart = cm.getCursor();\n        curEnd = clipCursorToContent(cm, new Pos(curStart.line + repeat - 1, Infinity));\n      }\n      var finalCh = 0;\n      for (var i = curStart.line; i < curEnd.line; i++) {\n        finalCh = lineLength(cm, curStart.line);\n        var text = '';\n        var nextStartCh = 0;\n        if (!actionArgs.keepSpaces) {\n          var nextLine = cm.getLine(curStart.line + 1);\n          nextStartCh = nextLine.search(/\\S/);\n          if (nextStartCh == -1) {\n            nextStartCh = nextLine.length;\n          } else {\n            text = \" \";\n          }\n        }\n        cm.replaceRange(text, new Pos(curStart.line, finalCh), new Pos(curStart.line + 1, nextStartCh));\n      }\n      var curFinalPos = clipCursorToContent(cm, new Pos(curStart.line, finalCh));\n      if (vim.visualMode) {\n        exitVisualMode(cm, false);\n      }\n      cm.setCursor(curFinalPos);\n    },\n    newLineAndEnterInsertMode: function (cm, actionArgs, vim) {\n      vim.insertMode = true;\n      var insertAt = copyCursor(cm.getCursor());\n      if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n        cm.replaceRange('\\n', new Pos(cm.firstLine(), 0));\n        cm.setCursor(cm.firstLine(), 0);\n      } else {\n        insertAt.line = actionArgs.after ? insertAt.line : insertAt.line - 1;\n        insertAt.ch = lineLength(cm, insertAt.line);\n        cm.setCursor(insertAt);\n        var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent;\n        newlineFn(cm);\n      }\n      this.enterInsertMode(cm, {\n        repeat: actionArgs.repeat\n      }, vim);\n    },\n    paste: function (cm, actionArgs, vim) {\n      var _this = this;\n      var register = vimGlobalState.registerController.getRegister(actionArgs.registerName);\n      if (actionArgs.registerName === '+') {\n        navigator.clipboard.readText().then(function (value) {\n          _this.continuePaste(cm, actionArgs, vim, value, register);\n        });\n      } else {\n        var text = register.toString();\n        this.continuePaste(cm, actionArgs, vim, text, register);\n      }\n    },\n    continuePaste: function (cm, actionArgs, vim, text, register) {\n      var cur = copyCursor(cm.getCursor());\n      if (!text) {\n        return;\n      }\n      if (actionArgs.matchIndent) {\n        var tabSize = cm.getOption(\"tabSize\");\n        var whitespaceLength = function (str) {\n          var tabs = str.split(\"\\t\").length - 1;\n          var spaces = str.split(\" \").length - 1;\n          return tabs * tabSize + spaces * 1;\n        };\n        var currentLine = cm.getLine(cm.getCursor().line);\n        var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\n        var chompedText = text.replace(/\\n$/, '');\n        var wasChomped = text !== chompedText;\n        var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n        var text = chompedText.replace(/^\\s*/gm, function (wspace) {\n          var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n          if (newIndent < 0) {\n            return \"\";\n          } else if (cm.getOption(\"indentWithTabs\")) {\n            var quotient = Math.floor(newIndent / tabSize);\n            return Array(quotient + 1).join('\\t');\n          } else {\n            return Array(newIndent + 1).join(' ');\n          }\n        });\n        text += wasChomped ? \"\\n\" : \"\";\n      }\n      if (actionArgs.repeat > 1) {\n        var text = Array(actionArgs.repeat + 1).join(text);\n      }\n      var linewise = register.linewise;\n      var blockwise = register.blockwise;\n      if (blockwise) {\n        text = text.split('\\n');\n        if (linewise) {\n          text.pop();\n        }\n        for (var i = 0; i < text.length; i++) {\n          text[i] = text[i] == '' ? ' ' : text[i];\n        }\n        cur.ch += actionArgs.after ? 1 : 0;\n        cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);\n      } else if (linewise) {\n        if (vim.visualMode) {\n          text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n        } else if (actionArgs.after) {\n          text = '\\n' + text.slice(0, text.length - 1);\n          cur.ch = lineLength(cm, cur.line);\n        } else {\n          cur.ch = 0;\n        }\n      } else {\n        cur.ch += actionArgs.after ? 1 : 0;\n      }\n      var curPosFinal;\n      var idx;\n      if (vim.visualMode) {\n        vim.lastPastedText = text;\n        var lastSelectionCurEnd;\n        var selectedArea = getSelectedAreaRange(cm, vim);\n        var selectionStart = selectedArea[0];\n        var selectionEnd = selectedArea[1];\n        var selectedText = cm.getSelection();\n        var selections = cm.listSelections();\n        var emptyStrings = new Array(selections.length).join('1').split('1');\n        if (vim.lastSelection) {\n          lastSelectionCurEnd = vim.lastSelection.headMark.find();\n        }\n        vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n        if (blockwise) {\n          cm.replaceSelections(emptyStrings);\n          selectionEnd = new Pos(selectionStart.line + text.length - 1, selectionStart.ch);\n          cm.setCursor(selectionStart);\n          selectBlock(cm, selectionEnd);\n          cm.replaceSelections(text);\n          curPosFinal = selectionStart;\n        } else if (vim.visualBlock) {\n          cm.replaceSelections(emptyStrings);\n          cm.setCursor(selectionStart);\n          cm.replaceRange(text, selectionStart, selectionStart);\n          curPosFinal = selectionStart;\n        } else {\n          cm.replaceRange(text, selectionStart, selectionEnd);\n          curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n        }\n        if (lastSelectionCurEnd) {\n          vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n        }\n        if (linewise) {\n          curPosFinal.ch = 0;\n        }\n      } else {\n        if (blockwise) {\n          cm.setCursor(cur);\n          for (var i = 0; i < text.length; i++) {\n            var line = cur.line + i;\n            if (line > cm.lastLine()) {\n              cm.replaceRange('\\n', new Pos(line, 0));\n            }\n            var lastCh = lineLength(cm, line);\n            if (lastCh < cur.ch) {\n              extendLineToColumn(cm, line, cur.ch);\n            }\n          }\n          cm.setCursor(cur);\n          selectBlock(cm, new Pos(cur.line + text.length - 1, cur.ch));\n          cm.replaceSelections(text);\n          curPosFinal = cur;\n        } else {\n          cm.replaceRange(text, cur);\n          if (linewise && actionArgs.after) {\n            curPosFinal = new Pos(cur.line + 1, findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));\n          } else if (linewise && !actionArgs.after) {\n            curPosFinal = new Pos(cur.line, findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));\n          } else if (!linewise && actionArgs.after) {\n            idx = cm.indexFromPos(cur);\n            curPosFinal = cm.posFromIndex(idx + text.length - 1);\n          } else {\n            idx = cm.indexFromPos(cur);\n            curPosFinal = cm.posFromIndex(idx + text.length);\n          }\n        }\n      }\n      if (vim.visualMode) {\n        exitVisualMode(cm, false);\n      }\n      cm.setCursor(curPosFinal);\n    },\n    undo: function (cm, actionArgs) {\n      cm.operation(function () {\n        repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n        cm.setCursor(clipCursorToContent(cm, cm.getCursor('start')));\n      });\n    },\n    redo: function (cm, actionArgs) {\n      repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n    },\n    setRegister: function (_cm, actionArgs, vim) {\n      vim.inputState.registerName = actionArgs.selectedCharacter;\n    },\n    setMark: function (cm, actionArgs, vim) {\n      var markName = actionArgs.selectedCharacter;\n      updateMark(cm, vim, markName, cm.getCursor());\n    },\n    replace: function (cm, actionArgs, vim) {\n      var replaceWith = actionArgs.selectedCharacter;\n      var curStart = cm.getCursor();\n      var replaceTo;\n      var curEnd;\n      var selections = cm.listSelections();\n      if (vim.visualMode) {\n        curStart = cm.getCursor('start');\n        curEnd = cm.getCursor('end');\n      } else {\n        var line = cm.getLine(curStart.line);\n        replaceTo = curStart.ch + actionArgs.repeat;\n        if (replaceTo > line.length) {\n          replaceTo = line.length;\n        }\n        curEnd = new Pos(curStart.line, replaceTo);\n      }\n      var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n      curStart = newPositions.start;\n      curEnd = newPositions.end;\n      if (replaceWith == '\\n') {\n        if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);\n        (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n      } else {\n        var replaceWithStr = cm.getRange(curStart, curEnd);\n        replaceWithStr = replaceWithStr.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, replaceWith);\n        replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n        if (vim.visualBlock) {\n          var spaces = new Array(cm.getOption(\"tabSize\") + 1).join(' ');\n          replaceWithStr = cm.getSelection();\n          replaceWithStr = replaceWithStr.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, replaceWith);\n          replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n          cm.replaceSelections(replaceWithStr);\n        } else {\n          cm.replaceRange(replaceWithStr, curStart, curEnd);\n        }\n        if (vim.visualMode) {\n          curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ? selections[0].anchor : selections[0].head;\n          cm.setCursor(curStart);\n          exitVisualMode(cm, false);\n        } else {\n          cm.setCursor(offsetCursor(curEnd, 0, -1));\n        }\n      }\n    },\n    incrementNumberToken: function (cm, actionArgs) {\n      var cur = cm.getCursor();\n      var lineStr = cm.getLine(cur.line);\n      var re = /(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;\n      var match;\n      var start;\n      var end;\n      var numberStr;\n      while ((match = re.exec(lineStr)) !== null) {\n        start = match.index;\n        end = start + match[0].length;\n        if (cur.ch < end) break;\n      }\n      if (!actionArgs.backtrack && end <= cur.ch) return;\n      if (match) {\n        var baseStr = match[2] || match[4];\n        var digits = match[3] || match[5];\n        var increment = actionArgs.increase ? 1 : -1;\n        var base = {\n          '0b': 2,\n          '0': 8,\n          '': 10,\n          '0x': 16\n        }[baseStr.toLowerCase()];\n        var number = parseInt(match[1] + digits, base) + increment * actionArgs.repeat;\n        numberStr = number.toString(base);\n        var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : '';\n        if (numberStr.charAt(0) === '-') {\n          numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);\n        } else {\n          numberStr = baseStr + zeroPadding + numberStr;\n        }\n        var from = new Pos(cur.line, start);\n        var to = new Pos(cur.line, end);\n        cm.replaceRange(numberStr, from, to);\n      } else {\n        return;\n      }\n      cm.setCursor(new Pos(cur.line, start + numberStr.length - 1));\n    },\n    repeatLastEdit: function (cm, actionArgs, vim) {\n      var lastEditInputState = vim.lastEditInputState;\n      if (!lastEditInputState) {\n        return;\n      }\n      var repeat = actionArgs.repeat;\n      if (repeat && actionArgs.repeatIsExplicit) {\n        vim.lastEditInputState.repeatOverride = repeat;\n      } else {\n        repeat = vim.lastEditInputState.repeatOverride || repeat;\n      }\n      repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\n    },\n\n    indent: function (cm, actionArgs) {\n      cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n    },\n    exitInsertMode: exitInsertMode\n  };\n  function defineAction(name, fn) {\n    actions[name] = fn;\n  }\n  function clipCursorToContent(cm, cur, oldCur) {\n    var vim = cm.state.vim;\n    var includeLineBreak = vim.insertMode || vim.visualMode;\n    var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine());\n    var text = cm.getLine(line);\n    var maxCh = text.length - 1 + !!includeLineBreak;\n    var ch = Math.min(Math.max(0, cur.ch), maxCh);\n    var charCode = text.charCodeAt(ch);\n    if (0xDC00 < charCode && charCode < 0xDFFF) {\n      var direction = 1;\n      if (oldCur && oldCur.line == line) {\n        if (oldCur.ch > ch) {\n          direction = -1;\n        }\n      }\n      ch += direction;\n      if (ch > maxCh) ch -= 2;\n    }\n    return new Pos(line, ch);\n  }\n  function copyArgs(args) {\n    var ret = {};\n    for (var prop in args) {\n      if (args.hasOwnProperty(prop)) {\n        ret[prop] = args[prop];\n      }\n    }\n    return ret;\n  }\n  function offsetCursor(cur, offsetLine, offsetCh) {\n    if (typeof offsetLine === 'object') {\n      offsetCh = offsetLine.ch;\n      offsetLine = offsetLine.line;\n    }\n    return new Pos(cur.line + offsetLine, cur.ch + offsetCh);\n  }\n  function commandMatches(keys, keyMap, context, inputState) {\n    var match,\n      partial = [],\n      full = [];\n    for (var i = 0; i < keyMap.length; i++) {\n      var command = keyMap[i];\n      if (context == 'insert' && command.context != 'insert' || command.context && command.context != context || inputState.operator && command.type == 'action' || !(match = commandMatch(keys, command.keys))) {\n        continue;\n      }\n      if (match == 'partial') {\n        partial.push(command);\n      }\n      if (match == 'full') {\n        full.push(command);\n      }\n    }\n    return {\n      partial: partial.length && partial,\n      full: full.length && full\n    };\n  }\n  function commandMatch(pressed, mapped) {\n    if (mapped.slice(-11) == '<character>') {\n      var prefixLen = mapped.length - 11;\n      var pressedPrefix = pressed.slice(0, prefixLen);\n      var mappedPrefix = mapped.slice(0, prefixLen);\n      return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' : mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n    } else {\n      return pressed == mapped ? 'full' : mapped.indexOf(pressed) == 0 ? 'partial' : false;\n    }\n  }\n  function lastChar(keys) {\n    var match = /^.*(<[^>]+>)$/.exec(keys);\n    var selectedCharacter = match ? match[1] : keys.slice(-1);\n    if (selectedCharacter.length > 1) {\n      switch (selectedCharacter) {\n        case '<CR>':\n          selectedCharacter = '\\n';\n          break;\n        case '<Space>':\n          selectedCharacter = ' ';\n          break;\n        default:\n          selectedCharacter = '';\n          break;\n      }\n    }\n    return selectedCharacter;\n  }\n  function repeatFn(cm, fn, repeat) {\n    return function () {\n      for (var i = 0; i < repeat; i++) {\n        fn(cm);\n      }\n    };\n  }\n  function copyCursor(cur) {\n    return new Pos(cur.line, cur.ch);\n  }\n  function cursorEqual(cur1, cur2) {\n    return cur1.ch == cur2.ch && cur1.line == cur2.line;\n  }\n  function cursorIsBefore(cur1, cur2) {\n    if (cur1.line < cur2.line) {\n      return true;\n    }\n    if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n      return true;\n    }\n    return false;\n  }\n  function cursorMin(cur1, cur2) {\n    if (arguments.length > 2) {\n      cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n    }\n    return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n  }\n  function cursorMax(cur1, cur2) {\n    if (arguments.length > 2) {\n      cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n    }\n    return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n  }\n  function cursorIsBetween(cur1, cur2, cur3) {\n    var cur1before2 = cursorIsBefore(cur1, cur2);\n    var cur2before3 = cursorIsBefore(cur2, cur3);\n    return cur1before2 && cur2before3;\n  }\n  function lineLength(cm, lineNum) {\n    return cm.getLine(lineNum).length;\n  }\n  function trim(s) {\n    if (s.trim) {\n      return s.trim();\n    }\n    return s.replace(/^\\s+|\\s+$/g, '');\n  }\n  function escapeRegex(s) {\n    return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n  }\n  function extendLineToColumn(cm, lineNum, column) {\n    var endCh = lineLength(cm, lineNum);\n    var spaces = new Array(column - endCh + 1).join(' ');\n    cm.setCursor(new Pos(lineNum, endCh));\n    cm.replaceRange(spaces, cm.getCursor());\n  }\n  function selectBlock(cm, selectionEnd) {\n    var selections = [],\n      ranges = cm.listSelections();\n    var head = copyCursor(cm.clipPos(selectionEnd));\n    var isClipped = !cursorEqual(selectionEnd, head);\n    var curHead = cm.getCursor('head');\n    var primIndex = getIndex(ranges, curHead);\n    var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n    var max = ranges.length - 1;\n    var index = max - primIndex > primIndex ? max : 0;\n    var base = ranges[index].anchor;\n    var firstLine = Math.min(base.line, head.line);\n    var lastLine = Math.max(base.line, head.line);\n    var baseCh = base.ch,\n      headCh = head.ch;\n    var dir = ranges[index].head.ch - baseCh;\n    var newDir = headCh - baseCh;\n    if (dir > 0 && newDir <= 0) {\n      baseCh++;\n      if (!isClipped) {\n        headCh--;\n      }\n    } else if (dir < 0 && newDir >= 0) {\n      baseCh--;\n      if (!wasClipped) {\n        headCh++;\n      }\n    } else if (dir < 0 && newDir == -1) {\n      baseCh--;\n      headCh++;\n    }\n    for (var line = firstLine; line <= lastLine; line++) {\n      var range = {\n        anchor: new Pos(line, baseCh),\n        head: new Pos(line, headCh)\n      };\n      selections.push(range);\n    }\n    cm.setSelections(selections);\n    selectionEnd.ch = headCh;\n    base.ch = baseCh;\n    return base;\n  }\n  function selectForInsert(cm, head, height) {\n    var sel = [];\n    for (var i = 0; i < height; i++) {\n      var lineHead = offsetCursor(head, i, 0);\n      sel.push({\n        anchor: lineHead,\n        head: lineHead\n      });\n    }\n    cm.setSelections(sel, 0);\n  }\n  function getIndex(ranges, cursor, end) {\n    for (var i = 0; i < ranges.length; i++) {\n      var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n      var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n      if (atAnchor || atHead) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  function getSelectedAreaRange(cm, vim) {\n    var lastSelection = vim.lastSelection;\n    var getCurrentSelectedAreaRange = function () {\n      var selections = cm.listSelections();\n      var start = selections[0];\n      var end = selections[selections.length - 1];\n      var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n      var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n      return [selectionStart, selectionEnd];\n    };\n    var getLastSelectedAreaRange = function () {\n      var selectionStart = cm.getCursor();\n      var selectionEnd = cm.getCursor();\n      var block = lastSelection.visualBlock;\n      if (block) {\n        var width = block.width;\n        var height = block.height;\n        selectionEnd = new Pos(selectionStart.line + height, selectionStart.ch + width);\n        var selections = [];\n        for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n          var anchor = new Pos(i, selectionStart.ch);\n          var head = new Pos(i, selectionEnd.ch);\n          var range = {\n            anchor: anchor,\n            head: head\n          };\n          selections.push(range);\n        }\n        cm.setSelections(selections);\n      } else {\n        var start = lastSelection.anchorMark.find();\n        var end = lastSelection.headMark.find();\n        var line = end.line - start.line;\n        var ch = end.ch - start.ch;\n        selectionEnd = {\n          line: selectionEnd.line + line,\n          ch: line ? selectionEnd.ch : ch + selectionEnd.ch\n        };\n        if (lastSelection.visualLine) {\n          selectionStart = new Pos(selectionStart.line, 0);\n          selectionEnd = new Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n        }\n        cm.setSelection(selectionStart, selectionEnd);\n      }\n      return [selectionStart, selectionEnd];\n    };\n    if (!vim.visualMode) {\n      return getLastSelectedAreaRange();\n    } else {\n      return getCurrentSelectedAreaRange();\n    }\n  }\n  function updateLastSelection(cm, vim) {\n    var anchor = vim.sel.anchor;\n    var head = vim.sel.head;\n    if (vim.lastPastedText) {\n      head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n      vim.lastPastedText = null;\n    }\n    vim.lastSelection = {\n      'anchorMark': cm.setBookmark(anchor),\n      'headMark': cm.setBookmark(head),\n      'anchor': copyCursor(anchor),\n      'head': copyCursor(head),\n      'visualMode': vim.visualMode,\n      'visualLine': vim.visualLine,\n      'visualBlock': vim.visualBlock\n    };\n  }\n  function expandSelection(cm, start, end) {\n    var sel = cm.state.vim.sel;\n    var head = sel.head;\n    var anchor = sel.anchor;\n    var tmp;\n    if (cursorIsBefore(end, start)) {\n      tmp = end;\n      end = start;\n      start = tmp;\n    }\n    if (cursorIsBefore(head, anchor)) {\n      head = cursorMin(start, head);\n      anchor = cursorMax(anchor, end);\n    } else {\n      anchor = cursorMin(start, anchor);\n      head = cursorMax(head, end);\n      head = offsetCursor(head, 0, -1);\n      if (head.ch == -1 && head.line != cm.firstLine()) {\n        head = new Pos(head.line - 1, lineLength(cm, head.line - 1));\n      }\n    }\n    return [anchor, head];\n  }\n  function updateCmSelection(cm, sel, mode) {\n    var vim = cm.state.vim;\n    sel = sel || vim.sel;\n    var mode = mode || vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n    var cmSel = makeCmSelection(cm, sel, mode);\n    cm.setSelections(cmSel.ranges, cmSel.primary);\n  }\n  function makeCmSelection(cm, sel, mode, exclusive) {\n    var head = copyCursor(sel.head);\n    var anchor = copyCursor(sel.anchor);\n    if (mode == 'char') {\n      var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n      var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n      head = offsetCursor(sel.head, 0, headOffset);\n      anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n      return {\n        ranges: [{\n          anchor: anchor,\n          head: head\n        }],\n        primary: 0\n      };\n    } else if (mode == 'line') {\n      if (!cursorIsBefore(sel.head, sel.anchor)) {\n        anchor.ch = 0;\n        var lastLine = cm.lastLine();\n        if (head.line > lastLine) {\n          head.line = lastLine;\n        }\n        head.ch = lineLength(cm, head.line);\n      } else {\n        head.ch = 0;\n        anchor.ch = lineLength(cm, anchor.line);\n      }\n      return {\n        ranges: [{\n          anchor: anchor,\n          head: head\n        }],\n        primary: 0\n      };\n    } else if (mode == 'block') {\n      var top = Math.min(anchor.line, head.line),\n        fromCh = anchor.ch,\n        bottom = Math.max(anchor.line, head.line),\n        toCh = head.ch;\n      if (fromCh < toCh) {\n        toCh += 1;\n      } else {\n        fromCh += 1;\n      }\n      ;\n      var height = bottom - top + 1;\n      var primary = head.line == top ? 0 : height - 1;\n      var ranges = [];\n      for (var i = 0; i < height; i++) {\n        ranges.push({\n          anchor: new Pos(top + i, fromCh),\n          head: new Pos(top + i, toCh)\n        });\n      }\n      return {\n        ranges: ranges,\n        primary: primary\n      };\n    }\n  }\n  function getHead(cm) {\n    var cur = cm.getCursor('head');\n    if (cm.getSelection().length == 1) {\n      cur = cursorMin(cur, cm.getCursor('anchor'));\n    }\n    return cur;\n  }\n  function exitVisualMode(cm, moveHead) {\n    var vim = cm.state.vim;\n    if (moveHead !== false) {\n      cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n    }\n    updateLastSelection(cm, vim);\n    vim.visualMode = false;\n    vim.visualLine = false;\n    vim.visualBlock = false;\n    if (!vim.insertMode) CodeMirror.signal(cm, \"vim-mode-change\", {\n      mode: \"normal\"\n    });\n  }\n  function clipToLine(cm, curStart, curEnd) {\n    var selection = cm.getRange(curStart, curEnd);\n    if (/\\n\\s*$/.test(selection)) {\n      var lines = selection.split('\\n');\n      lines.pop();\n      var line;\n      for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n        curEnd.line--;\n        curEnd.ch = 0;\n      }\n      if (line) {\n        curEnd.line--;\n        curEnd.ch = lineLength(cm, curEnd.line);\n      } else {\n        curEnd.ch = 0;\n      }\n    }\n  }\n  function expandSelectionToLine(_cm, curStart, curEnd) {\n    curStart.ch = 0;\n    curEnd.ch = 0;\n    curEnd.line++;\n  }\n  function findFirstNonWhiteSpaceCharacter(text) {\n    if (!text) {\n      return 0;\n    }\n    var firstNonWS = text.search(/\\S/);\n    return firstNonWS == -1 ? text.length : firstNonWS;\n  }\n  function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {\n    var cur = getHead(cm);\n    var line = cm.getLine(cur.line);\n    var idx = cur.ch;\n    var test = noSymbol ? wordCharTest[0] : bigWordCharTest[0];\n    while (!test(line.charAt(idx))) {\n      idx++;\n      if (idx >= line.length) {\n        return null;\n      }\n    }\n    if (bigWord) {\n      test = bigWordCharTest[0];\n    } else {\n      test = wordCharTest[0];\n      if (!test(line.charAt(idx))) {\n        test = wordCharTest[1];\n      }\n    }\n    var end = idx,\n      start = idx;\n    while (test(line.charAt(end)) && end < line.length) {\n      end++;\n    }\n    while (test(line.charAt(start)) && start >= 0) {\n      start--;\n    }\n    start++;\n    if (inclusive) {\n      var wordEnd = end;\n      while (/\\s/.test(line.charAt(end)) && end < line.length) {\n        end++;\n      }\n      if (wordEnd == end) {\n        var wordStart = start;\n        while (/\\s/.test(line.charAt(start - 1)) && start > 0) {\n          start--;\n        }\n        if (!start) {\n          start = wordStart;\n        }\n      }\n    }\n    return {\n      start: new Pos(cur.line, start),\n      end: new Pos(cur.line, end)\n    };\n  }\n  function expandTagUnderCursor(cm, head, inclusive) {\n    var cur = head;\n    if (!CodeMirror.findMatchingTag || !CodeMirror.findEnclosingTag) {\n      return {\n        start: cur,\n        end: cur\n      };\n    }\n    var tags = CodeMirror.findMatchingTag(cm, head) || CodeMirror.findEnclosingTag(cm, head);\n    if (!tags || !tags.open || !tags.close) {\n      return {\n        start: cur,\n        end: cur\n      };\n    }\n    if (inclusive) {\n      return {\n        start: tags.open.from,\n        end: tags.close.to\n      };\n    }\n    return {\n      start: tags.open.to,\n      end: tags.close.from\n    };\n  }\n  function recordJumpPosition(cm, oldCur, newCur) {\n    if (!cursorEqual(oldCur, newCur)) {\n      vimGlobalState.jumpList.add(cm, oldCur, newCur);\n    }\n  }\n  function recordLastCharacterSearch(increment, args) {\n    vimGlobalState.lastCharacterSearch.increment = increment;\n    vimGlobalState.lastCharacterSearch.forward = args.forward;\n    vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n  }\n  var symbolToMode = {\n    '(': 'bracket',\n    ')': 'bracket',\n    '{': 'bracket',\n    '}': 'bracket',\n    '[': 'section',\n    ']': 'section',\n    '*': 'comment',\n    '/': 'comment',\n    'm': 'method',\n    'M': 'method',\n    '#': 'preprocess'\n  };\n  var findSymbolModes = {\n    bracket: {\n      isComplete: function (state) {\n        if (state.nextCh === state.symb) {\n          state.depth++;\n          if (state.depth >= 1) return true;\n        } else if (state.nextCh === state.reverseSymb) {\n          state.depth--;\n        }\n        return false;\n      }\n    },\n    section: {\n      init: function (state) {\n        state.curMoveThrough = true;\n        state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n      },\n      isComplete: function (state) {\n        return state.index === 0 && state.nextCh === state.symb;\n      }\n    },\n    comment: {\n      isComplete: function (state) {\n        var found = state.lastCh === '*' && state.nextCh === '/';\n        state.lastCh = state.nextCh;\n        return found;\n      }\n    },\n    method: {\n      init: function (state) {\n        state.symb = state.symb === 'm' ? '{' : '}';\n        state.reverseSymb = state.symb === '{' ? '}' : '{';\n      },\n      isComplete: function (state) {\n        if (state.nextCh === state.symb) return true;\n        return false;\n      }\n    },\n    preprocess: {\n      init: function (state) {\n        state.index = 0;\n      },\n      isComplete: function (state) {\n        if (state.nextCh === '#') {\n          var token = state.lineText.match(/^#(\\w+)/)[1];\n          if (token === 'endif') {\n            if (state.forward && state.depth === 0) {\n              return true;\n            }\n            state.depth++;\n          } else if (token === 'if') {\n            if (!state.forward && state.depth === 0) {\n              return true;\n            }\n            state.depth--;\n          }\n          if (token === 'else' && state.depth === 0) return true;\n        }\n        return false;\n      }\n    }\n  };\n  function findSymbol(cm, repeat, forward, symb) {\n    var cur = copyCursor(cm.getCursor());\n    var increment = forward ? 1 : -1;\n    var endLine = forward ? cm.lineCount() : -1;\n    var curCh = cur.ch;\n    var line = cur.line;\n    var lineText = cm.getLine(line);\n    var state = {\n      lineText: lineText,\n      nextCh: lineText.charAt(curCh),\n      lastCh: null,\n      index: curCh,\n      symb: symb,\n      reverseSymb: (forward ? {\n        ')': '(',\n        '}': '{'\n      } : {\n        '(': ')',\n        '{': '}'\n      })[symb],\n      forward: forward,\n      depth: 0,\n      curMoveThrough: false\n    };\n    var mode = symbolToMode[symb];\n    if (!mode) return cur;\n    var init = findSymbolModes[mode].init;\n    var isComplete = findSymbolModes[mode].isComplete;\n    if (init) {\n      init(state);\n    }\n    while (line !== endLine && repeat) {\n      state.index += increment;\n      state.nextCh = state.lineText.charAt(state.index);\n      if (!state.nextCh) {\n        line += increment;\n        state.lineText = cm.getLine(line) || '';\n        if (increment > 0) {\n          state.index = 0;\n        } else {\n          var lineLen = state.lineText.length;\n          state.index = lineLen > 0 ? lineLen - 1 : 0;\n        }\n        state.nextCh = state.lineText.charAt(state.index);\n      }\n      if (isComplete(state)) {\n        cur.line = line;\n        cur.ch = state.index;\n        repeat--;\n      }\n    }\n    if (state.nextCh || state.curMoveThrough) {\n      return new Pos(line, state.index);\n    }\n    return cur;\n  }\n  function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n    var lineNum = cur.line;\n    var pos = cur.ch;\n    var line = cm.getLine(lineNum);\n    var dir = forward ? 1 : -1;\n    var charTests = bigWord ? bigWordCharTest : wordCharTest;\n    if (emptyLineIsWord && line == '') {\n      lineNum += dir;\n      line = cm.getLine(lineNum);\n      if (!isLine(cm, lineNum)) {\n        return null;\n      }\n      pos = forward ? 0 : line.length;\n    }\n    while (true) {\n      if (emptyLineIsWord && line == '') {\n        return {\n          from: 0,\n          to: 0,\n          line: lineNum\n        };\n      }\n      var stop = dir > 0 ? line.length : -1;\n      var wordStart = stop,\n        wordEnd = stop;\n      while (pos != stop) {\n        var foundWord = false;\n        for (var i = 0; i < charTests.length && !foundWord; ++i) {\n          if (charTests[i](line.charAt(pos))) {\n            wordStart = pos;\n            while (pos != stop && charTests[i](line.charAt(pos))) {\n              pos += dir;\n            }\n            wordEnd = pos;\n            foundWord = wordStart != wordEnd;\n            if (wordStart == cur.ch && lineNum == cur.line && wordEnd == wordStart + dir) {\n              continue;\n            } else {\n              return {\n                from: Math.min(wordStart, wordEnd + 1),\n                to: Math.max(wordStart, wordEnd),\n                line: lineNum\n              };\n            }\n          }\n        }\n        if (!foundWord) {\n          pos += dir;\n        }\n      }\n      lineNum += dir;\n      if (!isLine(cm, lineNum)) {\n        return null;\n      }\n      line = cm.getLine(lineNum);\n      pos = dir > 0 ? 0 : line.length;\n    }\n  }\n  function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n    var curStart = copyCursor(cur);\n    var words = [];\n    if (forward && !wordEnd || !forward && wordEnd) {\n      repeat++;\n    }\n    var emptyLineIsWord = !(forward && wordEnd);\n    for (var i = 0; i < repeat; i++) {\n      var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n      if (!word) {\n        var eodCh = lineLength(cm, cm.lastLine());\n        words.push(forward ? {\n          line: cm.lastLine(),\n          from: eodCh,\n          to: eodCh\n        } : {\n          line: 0,\n          from: 0,\n          to: 0\n        });\n        break;\n      }\n      words.push(word);\n      cur = new Pos(word.line, forward ? word.to - 1 : word.from);\n    }\n    var shortCircuit = words.length != repeat;\n    var firstWord = words[0];\n    var lastWord = words.pop();\n    if (forward && !wordEnd) {\n      if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n        lastWord = words.pop();\n      }\n      return new Pos(lastWord.line, lastWord.from);\n    } else if (forward && wordEnd) {\n      return new Pos(lastWord.line, lastWord.to - 1);\n    } else if (!forward && wordEnd) {\n      if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n        lastWord = words.pop();\n      }\n      return new Pos(lastWord.line, lastWord.to);\n    } else {\n      return new Pos(lastWord.line, lastWord.from);\n    }\n  }\n  function moveToEol(cm, head, motionArgs, vim, keepHPos) {\n    var cur = head;\n    var retval = new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n    var end = cm.clipPos(retval);\n    end.ch--;\n    if (!keepHPos) {\n      vim.lastHPos = Infinity;\n      vim.lastHSPos = cm.charCoords(end, 'div').left;\n    }\n    return retval;\n  }\n  function moveToCharacter(cm, repeat, forward, character) {\n    var cur = cm.getCursor();\n    var start = cur.ch;\n    var idx;\n    for (var i = 0; i < repeat; i++) {\n      var line = cm.getLine(cur.line);\n      idx = charIdxInLine(start, line, character, forward, true);\n      if (idx == -1) {\n        return null;\n      }\n      start = idx;\n    }\n    return new Pos(cm.getCursor().line, idx);\n  }\n  function moveToColumn(cm, repeat) {\n    var line = cm.getCursor().line;\n    return clipCursorToContent(cm, new Pos(line, repeat - 1));\n  }\n  function updateMark(cm, vim, markName, pos) {\n    if (!inArray(markName, validMarks)) {\n      return;\n    }\n    if (vim.marks[markName]) {\n      vim.marks[markName].clear();\n    }\n    vim.marks[markName] = cm.setBookmark(pos);\n  }\n  function charIdxInLine(start, line, character, forward, includeChar) {\n    var idx;\n    if (forward) {\n      idx = line.indexOf(character, start + 1);\n      if (idx != -1 && !includeChar) {\n        idx -= 1;\n      }\n    } else {\n      idx = line.lastIndexOf(character, start - 1);\n      if (idx != -1 && !includeChar) {\n        idx += 1;\n      }\n    }\n    return idx;\n  }\n  function findParagraph(cm, head, repeat, dir, inclusive) {\n    var line = head.line;\n    var min = cm.firstLine();\n    var max = cm.lastLine();\n    var start,\n      end,\n      i = line;\n    function isEmpty(i) {\n      return !/\\S/.test(cm.getLine(i));\n    } // ace_patch\n    function isBoundary(i, dir, any) {\n      if (any) {\n        return isEmpty(i) != isEmpty(i + dir);\n      }\n      return !isEmpty(i) && isEmpty(i + dir);\n    }\n    function skipFold(i) {\n      dir = dir > 0 ? 1 : -1;\n      var foldLine = cm.ace.session.getFoldLine(i);\n      if (foldLine) {\n        if (i + dir > foldLine.start.row && i + dir < foldLine.end.row) dir = (dir > 0 ? foldLine.end.row : foldLine.start.row) - i;\n      }\n    }\n    if (dir) {\n      while (min <= i && i <= max && repeat > 0) {\n        skipFold(i);\n        if (isBoundary(i, dir)) {\n          repeat--;\n        }\n        i += dir;\n      }\n      return new Pos(i, 0);\n    }\n    var vim = cm.state.vim;\n    if (vim.visualLine && isBoundary(line, 1, true)) {\n      var anchor = vim.sel.anchor;\n      if (isBoundary(anchor.line, -1, true)) {\n        if (!inclusive || anchor.line != line) {\n          line += 1;\n        }\n      }\n    }\n    var startState = isEmpty(line);\n    for (i = line; i <= max && repeat; i++) {\n      if (isBoundary(i, 1, true)) {\n        if (!inclusive || isEmpty(i) != startState) {\n          repeat--;\n        }\n      }\n    }\n    end = new Pos(i, 0);\n    if (i > max && !startState) {\n      startState = true;\n    } else {\n      inclusive = false;\n    }\n    for (i = line; i > min; i--) {\n      if (!inclusive || isEmpty(i) == startState || i == line) {\n        if (isBoundary(i, -1, true)) {\n          break;\n        }\n      }\n    }\n    start = new Pos(i, 0);\n    return {\n      start: start,\n      end: end\n    };\n  }\n  function getSentence(cm, cur, repeat, dir, inclusive /*includes whitespace*/) {\n    function nextChar(curr) {\n      if (curr.pos + curr.dir < 0 || curr.pos + curr.dir >= curr.line.length) {\n        curr.line = null;\n      } else {\n        curr.pos += curr.dir;\n      }\n    }\n    function forward(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir\n      };\n      if (curr.line === \"\") {\n        return {\n          ln: curr.ln,\n          pos: curr.pos\n        };\n      }\n      var lastSentencePos = curr.pos;\n      nextChar(curr);\n      while (curr.line !== null) {\n        lastSentencePos = curr.pos;\n        if (isEndOfSentenceSymbol(curr.line[curr.pos])) {\n          if (!inclusive) {\n            return {\n              ln: curr.ln,\n              pos: curr.pos + 1\n            };\n          } else {\n            nextChar(curr);\n            while (curr.line !== null) {\n              if (isWhiteSpaceString(curr.line[curr.pos])) {\n                lastSentencePos = curr.pos;\n                nextChar(curr);\n              } else {\n                break;\n              }\n            }\n            return {\n              ln: curr.ln,\n              pos: lastSentencePos + 1\n            };\n          }\n        }\n        nextChar(curr);\n      }\n      return {\n        ln: curr.ln,\n        pos: lastSentencePos + 1\n      };\n    }\n    function reverse(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir\n      };\n      if (curr.line === \"\") {\n        return {\n          ln: curr.ln,\n          pos: curr.pos\n        };\n      }\n      var lastSentencePos = curr.pos;\n      nextChar(curr);\n      while (curr.line !== null) {\n        if (!isWhiteSpaceString(curr.line[curr.pos]) && !isEndOfSentenceSymbol(curr.line[curr.pos])) {\n          lastSentencePos = curr.pos;\n        } else if (isEndOfSentenceSymbol(curr.line[curr.pos])) {\n          if (!inclusive) {\n            return {\n              ln: curr.ln,\n              pos: lastSentencePos\n            };\n          } else {\n            if (isWhiteSpaceString(curr.line[curr.pos + 1])) {\n              return {\n                ln: curr.ln,\n                pos: curr.pos + 1\n              };\n            } else {\n              return {\n                ln: curr.ln,\n                pos: lastSentencePos\n              };\n            }\n          }\n        }\n        nextChar(curr);\n      }\n      curr.line = line;\n      if (inclusive && isWhiteSpaceString(curr.line[curr.pos])) {\n        return {\n          ln: curr.ln,\n          pos: curr.pos\n        };\n      } else {\n        return {\n          ln: curr.ln,\n          pos: lastSentencePos\n        };\n      }\n    }\n    var curr_index = {\n      ln: cur.line,\n      pos: cur.ch\n    };\n    while (repeat > 0) {\n      if (dir < 0) {\n        curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n      } else {\n        curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n      }\n      repeat--;\n    }\n    return new Pos(curr_index.ln, curr_index.pos);\n  }\n  function findSentence(cm, cur, repeat, dir) {\n    function nextChar(cm, idx) {\n      if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {\n        idx.ln += idx.dir;\n        if (!isLine(cm, idx.ln)) {\n          idx.line = null;\n          idx.ln = null;\n          idx.pos = null;\n          return;\n        }\n        idx.line = cm.getLine(idx.ln);\n        idx.pos = idx.dir > 0 ? 0 : idx.line.length - 1;\n      } else {\n        idx.pos += idx.dir;\n      }\n    }\n    function forward(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n      var stop = line === \"\";\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir\n      };\n      var last_valid = {\n        ln: curr.ln,\n        pos: curr.pos\n      };\n      var skip_empty_lines = curr.line === \"\";\n      nextChar(cm, curr);\n      while (curr.line !== null) {\n        last_valid.ln = curr.ln;\n        last_valid.pos = curr.pos;\n        if (curr.line === \"\" && !skip_empty_lines) {\n          return {\n            ln: curr.ln,\n            pos: curr.pos\n          };\n        } else if (stop && curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n          return {\n            ln: curr.ln,\n            pos: curr.pos\n          };\n        } else if (isEndOfSentenceSymbol(curr.line[curr.pos]) && !stop && (curr.pos === curr.line.length - 1 || isWhiteSpaceString(curr.line[curr.pos + 1]))) {\n          stop = true;\n        }\n        nextChar(cm, curr);\n      }\n      var line = cm.getLine(last_valid.ln);\n      last_valid.pos = 0;\n      for (var i = line.length - 1; i >= 0; --i) {\n        if (!isWhiteSpaceString(line[i])) {\n          last_valid.pos = i;\n          break;\n        }\n      }\n      return last_valid;\n    }\n    function reverse(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir\n      };\n      var last_valid = {\n        ln: curr.ln,\n        pos: null\n      };\n      var skip_empty_lines = curr.line === \"\";\n      nextChar(cm, curr);\n      while (curr.line !== null) {\n        if (curr.line === \"\" && !skip_empty_lines) {\n          if (last_valid.pos !== null) {\n            return last_valid;\n          } else {\n            return {\n              ln: curr.ln,\n              pos: curr.pos\n            };\n          }\n        } else if (isEndOfSentenceSymbol(curr.line[curr.pos]) && last_valid.pos !== null && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {\n          return last_valid;\n        } else if (curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n          skip_empty_lines = false;\n          last_valid = {\n            ln: curr.ln,\n            pos: curr.pos\n          };\n        }\n        nextChar(cm, curr);\n      }\n      var line = cm.getLine(last_valid.ln);\n      last_valid.pos = 0;\n      for (var i = 0; i < line.length; ++i) {\n        if (!isWhiteSpaceString(line[i])) {\n          last_valid.pos = i;\n          break;\n        }\n      }\n      return last_valid;\n    }\n    var curr_index = {\n      ln: cur.line,\n      pos: cur.ch\n    };\n    while (repeat > 0) {\n      if (dir < 0) {\n        curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n      } else {\n        curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n      }\n      repeat--;\n    }\n    return new Pos(curr_index.ln, curr_index.pos);\n  }\n  function selectCompanionObject(cm, head, symb, inclusive) {\n    var cur = head,\n      start,\n      end;\n    var bracketRegexp = {\n      '(': /[()]/,\n      ')': /[()]/,\n      '[': /[[\\]]/,\n      ']': /[[\\]]/,\n      '{': /[{}]/,\n      '}': /[{}]/,\n      '<': /[<>]/,\n      '>': /[<>]/\n    }[symb];\n    var openSym = {\n      '(': '(',\n      ')': '(',\n      '[': '[',\n      ']': '[',\n      '{': '{',\n      '}': '{',\n      '<': '<',\n      '>': '<'\n    }[symb];\n    var curChar = cm.getLine(cur.line).charAt(cur.ch);\n    var offset = curChar === openSym ? 1 : 0;\n    start = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), -1, undefined, {\n      'bracketRegex': bracketRegexp\n    });\n    end = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), 1, undefined, {\n      'bracketRegex': bracketRegexp\n    });\n    if (!start || !end) {\n      return {\n        start: cur,\n        end: cur\n      };\n    }\n    start = start.pos;\n    end = end.pos;\n    if (start.line == end.line && start.ch > end.ch || start.line > end.line) {\n      var tmp = start;\n      start = end;\n      end = tmp;\n    }\n    if (inclusive) {\n      end.ch += 1;\n    } else {\n      start.ch += 1;\n    }\n    return {\n      start: start,\n      end: end\n    };\n  }\n  function findBeginningAndEnd(cm, head, symb, inclusive) {\n    var cur = copyCursor(head);\n    var line = cm.getLine(cur.line);\n    var chars = line.split('');\n    var start, end, i, len;\n    var firstIndex = chars.indexOf(symb);\n    if (cur.ch < firstIndex) {\n      cur.ch = firstIndex;\n    } else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n      end = cur.ch; // assign end to the current cursor\n      --cur.ch; // make sure to look backwards\n    }\n\n    if (chars[cur.ch] == symb && !end) {\n      start = cur.ch + 1; // assign start to ahead of the cursor\n    } else {\n      for (i = cur.ch; i > -1 && !start; i--) {\n        if (chars[i] == symb) {\n          start = i + 1;\n        }\n      }\n    }\n    if (start && !end) {\n      for (i = start, len = chars.length; i < len && !end; i++) {\n        if (chars[i] == symb) {\n          end = i;\n        }\n      }\n    }\n    if (!start || !end) {\n      return {\n        start: cur,\n        end: cur\n      };\n    }\n    if (inclusive) {\n      --start;\n      ++end;\n    }\n    return {\n      start: new Pos(cur.line, start),\n      end: new Pos(cur.line, end)\n    };\n  }\n  defineOption('pcre', true, 'boolean');\n  function SearchState() {}\n  SearchState.prototype = {\n    getQuery: function () {\n      return vimGlobalState.query;\n    },\n    setQuery: function (query) {\n      vimGlobalState.query = query;\n    },\n    getOverlay: function () {\n      return this.searchOverlay;\n    },\n    setOverlay: function (overlay) {\n      this.searchOverlay = overlay;\n    },\n    isReversed: function () {\n      return vimGlobalState.isReversed;\n    },\n    setReversed: function (reversed) {\n      vimGlobalState.isReversed = reversed;\n    },\n    getScrollbarAnnotate: function () {\n      return this.annotate;\n    },\n    setScrollbarAnnotate: function (annotate) {\n      this.annotate = annotate;\n    }\n  };\n  function getSearchState(cm) {\n    var vim = cm.state.vim;\n    return vim.searchState_ || (vim.searchState_ = new SearchState());\n  }\n  function splitBySlash(argString) {\n    return splitBySeparator(argString, '/');\n  }\n  function findUnescapedSlashes(argString) {\n    return findUnescapedSeparators(argString, '/');\n  }\n  function splitBySeparator(argString, separator) {\n    var slashes = findUnescapedSeparators(argString, separator) || [];\n    if (!slashes.length) return [];\n    var tokens = [];\n    if (slashes[0] !== 0) return;\n    for (var i = 0; i < slashes.length; i++) {\n      if (typeof slashes[i] == 'number') tokens.push(argString.substring(slashes[i] + 1, slashes[i + 1]));\n    }\n    return tokens;\n  }\n  function findUnescapedSeparators(str, separator) {\n    if (!separator) separator = '/';\n    var escapeNextChar = false;\n    var slashes = [];\n    for (var i = 0; i < str.length; i++) {\n      var c = str.charAt(i);\n      if (!escapeNextChar && c == separator) {\n        slashes.push(i);\n      }\n      escapeNextChar = !escapeNextChar && c == '\\\\';\n    }\n    return slashes;\n  }\n  function translateRegex(str) {\n    var specials = '|(){';\n    var unescape = '}';\n    var escapeNextChar = false;\n    var out = [];\n    for (var i = -1; i < str.length; i++) {\n      var c = str.charAt(i) || '';\n      var n = str.charAt(i + 1) || '';\n      var specialComesNext = n && specials.indexOf(n) != -1;\n      if (escapeNextChar) {\n        if (c !== '\\\\' || !specialComesNext) {\n          out.push(c);\n        }\n        escapeNextChar = false;\n      } else {\n        if (c === '\\\\') {\n          escapeNextChar = true;\n          if (n && unescape.indexOf(n) != -1) {\n            specialComesNext = true;\n          }\n          if (!specialComesNext || n === '\\\\') {\n            out.push(c);\n          }\n        } else {\n          out.push(c);\n          if (specialComesNext && n !== '\\\\') {\n            out.push('\\\\');\n          }\n        }\n      }\n    }\n    return out.join('');\n  }\n  var charUnescapes = {\n    '\\\\n': '\\n',\n    '\\\\r': '\\r',\n    '\\\\t': '\\t'\n  };\n  function translateRegexReplace(str) {\n    var escapeNextChar = false;\n    var out = [];\n    for (var i = -1; i < str.length; i++) {\n      var c = str.charAt(i) || '';\n      var n = str.charAt(i + 1) || '';\n      if (charUnescapes[c + n]) {\n        out.push(charUnescapes[c + n]);\n        i++;\n      } else if (escapeNextChar) {\n        out.push(c);\n        escapeNextChar = false;\n      } else {\n        if (c === '\\\\') {\n          escapeNextChar = true;\n          if (isNumber(n) || n === '$') {\n            out.push('$');\n          } else if (n !== '/' && n !== '\\\\') {\n            out.push('\\\\');\n          }\n        } else {\n          if (c === '$') {\n            out.push('$');\n          }\n          out.push(c);\n          if (n === '/') {\n            out.push('\\\\');\n          }\n        }\n      }\n    }\n    return out.join('');\n  }\n  var unescapes = {\n    '\\\\/': '/',\n    '\\\\\\\\': '\\\\',\n    '\\\\n': '\\n',\n    '\\\\r': '\\r',\n    '\\\\t': '\\t',\n    '\\\\&': '&'\n  };\n  function unescapeRegexReplace(str) {\n    var stream = new CodeMirror.StringStream(str);\n    var output = [];\n    while (!stream.eol()) {\n      while (stream.peek() && stream.peek() != '\\\\') {\n        output.push(stream.next());\n      }\n      var matched = false;\n      for (var matcher in unescapes) {\n        if (stream.match(matcher, true)) {\n          matched = true;\n          output.push(unescapes[matcher]);\n          break;\n        }\n      }\n      if (!matched) {\n        output.push(stream.next());\n      }\n    }\n    return output.join('');\n  }\n  function parseQuery(query, ignoreCase, smartCase) {\n    var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n    lastSearchRegister.setText(query);\n    if (query instanceof RegExp) {\n      return query;\n    }\n    var slashes = findUnescapedSlashes(query);\n    var regexPart;\n    var forceIgnoreCase;\n    if (!slashes.length) {\n      regexPart = query;\n    } else {\n      regexPart = query.substring(0, slashes[0]);\n      var flagsPart = query.substring(slashes[0]);\n      forceIgnoreCase = flagsPart.indexOf('i') != -1;\n    }\n    if (!regexPart) {\n      return null;\n    }\n    if (!getOption('pcre')) {\n      regexPart = translateRegex(regexPart);\n    }\n    if (smartCase) {\n      ignoreCase = /^[^A-Z]*$/.test(regexPart);\n    }\n    var regexp = new RegExp(regexPart, ignoreCase || forceIgnoreCase ? 'im' : 'm');\n    return regexp;\n  }\n  function dom(n) {\n    if (typeof n === 'string') n = document.createElement(n);\n    for (var a, i = 1; i < arguments.length; i++) {\n      if (!(a = arguments[i])) continue;\n      if (typeof a !== 'object') a = document.createTextNode(a);\n      if (a.nodeType) n.appendChild(a);else for (var key in a) {\n        if (!Object.prototype.hasOwnProperty.call(a, key)) continue;\n        if (key[0] === '$') n.style[key.slice(1)] = a[key];else n.setAttribute(key, a[key]);\n      }\n    }\n    return n;\n  }\n  function showConfirm(cm, template) {\n    var pre = dom('div', {\n      $color: 'red',\n      $whiteSpace: 'pre',\n      class: 'cm-vim-message'\n    }, template);\n    if (cm.openNotification) {\n      cm.openNotification(pre, {\n        bottom: true,\n        duration: 5000\n      });\n    } else {\n      alert(pre.innerText);\n    }\n  }\n  function makePrompt(prefix, desc) {\n    return dom(document.createDocumentFragment(), dom('span', {\n      $fontFamily: 'monospace',\n      $whiteSpace: 'pre'\n    }, prefix, dom('input', {\n      type: 'text',\n      autocorrect: 'off',\n      autocapitalize: 'off',\n      spellcheck: 'false'\n    })), desc && dom('span', {\n      $color: '#888'\n    }, desc));\n  }\n  function showPrompt(cm, options) {\n    var template = makePrompt(options.prefix, options.desc);\n    if (cm.openDialog) {\n      cm.openDialog(template, options.onClose, {\n        onKeyDown: options.onKeyDown,\n        onKeyUp: options.onKeyUp,\n        bottom: true,\n        selectValueOnOpen: false,\n        value: options.value\n      });\n    } else {\n      var shortText = '';\n      if (typeof options.prefix != \"string\" && options.prefix) shortText += options.prefix.textContent;\n      if (options.desc) shortText += \" \" + options.desc;\n      options.onClose(prompt(shortText, ''));\n    }\n  }\n  function regexEqual(r1, r2) {\n    if (r1 instanceof RegExp && r2 instanceof RegExp) {\n      var props = ['global', 'multiline', 'ignoreCase', 'source'];\n      for (var i = 0; i < props.length; i++) {\n        var prop = props[i];\n        if (r1[prop] !== r2[prop]) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n    if (!rawQuery) {\n      return;\n    }\n    var state = getSearchState(cm);\n    var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n    if (!query) {\n      return;\n    }\n    highlightSearchMatches(cm, query);\n    if (regexEqual(query, state.getQuery())) {\n      return query;\n    }\n    state.setQuery(query);\n    return query;\n  }\n  function searchOverlay(query) {\n    if (query.source.charAt(0) == '^') {\n      var matchSol = true;\n    }\n    return {\n      token: function (stream) {\n        if (matchSol && !stream.sol()) {\n          stream.skipToEnd();\n          return;\n        }\n        var match = stream.match(query, false);\n        if (match) {\n          if (match[0].length == 0) {\n            stream.next();\n            return 'searching';\n          }\n          if (!stream.sol()) {\n            stream.backUp(1);\n            if (!query.exec(stream.next() + match[0])) {\n              stream.next();\n              return null;\n            }\n          }\n          stream.match(query);\n          return 'searching';\n        }\n        while (!stream.eol()) {\n          stream.next();\n          if (stream.match(query, false)) break;\n        }\n      },\n      query: query\n    };\n  }\n  var highlightTimeout = 0;\n  function highlightSearchMatches(cm, query) {\n    clearTimeout(highlightTimeout);\n    highlightTimeout = setTimeout(function () {\n      if (!cm.state.vim) return;\n      var searchState = getSearchState(cm);\n      var overlay = searchState.getOverlay();\n      if (!overlay || query != overlay.query) {\n        if (overlay) {\n          cm.removeOverlay(overlay);\n        }\n        overlay = searchOverlay(query);\n        cm.addOverlay(overlay);\n        if (cm.showMatchesOnScrollbar) {\n          if (searchState.getScrollbarAnnotate()) {\n            searchState.getScrollbarAnnotate().clear();\n          }\n          searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n        }\n        searchState.setOverlay(overlay);\n      }\n    }, 50);\n  }\n  function findNext(cm, prev, query, repeat) {\n    if (repeat === undefined) {\n      repeat = 1;\n    }\n    return cm.operation(function () {\n      var pos = cm.getCursor();\n      var cursor = cm.getSearchCursor(query, pos);\n      for (var i = 0; i < repeat; i++) {\n        var found = cursor.find(prev);\n        if (i == 0 && found && cursorEqual(cursor.from(), pos)) {\n          var lastEndPos = prev ? cursor.from() : cursor.to();\n          found = cursor.find(prev);\n          if (found && !found[0] && cursorEqual(cursor.from(), lastEndPos)) {\n            if (cm.getLine(lastEndPos.line).length == lastEndPos.ch) found = cursor.find(prev);\n          }\n        }\n        if (!found) {\n          cursor = cm.getSearchCursor(query, prev ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0));\n          if (!cursor.find(prev)) {\n            return;\n          }\n        }\n      }\n      return cursor.from();\n    });\n  }\n  function findNextFromAndToInclusive(cm, prev, query, repeat, vim) {\n    if (repeat === undefined) {\n      repeat = 1;\n    }\n    return cm.operation(function () {\n      var pos = cm.getCursor();\n      var cursor = cm.getSearchCursor(query, pos);\n      var found = cursor.find(!prev);\n      if (!vim.visualMode && found && cursorEqual(cursor.from(), pos)) {\n        cursor.find(!prev);\n      }\n      for (var i = 0; i < repeat; i++) {\n        found = cursor.find(prev);\n        if (!found) {\n          cursor = cm.getSearchCursor(query, prev ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0));\n          if (!cursor.find(prev)) {\n            return;\n          }\n        }\n      }\n      return [cursor.from(), cursor.to()];\n    });\n  }\n  function clearSearchHighlight(cm) {\n    var state = getSearchState(cm);\n    cm.removeOverlay(getSearchState(cm).getOverlay());\n    state.setOverlay(null);\n    if (state.getScrollbarAnnotate()) {\n      state.getScrollbarAnnotate().clear();\n      state.setScrollbarAnnotate(null);\n    }\n  }\n  function isInRange(pos, start, end) {\n    if (typeof pos != 'number') {\n      pos = pos.line;\n    }\n    if (start instanceof Array) {\n      return inArray(pos, start);\n    } else {\n      if (typeof end == 'number') {\n        return pos >= start && pos <= end;\n      } else {\n        return pos == start;\n      }\n    }\n  }\n  function getUserVisibleLines(cm) {\n    var renderer = cm.ace.renderer;\n    return {\n      top: renderer.getFirstFullyVisibleRow(),\n      bottom: renderer.getLastFullyVisibleRow()\n    };\n  }\n  function getMarkPos(cm, vim, markName) {\n    if (markName == '\\'' || markName == '`') {\n      return vimGlobalState.jumpList.find(cm, -1) || new Pos(0, 0);\n    } else if (markName == '.') {\n      return getLastEditPos(cm);\n    }\n    var mark = vim.marks[markName];\n    return mark && mark.find();\n  }\n  function getLastEditPos(cm) {\n    var undoManager = cm.ace.session.$undoManager;\n    if (undoManager && undoManager.$lastDelta) return toCmPos(undoManager.$lastDelta.end);\n  }\n  var ExCommandDispatcher = function () {\n    this.buildCommandMap_();\n  };\n  ExCommandDispatcher.prototype = {\n    processCommand: function (cm, input, opt_params) {\n      var that = this;\n      cm.operation(function () {\n        cm.curOp.isVimOp = true;\n        that._processCommand(cm, input, opt_params);\n      });\n    },\n    _processCommand: function (cm, input, opt_params) {\n      var vim = cm.state.vim;\n      var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n      var previousCommand = commandHistoryRegister.toString();\n      if (vim.visualMode) {\n        exitVisualMode(cm);\n      }\n      var inputStream = new CodeMirror.StringStream(input);\n      commandHistoryRegister.setText(input);\n      var params = opt_params || {};\n      params.input = input;\n      try {\n        this.parseInput_(cm, inputStream, params);\n      } catch (e) {\n        showConfirm(cm, e.toString());\n        throw e;\n      }\n      var command;\n      var commandName;\n      if (!params.commandName) {\n        if (params.line !== undefined) {\n          commandName = 'move';\n        }\n      } else {\n        command = this.matchCommand_(params.commandName);\n        if (command) {\n          commandName = command.name;\n          if (command.excludeFromCommandHistory) {\n            commandHistoryRegister.setText(previousCommand);\n          }\n          this.parseCommandArgs_(inputStream, params, command);\n          if (command.type == 'exToKey') {\n            for (var i = 0; i < command.toKeys.length; i++) {\n              vimApi.handleKey(cm, command.toKeys[i], 'mapping');\n            }\n            return;\n          } else if (command.type == 'exToEx') {\n            this.processCommand(cm, command.toInput);\n            return;\n          }\n        }\n      }\n      if (!commandName) {\n        showConfirm(cm, 'Not an editor command \":' + input + '\"');\n        return;\n      }\n      try {\n        exCommands[commandName](cm, params);\n        if ((!command || !command.possiblyAsync) && params.callback) {\n          params.callback();\n        }\n      } catch (e) {\n        showConfirm(cm, e.toString());\n        throw e;\n      }\n    },\n    parseInput_: function (cm, inputStream, result) {\n      inputStream.eatWhile(':');\n      if (inputStream.eat('%')) {\n        result.line = cm.firstLine();\n        result.lineEnd = cm.lastLine();\n      } else {\n        result.line = this.parseLineSpec_(cm, inputStream);\n        if (result.line !== undefined && inputStream.eat(',')) {\n          result.lineEnd = this.parseLineSpec_(cm, inputStream);\n        }\n      }\n      var commandMatch = inputStream.match(/^(\\w+|!!|@@|[!#&*<=>@~])/);\n      if (commandMatch) {\n        result.commandName = commandMatch[1];\n      } else {\n        result.commandName = inputStream.match(/.*/)[0];\n      }\n      return result;\n    },\n    parseLineSpec_: function (cm, inputStream) {\n      var numberMatch = inputStream.match(/^(\\d+)/);\n      if (numberMatch) {\n        return parseInt(numberMatch[1], 10) - 1;\n      }\n      switch (inputStream.next()) {\n        case '.':\n          return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n        case '$':\n          return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n        case '\\'':\n          var markName = inputStream.next();\n          var markPos = getMarkPos(cm, cm.state.vim, markName);\n          if (!markPos) throw new Error('Mark not set');\n          return this.parseLineSpecOffset_(inputStream, markPos.line);\n        case '-':\n        case '+':\n          inputStream.backUp(1);\n          return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n        default:\n          inputStream.backUp(1);\n          return undefined;\n      }\n    },\n    parseLineSpecOffset_: function (inputStream, line) {\n      var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n      if (offsetMatch) {\n        var offset = parseInt(offsetMatch[2], 10);\n        if (offsetMatch[1] == \"-\") {\n          line -= offset;\n        } else {\n          line += offset;\n        }\n      }\n      return line;\n    },\n    parseCommandArgs_: function (inputStream, params, command) {\n      if (inputStream.eol()) {\n        return;\n      }\n      params.argString = inputStream.match(/.*/)[0];\n      var delim = command.argDelimiter || /\\s+/;\n      var args = trim(params.argString).split(delim);\n      if (args.length && args[0]) {\n        params.args = args;\n      }\n    },\n    matchCommand_: function (commandName) {\n      for (var i = commandName.length; i > 0; i--) {\n        var prefix = commandName.substring(0, i);\n        if (this.commandMap_[prefix]) {\n          var command = this.commandMap_[prefix];\n          if (command.name.indexOf(commandName) === 0) {\n            return command;\n          }\n        }\n      }\n      return null;\n    },\n    buildCommandMap_: function () {\n      this.commandMap_ = {};\n      for (var i = 0; i < defaultExCommandMap.length; i++) {\n        var command = defaultExCommandMap[i];\n        var key = command.shortName || command.name;\n        this.commandMap_[key] = command;\n      }\n    },\n    map: function (lhs, rhs, ctx) {\n      if (lhs != ':' && lhs.charAt(0) == ':') {\n        if (ctx) {\n          throw Error('Mode not supported for ex mappings');\n        }\n        var commandName = lhs.substring(1);\n        if (rhs != ':' && rhs.charAt(0) == ':') {\n          this.commandMap_[commandName] = {\n            name: commandName,\n            type: 'exToEx',\n            toInput: rhs.substring(1),\n            user: true\n          };\n        } else {\n          this.commandMap_[commandName] = {\n            name: commandName,\n            type: 'exToKey',\n            toKeys: rhs,\n            user: true\n          };\n        }\n      } else {\n        if (rhs != ':' && rhs.charAt(0) == ':') {\n          var mapping = {\n            keys: lhs,\n            type: 'keyToEx',\n            exArgs: {\n              input: rhs.substring(1)\n            }\n          };\n          if (ctx) {\n            mapping.context = ctx;\n          }\n          defaultKeymap.unshift(mapping);\n        } else {\n          var mapping = {\n            keys: lhs,\n            type: 'keyToKey',\n            toKeys: rhs\n          };\n          if (ctx) {\n            mapping.context = ctx;\n          }\n          defaultKeymap.unshift(mapping);\n        }\n      }\n    },\n    unmap: function (lhs, ctx) {\n      if (lhs != ':' && lhs.charAt(0) == ':') {\n        if (ctx) {\n          throw Error('Mode not supported for ex mappings');\n        }\n        var commandName = lhs.substring(1);\n        if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n          delete this.commandMap_[commandName];\n          return true;\n        }\n      } else {\n        var keys = lhs;\n        for (var i = 0; i < defaultKeymap.length; i++) {\n          if (keys == defaultKeymap[i].keys && defaultKeymap[i].context === ctx) {\n            defaultKeymap.splice(i, 1);\n            return true;\n          }\n        }\n      }\n    }\n  };\n  var exCommands = {\n    colorscheme: function (cm, params) {\n      if (!params.args || params.args.length < 1) {\n        showConfirm(cm, cm.getOption('theme'));\n        return;\n      }\n      cm.setOption('theme', params.args[0]);\n    },\n    map: function (cm, params, ctx) {\n      var mapArgs = params.args;\n      if (!mapArgs || mapArgs.length < 2) {\n        if (cm) {\n          showConfirm(cm, 'Invalid mapping: ' + params.input);\n        }\n        return;\n      }\n      exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);\n    },\n    imap: function (cm, params) {\n      this.map(cm, params, 'insert');\n    },\n    nmap: function (cm, params) {\n      this.map(cm, params, 'normal');\n    },\n    vmap: function (cm, params) {\n      this.map(cm, params, 'visual');\n    },\n    unmap: function (cm, params, ctx) {\n      var mapArgs = params.args;\n      if (!mapArgs || mapArgs.length < 1 || !exCommandDispatcher.unmap(mapArgs[0], ctx)) {\n        if (cm) {\n          showConfirm(cm, 'No such mapping: ' + params.input);\n        }\n      }\n    },\n    move: function (cm, params) {\n      commandDispatcher.processCommand(cm, cm.state.vim, {\n        type: 'motion',\n        motion: 'moveToLineOrEdgeOfDocument',\n        motionArgs: {\n          forward: false,\n          explicitRepeat: true,\n          linewise: true\n        },\n        repeatOverride: params.line + 1\n      });\n    },\n    set: function (cm, params) {\n      var setArgs = params.args;\n      var setCfg = params.setCfg || {};\n      if (!setArgs || setArgs.length < 1) {\n        if (cm) {\n          showConfirm(cm, 'Invalid mapping: ' + params.input);\n        }\n        return;\n      }\n      var expr = setArgs[0].split('=');\n      var optionName = expr[0];\n      var value = expr[1];\n      var forceGet = false;\n      if (optionName.charAt(optionName.length - 1) == '?') {\n        if (value) {\n          throw Error('Trailing characters: ' + params.argString);\n        }\n        optionName = optionName.substring(0, optionName.length - 1);\n        forceGet = true;\n      }\n      if (value === undefined && optionName.substring(0, 2) == 'no') {\n        optionName = optionName.substring(2);\n        value = false;\n      }\n      var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n      if (optionIsBoolean && value == undefined) {\n        value = true;\n      }\n      if (!optionIsBoolean && value === undefined || forceGet) {\n        var oldValue = getOption(optionName, cm, setCfg);\n        if (oldValue instanceof Error) {\n          showConfirm(cm, oldValue.message);\n        } else if (oldValue === true || oldValue === false) {\n          showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n        } else {\n          showConfirm(cm, '  ' + optionName + '=' + oldValue);\n        }\n      } else {\n        var setOptionReturn = setOption(optionName, value, cm, setCfg);\n        if (setOptionReturn instanceof Error) {\n          showConfirm(cm, setOptionReturn.message);\n        }\n      }\n    },\n    setlocal: function (cm, params) {\n      params.setCfg = {\n        scope: 'local'\n      };\n      this.set(cm, params);\n    },\n    setglobal: function (cm, params) {\n      params.setCfg = {\n        scope: 'global'\n      };\n      this.set(cm, params);\n    },\n    registers: function (cm, params) {\n      var regArgs = params.args;\n      var registers = vimGlobalState.registerController.registers;\n      var regInfo = '----------Registers----------\\n\\n';\n      if (!regArgs) {\n        for (var registerName in registers) {\n          var text = registers[registerName].toString();\n          if (text.length) {\n            regInfo += '\"' + registerName + '    ' + text + '\\n';\n          }\n        }\n      } else {\n        var registerName;\n        regArgs = regArgs.join('');\n        for (var i = 0; i < regArgs.length; i++) {\n          registerName = regArgs.charAt(i);\n          if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n            continue;\n          }\n          var register = registers[registerName] || new Register();\n          regInfo += '\"' + registerName + '    ' + register.toString() + '\\n';\n        }\n      }\n      showConfirm(cm, regInfo);\n    },\n    sort: function (cm, params) {\n      var reverse, ignoreCase, unique, number, pattern;\n      function parseArgs() {\n        if (params.argString) {\n          var args = new CodeMirror.StringStream(params.argString);\n          if (args.eat('!')) {\n            reverse = true;\n          }\n          if (args.eol()) {\n            return;\n          }\n          if (!args.eatSpace()) {\n            return 'Invalid arguments';\n          }\n          var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n          if (!opts && !args.eol()) {\n            return 'Invalid arguments';\n          }\n          if (opts[1]) {\n            ignoreCase = opts[1].indexOf('i') != -1;\n            unique = opts[1].indexOf('u') != -1;\n            var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;\n            var hex = opts[1].indexOf('x') != -1 && 1;\n            var octal = opts[1].indexOf('o') != -1 && 1;\n            if (decimal + hex + octal > 1) {\n              return 'Invalid arguments';\n            }\n            number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n          }\n          if (opts[2]) {\n            pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n          }\n        }\n      }\n      var err = parseArgs();\n      if (err) {\n        showConfirm(cm, err + ': ' + params.argString);\n        return;\n      }\n      var lineStart = params.line || cm.firstLine();\n      var lineEnd = params.lineEnd || params.line || cm.lastLine();\n      if (lineStart == lineEnd) {\n        return;\n      }\n      var curStart = new Pos(lineStart, 0);\n      var curEnd = new Pos(lineEnd, lineLength(cm, lineEnd));\n      var text = cm.getRange(curStart, curEnd).split('\\n');\n      var numberRegex = pattern ? pattern : number == 'decimal' ? /(-?)([\\d]+)/ : number == 'hex' ? /(-?)(?:0x)?([0-9a-f]+)/i : number == 'octal' ? /([0-7]+)/ : null;\n      var radix = number == 'decimal' ? 10 : number == 'hex' ? 16 : number == 'octal' ? 8 : null;\n      var numPart = [],\n        textPart = [];\n      if (number || pattern) {\n        for (var i = 0; i < text.length; i++) {\n          var matchPart = pattern ? text[i].match(pattern) : null;\n          if (matchPart && matchPart[0] != '') {\n            numPart.push(matchPart);\n          } else if (!pattern && numberRegex.exec(text[i])) {\n            numPart.push(text[i]);\n          } else {\n            textPart.push(text[i]);\n          }\n        }\n      } else {\n        textPart = text;\n      }\n      function compareFn(a, b) {\n        if (reverse) {\n          var tmp;\n          tmp = a;\n          a = b;\n          b = tmp;\n        }\n        if (ignoreCase) {\n          a = a.toLowerCase();\n          b = b.toLowerCase();\n        }\n        var anum = number && numberRegex.exec(a);\n        var bnum = number && numberRegex.exec(b);\n        if (!anum) {\n          return a < b ? -1 : 1;\n        }\n        anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n        bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n        return anum - bnum;\n      }\n      function comparePatternFn(a, b) {\n        if (reverse) {\n          var tmp;\n          tmp = a;\n          a = b;\n          b = tmp;\n        }\n        if (ignoreCase) {\n          a[0] = a[0].toLowerCase();\n          b[0] = b[0].toLowerCase();\n        }\n        return a[0] < b[0] ? -1 : 1;\n      }\n      numPart.sort(pattern ? comparePatternFn : compareFn);\n      if (pattern) {\n        for (var i = 0; i < numPart.length; i++) {\n          numPart[i] = numPart[i].input;\n        }\n      } else if (!number) {\n        textPart.sort(compareFn);\n      }\n      text = !reverse ? textPart.concat(numPart) : numPart.concat(textPart);\n      if (unique) {\n        // Remove duplicate lines\n        var textOld = text;\n        var lastLine;\n        text = [];\n        for (var i = 0; i < textOld.length; i++) {\n          if (textOld[i] != lastLine) {\n            text.push(textOld[i]);\n          }\n          lastLine = textOld[i];\n        }\n      }\n      cm.replaceRange(text.join('\\n'), curStart, curEnd);\n    },\n    vglobal: function (cm, params) {\n      this.global(cm, params);\n    },\n    global: function (cm, params) {\n      var argString = params.argString;\n      if (!argString) {\n        showConfirm(cm, 'Regular Expression missing from global');\n        return;\n      }\n      var inverted = params.commandName[0] === 'v';\n      var lineStart = params.line !== undefined ? params.line : cm.firstLine();\n      var lineEnd = params.lineEnd || params.line || cm.lastLine();\n      var tokens = splitBySlash(argString);\n      var regexPart = argString,\n        cmd;\n      if (tokens.length) {\n        regexPart = tokens[0];\n        cmd = tokens.slice(1, tokens.length).join('/');\n      }\n      if (regexPart) {\n        try {\n          updateSearchQuery(cm, regexPart, true /** ignoreCase */, true /** smartCase */);\n        } catch (e) {\n          showConfirm(cm, 'Invalid regex: ' + regexPart);\n          return;\n        }\n      }\n      var query = getSearchState(cm).getQuery();\n      var matchedLines = [];\n      for (var i = lineStart; i <= lineEnd; i++) {\n        var line = cm.getLineHandle(i);\n        var matched = query.test(line.text);\n        if (matched !== inverted) {\n          matchedLines.push(cmd ? line : line.text);\n        }\n      }\n      if (!cmd) {\n        showConfirm(cm, matchedLines.join('\\n'));\n        return;\n      }\n      var index = 0;\n      var nextCommand = function () {\n        if (index < matchedLines.length) {\n          var line = matchedLines[index++];\n          var lineNum = cm.getLineNumber(line);\n          if (lineNum == null) {\n            nextCommand();\n            return;\n          }\n          var command = lineNum + 1 + cmd;\n          exCommandDispatcher.processCommand(cm, command, {\n            callback: nextCommand\n          });\n        }\n      };\n      nextCommand();\n    },\n    substitute: function (cm, params) {\n      if (!cm.getSearchCursor) {\n        throw new Error('Search feature not available. Requires searchcursor.js or ' + 'any other getSearchCursor implementation.');\n      }\n      var argString = params.argString;\n      var tokens = argString ? splitBySeparator(argString, argString[0]) : [];\n      var regexPart,\n        replacePart = '',\n        trailing,\n        flagsPart,\n        count;\n      var confirm = false; // Whether to confirm each replace.\n      var global = false; // True to replace all instances on a line, false to replace only 1.\n      if (tokens.length) {\n        regexPart = tokens[0];\n        if (getOption('pcre') && regexPart !== '') {\n          regexPart = new RegExp(regexPart).source; //normalize not escaped characters\n        }\n\n        replacePart = tokens[1];\n        if (replacePart !== undefined) {\n          if (getOption('pcre')) {\n            replacePart = unescapeRegexReplace(replacePart.replace(/([^\\\\])&/g, \"$1$$&\"));\n          } else {\n            replacePart = translateRegexReplace(replacePart);\n          }\n          vimGlobalState.lastSubstituteReplacePart = replacePart;\n        }\n        trailing = tokens[2] ? tokens[2].split(' ') : [];\n      } else {\n        if (argString && argString.length) {\n          showConfirm(cm, 'Substitutions should be of the form ' + ':s/pattern/replace/');\n          return;\n        }\n      }\n      if (trailing) {\n        flagsPart = trailing[0];\n        count = parseInt(trailing[1]);\n        if (flagsPart) {\n          if (flagsPart.indexOf('c') != -1) {\n            confirm = true;\n          }\n          if (flagsPart.indexOf('g') != -1) {\n            global = true;\n          }\n          if (getOption('pcre')) {\n            regexPart = regexPart + '/' + flagsPart;\n          } else {\n            regexPart = regexPart.replace(/\\//g, \"\\\\/\") + '/' + flagsPart;\n          }\n        }\n      }\n      if (regexPart) {\n        try {\n          updateSearchQuery(cm, regexPart, true /** ignoreCase */, true /** smartCase */);\n        } catch (e) {\n          showConfirm(cm, 'Invalid regex: ' + regexPart);\n          return;\n        }\n      }\n      replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n      if (replacePart === undefined) {\n        showConfirm(cm, 'No previous substitute regular expression');\n        return;\n      }\n      var state = getSearchState(cm);\n      var query = state.getQuery();\n      var lineStart = params.line !== undefined ? params.line : cm.getCursor().line;\n      var lineEnd = params.lineEnd || lineStart;\n      if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n        lineEnd = Infinity;\n      }\n      if (count) {\n        lineStart = lineEnd;\n        lineEnd = lineStart + count - 1;\n      }\n      var startPos = clipCursorToContent(cm, new Pos(lineStart, 0));\n      var cursor = cm.getSearchCursor(query, startPos);\n      doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n    },\n    redo: CodeMirror.commands.redo,\n    undo: CodeMirror.commands.undo,\n    write: function (cm) {\n      if (CodeMirror.commands.save) {\n        CodeMirror.commands.save(cm);\n      } else if (cm.save) {\n        cm.save();\n      }\n    },\n    nohlsearch: function (cm) {\n      clearSearchHighlight(cm);\n    },\n    yank: function (cm) {\n      var cur = copyCursor(cm.getCursor());\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      vimGlobalState.registerController.pushText('0', 'yank', lineText, true, true);\n    },\n    delmarks: function (cm, params) {\n      if (!params.argString || !trim(params.argString)) {\n        showConfirm(cm, 'Argument required');\n        return;\n      }\n      var state = cm.state.vim;\n      var stream = new CodeMirror.StringStream(trim(params.argString));\n      while (!stream.eol()) {\n        stream.eatSpace();\n        var count = stream.pos;\n        if (!stream.match(/[a-zA-Z]/, false)) {\n          showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n          return;\n        }\n        var sym = stream.next();\n        if (stream.match('-', true)) {\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n            return;\n          }\n          var startMark = sym;\n          var finishMark = stream.next();\n          if (isLowerCase(startMark) && isLowerCase(finishMark) || isUpperCase(startMark) && isUpperCase(finishMark)) {\n            var start = startMark.charCodeAt(0);\n            var finish = finishMark.charCodeAt(0);\n            if (start >= finish) {\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n              return;\n            }\n            for (var j = 0; j <= finish - start; j++) {\n              var mark = String.fromCharCode(start + j);\n              delete state.marks[mark];\n            }\n          } else {\n            showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n            return;\n          }\n        } else {\n          delete state.marks[sym];\n        }\n      }\n    }\n  };\n  var exCommandDispatcher = new ExCommandDispatcher();\n  function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query, replaceWith, callback) {\n    cm.state.vim.exMode = true;\n    var done = false;\n    var lastPos, modifiedLineNumber, joined;\n    function replaceAll() {\n      cm.operation(function () {\n        while (!done) {\n          replace();\n          next();\n        }\n        stop();\n      });\n    }\n    function replace() {\n      var text = cm.getRange(searchCursor.from(), searchCursor.to());\n      var newText = text.replace(query, replaceWith);\n      var unmodifiedLineNumber = searchCursor.to().line;\n      searchCursor.replace(newText);\n      modifiedLineNumber = searchCursor.to().line;\n      lineEnd += modifiedLineNumber - unmodifiedLineNumber;\n      joined = modifiedLineNumber < unmodifiedLineNumber;\n    }\n    function findNextValidMatch() {\n      var lastMatchTo = lastPos && copyCursor(searchCursor.to());\n      var match = searchCursor.findNext();\n      if (match && !match[0] && lastMatchTo && cursorEqual(searchCursor.from(), lastMatchTo)) {\n        match = searchCursor.findNext();\n      }\n      return match;\n    }\n    function next() {\n      while (findNextValidMatch() && isInRange(searchCursor.from(), lineStart, lineEnd)) {\n        if (!global && searchCursor.from().line == modifiedLineNumber && !joined) {\n          continue;\n        }\n        cm.scrollIntoView(searchCursor.from(), 30);\n        cm.setSelection(searchCursor.from(), searchCursor.to());\n        lastPos = searchCursor.from();\n        done = false;\n        return;\n      }\n      done = true;\n    }\n    function stop(close) {\n      if (close) {\n        close();\n      }\n      cm.focus();\n      if (lastPos) {\n        cm.setCursor(lastPos);\n        var vim = cm.state.vim;\n        vim.exMode = false;\n        vim.lastHPos = vim.lastHSPos = lastPos.ch;\n      }\n      if (callback) {\n        callback();\n      }\n    }\n    function onPromptKeyDown(e, _value, close) {\n      CodeMirror.e_stop(e);\n      var keyName = CodeMirror.keyName(e);\n      switch (keyName) {\n        case 'Y':\n          replace();\n          next();\n          break;\n        case 'N':\n          next();\n          break;\n        case 'A':\n          var savedCallback = callback;\n          callback = undefined;\n          cm.operation(replaceAll);\n          callback = savedCallback;\n          break;\n        case 'L':\n          replace();\n        case 'Q':\n        case 'Esc':\n        case 'Ctrl-C':\n        case 'Ctrl-[':\n          stop(close);\n          break;\n      }\n      if (done) {\n        stop(close);\n      }\n      return true;\n    }\n    next();\n    if (done) {\n      showConfirm(cm, 'No matches for ' + query.source);\n      return;\n    }\n    if (!confirm) {\n      replaceAll();\n      if (callback) {\n        callback();\n      }\n      return;\n    }\n    showPrompt(cm, {\n      prefix: dom('span', 'replace with ', dom('strong', replaceWith), ' (y/n/a/q/l)'),\n      onKeyDown: onPromptKeyDown\n    });\n  }\n  CodeMirror.keyMap.vim = {\n    attach: attachVimMap,\n    detach: detachVimMap,\n    call: cmKey\n  };\n  function exitInsertMode(cm) {\n    var vim = cm.state.vim;\n    var macroModeState = vimGlobalState.macroModeState;\n    var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n    var isPlaying = macroModeState.isPlaying;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    if (!isPlaying) {\n      cm.off('change', onChange);\n      CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n    }\n    if (!isPlaying && vim.insertModeRepeat > 1) {\n      repeatLastEdit(cm, vim, vim.insertModeRepeat - 1, true /** repeatForInsert */);\n      vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n    }\n    delete vim.insertModeRepeat;\n    vim.insertMode = false;\n    cm.setCursor(cm.getCursor().line, cm.getCursor().ch - 1);\n    cm.setOption('keyMap', 'vim');\n    cm.setOption('disableInput', true);\n    cm.toggleOverwrite(false); // exit replace mode if we were in it.\n    insertModeChangeRegister.setText(lastChange.changes.join(''));\n    CodeMirror.signal(cm, \"vim-mode-change\", {\n      mode: \"normal\"\n    });\n    if (macroModeState.isRecording) {\n      logInsertModeChange(macroModeState);\n    }\n  }\n  function _mapCommand(command) {\n    defaultKeymap.unshift(command);\n  }\n  function mapCommand(keys, type, name, args, extra) {\n    var command = {\n      keys: keys,\n      type: type\n    };\n    command[type] = name;\n    command[type + \"Args\"] = args;\n    for (var key in extra) command[key] = extra[key];\n    _mapCommand(command);\n  }\n  defineOption('insertModeEscKeysTimeout', 200, 'number');\n  CodeMirror.keyMap['vim-insert'] = {\n    fallthrough: ['default'],\n    attach: attachVimMap,\n    detach: detachVimMap,\n    call: cmKey\n  };\n  CodeMirror.keyMap['vim-replace'] = {\n    'Backspace': 'goCharLeft',\n    fallthrough: ['vim-insert'],\n    attach: attachVimMap,\n    detach: detachVimMap,\n    call: cmKey\n  };\n  function executeMacroRegister(cm, vim, macroModeState, registerName) {\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (registerName == ':') {\n      if (register.keyBuffer[0]) {\n        exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n      }\n      macroModeState.isPlaying = false;\n      return;\n    }\n    var keyBuffer = register.keyBuffer;\n    var imc = 0;\n    macroModeState.isPlaying = true;\n    macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n    for (var i = 0; i < keyBuffer.length; i++) {\n      var text = keyBuffer[i];\n      var match, key;\n      while (text) {\n        match = /<\\w+-.+?>|<\\w+>|./.exec(text);\n        key = match[0];\n        text = text.substring(match.index + key.length);\n        vimApi.handleKey(cm, key, 'macro');\n        if (vim.insertMode) {\n          var changes = register.insertModeChanges[imc++].changes;\n          vimGlobalState.macroModeState.lastInsertModeChanges.changes = changes;\n          repeatInsertModeChanges(cm, changes, 1);\n          exitInsertMode(cm);\n        }\n      }\n    }\n    macroModeState.isPlaying = false;\n  }\n  function logKey(macroModeState, key) {\n    if (macroModeState.isPlaying) {\n      return;\n    }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register) {\n      register.pushText(key);\n    }\n  }\n  function logInsertModeChange(macroModeState) {\n    if (macroModeState.isPlaying) {\n      return;\n    }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register && register.pushInsertModeChanges) {\n      register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n    }\n  }\n  function logSearchQuery(macroModeState, query) {\n    if (macroModeState.isPlaying) {\n      return;\n    }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register && register.pushSearchQuery) {\n      register.pushSearchQuery(query);\n    }\n  }\n  function onChange(cm, changeObj) {\n    var macroModeState = vimGlobalState.macroModeState;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    if (!macroModeState.isPlaying) {\n      while (changeObj) {\n        lastChange.expectCursorActivityForChange = true;\n        if (lastChange.ignoreCount > 1) {\n          lastChange.ignoreCount--;\n        } else if (changeObj.origin == '+input' || changeObj.origin == 'paste' || changeObj.origin === undefined /* only in testing */) {\n          var selectionCount = cm.listSelections().length;\n          if (selectionCount > 1) lastChange.ignoreCount = selectionCount;\n          var text = changeObj.text.join('\\n');\n          if (lastChange.maybeReset) {\n            lastChange.changes = [];\n            lastChange.maybeReset = false;\n          }\n          if (text) {\n            if (cm.state.overwrite && !/\\n/.test(text)) {\n              lastChange.changes.push([text]);\n            } else {\n              lastChange.changes.push(text);\n            }\n          }\n        }\n        changeObj = changeObj.next;\n      }\n    }\n  }\n  function onCursorActivity(cm) {\n    var vim = cm.state.vim;\n    if (vim.insertMode) {\n      var macroModeState = vimGlobalState.macroModeState;\n      if (macroModeState.isPlaying) {\n        return;\n      }\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (lastChange.expectCursorActivityForChange) {\n        lastChange.expectCursorActivityForChange = false;\n      } else {\n        lastChange.maybeReset = true;\n      }\n    } else if (!cm.curOp.isVimOp) {\n      handleExternalSelection(cm, vim);\n    }\n  }\n  function handleExternalSelection(cm, vim, keepHPos) {\n    var anchor = cm.getCursor('anchor');\n    var head = cm.getCursor('head');\n    if (vim.visualMode && !cm.somethingSelected()) {\n      exitVisualMode(cm, false);\n    } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n      vim.visualMode = true;\n      vim.visualLine = false;\n      CodeMirror.signal(cm, \"vim-mode-change\", {\n        mode: \"visual\"\n      });\n    }\n    if (vim.visualMode) {\n      var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n      var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n      head = offsetCursor(head, 0, headOffset);\n      anchor = offsetCursor(anchor, 0, anchorOffset);\n      vim.sel = {\n        anchor: anchor,\n        head: head\n      };\n      updateMark(cm, vim, '<', cursorMin(head, anchor));\n      updateMark(cm, vim, '>', cursorMax(head, anchor));\n    } else if (!vim.insertMode && !keepHPos) {\n      vim.lastHPos = cm.getCursor().ch;\n    }\n  }\n  function InsertModeKey(keyName) {\n    this.keyName = keyName;\n  }\n  function onKeyEventTargetKeyDown(e) {\n    var macroModeState = vimGlobalState.macroModeState;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    var keyName = CodeMirror.keyName(e);\n    if (!keyName) {\n      return;\n    }\n    function onKeyFound() {\n      if (lastChange.maybeReset) {\n        lastChange.changes = [];\n        lastChange.maybeReset = false;\n      }\n      lastChange.changes.push(new InsertModeKey(keyName));\n      return true;\n    }\n    if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n      CodeMirror.lookupKey(keyName, 'vim-insert', onKeyFound);\n    }\n  }\n  function repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n    var macroModeState = vimGlobalState.macroModeState;\n    macroModeState.isPlaying = true;\n    var isAction = !!vim.lastEditActionCommand;\n    var cachedInputState = vim.inputState;\n    function repeatCommand() {\n      if (isAction) {\n        commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n      } else {\n        commandDispatcher.evalInput(cm, vim);\n      }\n    }\n    function repeatInsert(repeat) {\n      if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n        repeat = !vim.lastEditActionCommand ? 1 : repeat;\n        var changeObject = macroModeState.lastInsertModeChanges;\n        repeatInsertModeChanges(cm, changeObject.changes, repeat);\n      }\n    }\n    vim.inputState = vim.lastEditInputState;\n    if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n      for (var i = 0; i < repeat; i++) {\n        repeatCommand();\n        repeatInsert(1);\n      }\n    } else {\n      if (!repeatForInsert) {\n        repeatCommand();\n      }\n      repeatInsert(repeat);\n    }\n    vim.inputState = cachedInputState;\n    if (vim.insertMode && !repeatForInsert) {\n      exitInsertMode(cm);\n    }\n    macroModeState.isPlaying = false;\n  }\n  function repeatInsertModeChanges(cm, changes, repeat) {\n    function keyHandler(binding) {\n      if (typeof binding == 'string') {\n        CodeMirror.commands[binding](cm);\n      } else {\n        binding(cm);\n      }\n      return true;\n    }\n    var head = cm.getCursor('head');\n    var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;\n    if (visualBlock) {\n      selectForInsert(cm, head, visualBlock + 1);\n      repeat = cm.listSelections().length;\n      cm.setCursor(head);\n    }\n    for (var i = 0; i < repeat; i++) {\n      if (visualBlock) {\n        cm.setCursor(offsetCursor(head, i, 0));\n      }\n      for (var j = 0; j < changes.length; j++) {\n        var change = changes[j];\n        if (change instanceof InsertModeKey) {\n          CodeMirror.lookupKey(change.keyName, 'vim-insert', keyHandler);\n        } else if (typeof change == \"string\") {\n          cm.replaceSelection(change);\n        } else {\n          var start = cm.getCursor();\n          var end = offsetCursor(start, 0, change[0].length);\n          cm.replaceRange(change[0], start, end);\n          cm.setCursor(end);\n        }\n      }\n    }\n    if (visualBlock) {\n      cm.setCursor(offsetCursor(head, 0, 1));\n    }\n  }\n  resetVimGlobalState();\n  CodeMirror.Vim = vimApi;\n  var specialKey = {\n    'return': 'CR',\n    backspace: 'BS',\n    'delete': 'Del',\n    esc: 'Esc',\n    left: 'Left',\n    right: 'Right',\n    up: 'Up',\n    down: 'Down',\n    space: 'Space',\n    insert: 'Ins',\n    home: 'Home',\n    end: 'End',\n    pageup: 'PageUp',\n    pagedown: 'PageDown',\n    enter: 'CR'\n  };\n  function lookupKey(hashId, key, e) {\n    if (key.length > 1 && key[0] == \"n\") {\n      key = key.replace(\"numpad\", \"\");\n    }\n    key = specialKey[key] || key;\n    var name = '';\n    if (e.ctrlKey) {\n      name += 'C-';\n    }\n    if (e.altKey) {\n      name += 'A-';\n    }\n    if ((name || key.length > 1) && e.shiftKey) {\n      name += 'S-';\n    }\n    name += key;\n    if (name.length > 1) {\n      name = '<' + name + '>';\n    }\n    return name;\n  }\n  var handleKey = vimApi.handleKey.bind(vimApi);\n  vimApi.handleKey = function (cm, key, origin) {\n    return cm.operation(function () {\n      return handleKey(cm, key, origin);\n    }, true);\n  };\n  function cloneVimState(state) {\n    var n = new state.constructor();\n    Object.keys(state).forEach(function (key) {\n      var o = state[key];\n      if (Array.isArray(o)) o = o.slice();else if (o && typeof o == \"object\" && o.constructor != Object) o = cloneVimState(o);\n      n[key] = o;\n    });\n    if (state.sel) {\n      n.sel = {\n        head: state.sel.head && copyCursor(state.sel.head),\n        anchor: state.sel.anchor && copyCursor(state.sel.anchor)\n      };\n    }\n    return n;\n  }\n  function multiSelectHandleKey(cm, key, origin) {\n    var isHandled = false;\n    var vim = vimApi.maybeInitVimState_(cm);\n    var visualBlock = vim.visualBlock || vim.wasInVisualBlock;\n    var wasMultiselect = cm.ace.inMultiSelectMode;\n    if (vim.wasInVisualBlock && !wasMultiselect) {\n      vim.wasInVisualBlock = false;\n    } else if (wasMultiselect && vim.visualBlock) {\n      vim.wasInVisualBlock = true;\n    }\n    if (key == '<Esc>' && !vim.insertMode && !vim.visualMode && wasMultiselect) {\n      cm.ace.exitMultiSelectMode();\n    } else if (visualBlock || !wasMultiselect || cm.ace.inVirtualSelectionMode) {\n      isHandled = vimApi.handleKey(cm, key, origin);\n    } else {\n      var old = cloneVimState(vim);\n      cm.operation(function () {\n        cm.ace.forEachSelection(function () {\n          var sel = cm.ace.selection;\n          cm.state.vim.lastHPos = sel.$desiredColumn == null ? sel.lead.column : sel.$desiredColumn;\n          var head = cm.getCursor(\"head\");\n          var anchor = cm.getCursor(\"anchor\");\n          var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n          var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n          head = offsetCursor(head, 0, headOffset);\n          anchor = offsetCursor(anchor, 0, anchorOffset);\n          cm.state.vim.sel.head = head;\n          cm.state.vim.sel.anchor = anchor;\n          isHandled = handleKey(cm, key, origin);\n          sel.$desiredColumn = cm.state.vim.lastHPos == -1 ? null : cm.state.vim.lastHPos;\n          if (cm.virtualSelectionMode()) {\n            cm.state.vim = cloneVimState(old);\n          }\n        });\n        if (cm.curOp.cursorActivity && !isHandled) cm.curOp.cursorActivity = false;\n      }, true);\n    }\n    if (isHandled && !vim.visualMode && !vim.insert && vim.visualMode != cm.somethingSelected()) {\n      handleExternalSelection(cm, vim, true);\n    }\n    return isHandled;\n  }\n  exports.CodeMirror = CodeMirror;\n  var getVim = vimApi.maybeInitVimState_;\n  exports.handler = {\n    $id: \"ace/keyboard/vim\",\n    drawCursor: function (element, pixelPos, config, sel, session) {\n      var vim = this.state.vim || {};\n      var w = config.characterWidth;\n      var h = config.lineHeight;\n      var top = pixelPos.top;\n      var left = pixelPos.left;\n      if (!vim.insertMode) {\n        var isbackwards = !sel.cursor ? session.selection.isBackwards() || session.selection.isEmpty() : Range.comparePoints(sel.cursor, sel.start) <= 0;\n        if (!isbackwards && left > w) left -= w;\n      }\n      if (!vim.insertMode && vim.status) {\n        h = h / 2;\n        top += h;\n      }\n      domLib.translate(element, left, top);\n      domLib.setStyle(element.style, \"width\", w + \"px\");\n      domLib.setStyle(element.style, \"height\", h + \"px\");\n    },\n    $getDirectionForHighlight: function (editor) {\n      var cm = editor.state.cm;\n      var vim = getVim(cm);\n      if (!vim.insertMode) {\n        return editor.session.selection.isBackwards() || editor.session.selection.isEmpty();\n      }\n    },\n    handleKeyboard: function (data, hashId, key, keyCode, e) {\n      var editor = data.editor;\n      var cm = editor.state.cm;\n      var vim = getVim(cm);\n      if (keyCode == -1) return;\n      if (!vim.insertMode) {\n        if (hashId == -1) {\n          if (key.charCodeAt(0) > 0xFF) {\n            if (data.inputKey) {\n              key = data.inputKey;\n              if (key && data.inputHash == 4) key = key.toUpperCase();\n            }\n          }\n          data.inputChar = key;\n        } else if (hashId == 4 || hashId == 0) {\n          if (data.inputKey == key && data.inputHash == hashId && data.inputChar) {\n            key = data.inputChar;\n            hashId = -1;\n          } else {\n            data.inputChar = null;\n            data.inputKey = key;\n            data.inputHash = hashId;\n          }\n        } else {\n          data.inputChar = data.inputKey = null;\n        }\n      }\n      if (cm.state.overwrite && vim.insertMode && key == \"backspace\" && hashId == 0) {\n        return {\n          command: \"gotoleft\"\n        };\n      }\n      if (key == \"c\" && hashId == 1) {\n        // key == \"ctrl-c\"\n        if (!useragent.isMac && editor.getCopyText()) {\n          editor.once(\"copy\", function () {\n            if (vim.insertMode) editor.selection.clearSelection();else cm.operation(function () {\n              exitVisualMode(cm);\n            });\n          });\n          return {\n            command: \"null\",\n            passEvent: true\n          };\n        }\n      }\n      if (key == \"esc\" && !vim.insertMode && !vim.visualMode && !cm.ace.inMultiSelectMode) {\n        var searchState = getSearchState(cm);\n        var overlay = searchState.getOverlay();\n        if (overlay) cm.removeOverlay(overlay);\n      }\n      if (hashId == -1 || hashId & 1 || hashId === 0 && key.length > 1) {\n        var insertMode = vim.insertMode;\n        var name = lookupKey(hashId, key, e || {});\n        if (vim.status == null) vim.status = \"\";\n        var isHandled = multiSelectHandleKey(cm, name, 'user');\n        vim = getVim(cm); // may be changed by multiSelectHandleKey\n        if (isHandled && vim.status != null) vim.status += name;else if (vim.status == null) vim.status = \"\";\n        cm._signal(\"changeStatus\");\n        if (!isHandled && (hashId != -1 || insertMode)) return;\n        return {\n          command: \"null\",\n          passEvent: !isHandled\n        };\n      }\n    },\n    attach: function (editor) {\n      if (!editor.state) editor.state = {};\n      var cm = new CodeMirror(editor);\n      editor.state.cm = cm;\n      editor.$vimModeHandler = this;\n      CodeMirror.keyMap.vim.attach(cm);\n      getVim(cm).status = null;\n      cm.on('vim-command-done', function () {\n        if (cm.virtualSelectionMode()) return;\n        getVim(cm).status = null;\n        cm.ace._signal(\"changeStatus\");\n        cm.ace.session.markUndoGroup();\n      });\n      cm.on(\"changeStatus\", function () {\n        cm.ace.renderer.updateCursor();\n        cm.ace._signal(\"changeStatus\");\n      });\n      cm.on(\"vim-mode-change\", function () {\n        if (cm.virtualSelectionMode()) return;\n        updateInputMode();\n        cm._signal(\"changeStatus\");\n      });\n      function updateInputMode() {\n        var isIntsert = getVim(cm).insertMode;\n        cm.ace.renderer.setStyle(\"normal-mode\", !isIntsert);\n        editor.textInput.setCommandMode(!isIntsert);\n        editor.renderer.$keepTextAreaAtCursor = isIntsert;\n        editor.renderer.$blockCursor = !isIntsert;\n      }\n      updateInputMode();\n      editor.renderer.$cursorLayer.drawCursor = this.drawCursor.bind(cm);\n    },\n    detach: function (editor) {\n      var cm = editor.state.cm;\n      CodeMirror.keyMap.vim.detach(cm);\n      cm.destroy();\n      editor.state.cm = null;\n      editor.$vimModeHandler = null;\n      editor.renderer.$cursorLayer.drawCursor = null;\n      editor.renderer.setStyle(\"normal-mode\", false);\n      editor.textInput.setCommandMode(false);\n      editor.renderer.$keepTextAreaAtCursor = true;\n    },\n    getStatusText: function (editor) {\n      var cm = editor.state.cm;\n      var vim = getVim(cm);\n      if (vim.insertMode) return \"INSERT\";\n      var status = \"\";\n      if (vim.visualMode) {\n        status += \"VISUAL\";\n        if (vim.visualLine) status += \" LINE\";\n        if (vim.visualBlock) status += \" BLOCK\";\n      }\n      if (vim.status) status += (status ? \" \" : \"\") + vim.status;\n      return status;\n    }\n  };\n  vimApi.defineOption({\n    name: \"wrap\",\n    set: function (value, cm) {\n      if (cm) {\n        cm.ace.setOption(\"wrap\", value);\n      }\n    },\n    type: \"boolean\"\n  }, false);\n  vimApi.defineEx('write', 'w', function () {\n    console.log(':write is not implemented');\n  });\n  defaultKeymap.push({\n    keys: 'zc',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      open: false\n    }\n  }, {\n    keys: 'zC',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      open: false,\n      all: true\n    }\n  }, {\n    keys: 'zo',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      open: true\n    }\n  }, {\n    keys: 'zO',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      open: true,\n      all: true\n    }\n  }, {\n    keys: 'za',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      toggle: true\n    }\n  }, {\n    keys: 'zA',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      toggle: true,\n      all: true\n    }\n  }, {\n    keys: 'zf',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      open: true,\n      all: true\n    }\n  }, {\n    keys: 'zd',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      open: true,\n      all: true\n    }\n  }, {\n    keys: '<C-A-k>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"addCursorAbove\"\n    }\n  }, {\n    keys: '<C-A-j>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"addCursorBelow\"\n    }\n  }, {\n    keys: '<C-A-S-k>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"addCursorAboveSkipCurrent\"\n    }\n  }, {\n    keys: '<C-A-S-j>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"addCursorBelowSkipCurrent\"\n    }\n  }, {\n    keys: '<C-A-h>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"selectMoreBefore\"\n    }\n  }, {\n    keys: '<C-A-l>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"selectMoreAfter\"\n    }\n  }, {\n    keys: '<C-A-S-h>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"selectNextBefore\"\n    }\n  }, {\n    keys: '<C-A-S-l>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"selectNextAfter\"\n    }\n  });\n  defaultKeymap.push({\n    keys: 'gq',\n    type: 'operator',\n    operator: 'hardWrap'\n  });\n  vimApi.defineOperator(\"hardWrap\", function (cm, operatorArgs, ranges, oldAnchor, newHead) {\n    var anchor = ranges[0].anchor.line;\n    var head = ranges[0].head.line;\n    if (operatorArgs.linewise) head--;\n    hardWrap(cm.ace, {\n      startRow: anchor,\n      endRow: head\n    });\n    return Pos(head, 0);\n  });\n  defineOption('textwidth', undefined, 'number', ['tw'], function (width, cm) {\n    if (cm === undefined) {\n      return;\n    }\n    if (width === undefined) {\n      var value = cm.ace.getOption('printMarginColumn');\n      return value;\n    } else {\n      var column = Math.round(width);\n      if (column > 1) {\n        cm.ace.setOption('printMarginColumn', column);\n      }\n    }\n  });\n  actions.aceCommand = function (cm, actionArgs, vim) {\n    cm.vimCmd = actionArgs;\n    if (cm.ace.inVirtualSelectionMode) cm.ace.on(\"beforeEndOperation\", delayedExecAceCommand);else delayedExecAceCommand(null, cm.ace);\n  };\n  function delayedExecAceCommand(op, ace) {\n    ace.off(\"beforeEndOperation\", delayedExecAceCommand);\n    var cmd = ace.state.cm.vimCmd;\n    if (cmd) {\n      ace.execCommand(cmd.exec ? cmd : cmd.name, cmd.args);\n    }\n    ace.curOp = ace.prevOp;\n  }\n  actions.fold = function (cm, actionArgs, vim) {\n    cm.ace.execCommand(['toggleFoldWidget', 'toggleFoldWidget', 'foldOther', 'unfoldall'][(actionArgs.all ? 2 : 0) + (actionArgs.open ? 1 : 0)]);\n  };\n  exports.handler.defaultKeymap = defaultKeymap;\n  exports.handler.actions = actions;\n  exports.Vim = vimApi;\n});\n(function () {\n  ace.require([\"ace/keyboard/vim\"], function (m) {\n    if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n      module.exports = m;\n    }\n  });\n})();","map":{"version":3,"names":["ace","define","require","exports","module","Range","hardWrap","editor","options","max","column","getOption","allowMerge","row","Math","min","startRow","endRow","session","line","getLine","length","space","findSpace","indentation","exec","replace","start","end","test","nextLine","trimmedLine","trimmedNextLine","mergedLine","replaceRange","remove","before","slice","after","spaceAfter","spaceBefore","index","wrapAfterInput","e","command","name","args","cursor","selection","renderer","$printMarginColumn","lastDelta","$undoManager","$lastDelta","markUndoGroup","Editor","defineOptions","prototype","set","val","commands","on","off","value","log","d","format","p","ch","anchor","head","Array","isArray","map","x","JSON","stringify","i","arguments","f","console","EventEmitter","domLib","oop","KEYS","event","Search","useragent","SearchHighlight","multiSelectCommands","TextModeTokenRe","Mode","tokenRe","CodeMirror","state","marks","$uid","onChange","bind","onSelectionChange","onBeforeEndOperation","Pos","defineOption","setter","redo","cm","undo","newlineAndIndent","insert","goLineLeft","moveCursorLineStart","goLineRight","moveCursorLineEnd","keyMap","addClass","rmClass","e_stop","e_preventDefault","stopEvent","keyName","key","keyCode","toUpperCase","getModifierString","m","cmd","commandKeyBinding","toLowerCase","execCommand","lookupKey","handle","found","fallthrough","result","findMatchingTag","findEnclosingTag","signal","o","_signal","addListener","removeListener","isWordChar","lastIndex","implement","destroy","removeOverlay","virtualSelectionMode","inVirtualSelectionMode","delta","change","text","action","lines","curOp","changeHandlers","_eventRegistry","lastChange","next","$updateMarkers","cursorActivityHandlers","cursorActivity","inMultiSelectMode","keyBinding","removeKeyboardHandler","keyboardHandler","operation","fn","force","prevOp","startOperation","scrollIntoView","dialog","vimDialogScroll","endOperation","op","eventName","handlers","listeners","firstLine","lastLine","getLength","lineCount","setCursor","shouldScroll","exitMultiSelectMode","unfold","moveTo","scrollCursorIntoView","getCursor","sel","pos","isEmpty","lead","getRange","toCmPos","listSelections","ranges","multiSelect","rangeList","r","clipPos","setSelections","primIndex","toAcePos","comparePoints","fromPoints","fromOrientedRange","reverse","push","splice","toSingleRange","clone","range","$clipRangeToDocument","addRange","setSelection","a","h","selectTo","origin","somethingSelected","$clipPositionToDocument","foldCode","$toggleFoldWidget","markText","clear","find","isInsert","rowShift","colShift","point","cmp","bias","cmp2","Marker","id","setBookmark","bm","insertLeft","$insertRight","moveH","increment","unit","clearSelection","moveCursorBy","findPosV","amount","goalColumn","config","layerConfig","floor","height","lineHeight","screenPos","documentToScreenPosition","getScreenLength","screenToDocumentPosition","charCoords","mode","sc","left","top","lh","cw","characterWidth","bottom","coordsChar","col","getSearchCursor","query","caseFold","caseSensitive","isRegexp","RegExp","global","ignoreCase","source","search","undefined","Number","MAX_VALUE","acePos","last","findNext","findPrevious","back","setOptions","needle","wrap","backwards","regExp","from","to","doc","scrollTo","y","maxHeight","$size","scrollerHeight","$scrollPastEnd","setScrollTop","setScrollLeft","width","scrollInfo","margin","viewMargin","s","getTextRange","replaceSelection","replaceSelections","getSelection","getSelectedText","getSelections","getInputField","textInput","getElement","getWrapperElement","container","optMap","indentWithTabs","indentUnit","tabSize","firstLineNumber","readOnly","setOption","$keyMap","aceOpt","toggleOverwrite","overwrite","setOverwrite","addOverlay","$searchHighlight","highlight","marker","addDynamicMarker","updateOnChange","removeMarker","cache","re","setRegexp","updateBackMarkers","getScrollInfo","scrollLeft","scrollTop","clientHeight","clientWidth","getValue","setValue","v","getTokenTypeAt","token","getTokenAt","type","findMatchingBracket","getMatchingTags","open","openTag","close","closeTag","indentLine","method","indentRows","outdentRows","indexFromPos","positionToIndex","posFromIndex","indexToPosition","focus","blur","defaultTextHeight","scanForBracket","dir","_","bracketRegex","$findClosingBracket","$findOpeningBracket","refresh","resize","getMode","hasOwnProperty","getLineNumber","getLineHandle","call","cmPos","StringStream","string","lastColumnPos","lastColumnValue","lineStart","eol","sol","peek","charAt","eat","match","ok","eatWhile","eatSpace","skipToEnd","skipTo","indexOf","backUp","n","pattern","consume","caseInsensitive","cased","str","substr","current","hideFirstChars","inner","defineExtension","importCssString","dialogDiv","template","appendChild","document","createElement","className","innerHTML","closeNotification","newVal","currentNotificationClose","callback","closed","me","inp","activeElement","onClose","vim","status","$loop","schedule","CHANGE_CURSOR","getElementsByTagName","button","selectValueOnOpen","select","onInput","onKeyUp","onKeyDown","closeOnEnter","closeOnBlur","doneTimer","duration","clearTimeout","setTimeout","transformCursor","insertMode","visualBlock","empty","updateSelectionForSurrogateCharacters","curStart","curEnd","charCode","charCodeAt","defaultKeymap","keys","toKeys","context","motion","motionArgs","linewise","toJumplist","forward","wordEnd","bigWord","inclusive","explicitRepeat","toFirstChar","repeatOffset","isEdit","actionArgs","matchIndent","sameLine","operator","operatorArgs","indentRight","toLower","operatorMotionArgs","visualLine","shouldMoveCursor","insertAt","interlaceInsertRepeat","blockwise","keepSpaces","fullLine","exitVisualBlock","position","increase","backtrack","textObjectInner","searchArgs","querySrc","wholeWordOnly","defaultKeymapLength","defaultExCommandMap","shortName","possiblyAsync","excludeFromCommandHistory","enterVimMode","onCursorActivity","maybeInitVimState","getOnPasteFn","leaveVimMode","highlightTimeout","detachVimMap","$customCursor","attach","attachVimMap","prev","selectionChanged","Init","cmKey","vimKey","cmKeyToVimKey","vimApi","findKey","modifiers","Shift","Ctrl","Alt","Cmd","Mod","CapsLock","specialKeys","Enter","Backspace","Delete","Insert","pieces","split","lastPiece","hasCharacter","piece","isUpperCase","join","onPasteFn","offsetCursor","actions","enterInsertMode","numberRegex","wordCharTest","bigWordCharTest","makeKeyRange","size","String","fromCharCode","upperCaseAlphabet","lowerCaseAlphabet","numbers","validMarks","concat","validRegisters","upperCaseChars","isLine","isLowerCase","k","isMatchableSymbol","isNumber","isWhiteSpaceString","isEndOfSentenceSymbol","inArray","arr","defaultValue","aliases","Error","cfg","option","scope","local","createCircularJumpList","pointer","tail","buffer","add","oldCur","newCur","curMark","useNextSlot","trashMark","markPos","cursorEqual","move","offset","mark","inc","oldPointer","cachedCursor","createInsertModeChanges","c","changes","expectCursorActivityForChange","MacroModeState","latestRegister","isPlaying","isRecording","replaySearchQueries","onRecordingDone","lastInsertModeChanges","exitMacroRecordMode","macroModeState","vimGlobalState","enterMacroRecordMode","registerName","register","registerController","getRegister","openDialog","dom","class","inputState","InputState","lastEditInputState","lastEditActionCommand","lastHPos","lastHSPos","lastMotion","insertModeRepeat","visualMode","lastSelection","lastPastedText","resetVimGlobalState","searchQuery","searchIsReversed","lastSubstituteReplacePart","jumpList","lastCharacterSearch","selectedCharacter","RegisterController","searchHistoryController","HistoryController","exCommandHistoryController","optionName","lastInsertModeKeyTimer","buildKeyMap","getRegisterController","resetVimGlobalState_","getVimGlobalState_","maybeInitVimState_","suppressErrorLogging","InsertModeKey","lhs","rhs","ctx","exCommandDispatcher","unmap","noremap","toCtxArray","ctxsToMap","actualLength","origLength","mapping","newMapping","_mapCommand","mappedCtxs","filter","el","mapclear","userKeymap","contexts","j","defineEx","prefix","func","exCommands","commandMap_","handleKey","multiSelectHandleKey","handleMacroRecording","clearInputState","logKey","handleEsc","exitVisualMode","exitInsertMode","doKeyToKey","substring","handleKeyInsertMode","keyBuffer","keysAreChars","commandDispatcher","matchCommand","thisMatch","window","selections","here","pop","handleKeyNonInsertMode","keysMatcher","mainKey","operatorShortcut","pushRepeatDigit","isVimOp","processCommand","handleEx","input","defineMotion","defineAction","defineOperator","mapCommand","defineRegister","prefixRepeat","motionRepeat","getRepeat","repeat","parseInt","reason","Register","insertModeChanges","searchQueries","setText","pushText","pushInsertModeChanges","pushSearchQuery","toString","registers","unnamedRegister","isValidRegister","shiftNumericRegisters_","append","navigator","clipboard","writeText","historyBuffer","iterator","initialPrefix","nextMatch","up","element","pushInput","reset","matches","commandMatches","full","partial","bestMatch","character","lastChar","repeatOverride","processMotion","processOperator","processOperatorMotion","processAction","processSearch","processEx","copyArgs","evalInput","updateCmSelection","repeatIsExplicit","recordLastEdit","getSearchState","setReversed","promptPrefix","originalQuery","getQuery","originalScrollPos","handleQuery","smartCase","updateSearchQuery","showConfirm","onPromptClose","logSearchQuery","onPromptKeyUp","target","selectionEnd","selectionStart","parsedQuery","clearSearchHighlight","onPromptKeyDown","shift","showPrompt","desc","word","expandWordUnderCursor","isKeyword","escapeRegex","exArgs","origHead","copyCursor","clipCursorToContent","origAnchor","oldHead","oldAnchor","newHead","newAnchor","noRepeat","motionResult","motions","recordJumpPosition","Infinity","updateMark","cursorIsBefore","lastSel","lineOffset","abs","chOffset","cmSel","cursorMin","cursorMax","newPositions","makeCmSelection","lineLength","tmp","expandSelectionToLine","clipToLine","exclusive","primary","operatorMoveTo","operators","actionCommand","moveToTopLine","_head","getUserVisibleLines","findFirstNonWhiteSpaceCharacter","moveToMiddleLine","moveToBottomLine","expandToLine","_cm","cur","isReversed","highlightSearchMatches","findAndSelectNextInclusive","prevInputState","findNextFromAndToInclusive","subMode","goToMark","getMarkPos","moveToOtherHighlightedEnd","jumpToMark","best","isWrongDirection","equal","between","cursorIsBetween","moveByCharacters","moveByLines","endCh","moveByDisplayLines","moveByScroll","moveToColumn","moveToEol","first","moveToStartOfLine","fold","getFoldLine","res","hitSide","lastCharCoords","goalCoords","resCoords","moveByPage","moveByParagraph","findParagraph","moveBySentence","findSentence","scrollbox","orig","dest","moveByWords","moveToWord","moveTillCharacter","moveToCharacter","recordLastCharacterSearch","moveToSymbol","findSymbol","moveToFirstNonWhiteSpaceCharacter","moveToMatchedSymbol","lineText","symbol","style","matched","moveToLineOrEdgeOfDocument","lineNum","moveToStartOfDisplayLine","moveToEndOfDisplayLine","sticky","textObjectManipulation","mirroredPairs","selfPaired","selectCompanionObject","findBeginningAndEnd","expandTagUnderCursor","content","getSentence","expandSelection","repeatLastCharacterSearch","lastSearch","fillArray","times","finalHead","lastState","prevLineEnd","wasLastLine","replacement","indent","indentMore","indentLess","startLine","endLine","indentAuto","_args","changeCase","swapped","toSwap","yank","endPos","jumpListWalk","scroll","newPos","cursorCoords","ceil","newBottom","scrollToCursor","lineLastCharPos","lineLastCharCoords","replayMacro","executeMacroRegister","newPosition","getLastEditPos","onKeyEventTargetKeyDown","selectForInsert","toggleVisualMode","reselectLastSelection","_actionArgs","updateLastSelection","anchorMark","headMark","joinLines","finalCh","nextStartCh","curFinalPos","newLineAndEnterInsertMode","newlineFn","newlineAndIndentContinueComment","paste","_this","readText","then","continuePaste","whitespaceLength","tabs","spaces","currentLine","chompedText","wasChomped","firstIndent","wspace","newIndent","quotient","curPosFinal","idx","lastSelectionCurEnd","selectedArea","getSelectedAreaRange","selectedText","emptyStrings","selectBlock","lastCh","extendLineToColumn","repeatFn","setRegister","setMark","markName","replaceWith","replaceTo","replaceWithStr","incrementNumberToken","lineStr","numberStr","baseStr","digits","base","number","zeroPadding","repeatLastEdit","includeLineBreak","maxCh","direction","ret","prop","offsetLine","offsetCh","commandMatch","pressed","mapped","prefixLen","pressedPrefix","mappedPrefix","cur1","cur2","apply","cur3","cur1before2","cur2before3","trim","isClipped","curHead","getIndex","wasClipped","baseCh","headCh","newDir","lineHead","atAnchor","atHead","getCurrentSelectedAreaRange","getLastSelectedAreaRange","block","headOffset","anchorOffset","fromCh","toCh","getHead","moveHead","firstNonWS","_forward","noSymbol","wordStart","tags","symbolToMode","findSymbolModes","bracket","isComplete","nextCh","symb","depth","reverseSymb","section","init","curMoveThrough","comment","preprocess","curCh","lineLen","findWord","emptyLineIsWord","charTests","stop","foundWord","words","eodCh","shortCircuit","firstWord","lastWord","keepHPos","retval","charIdxInLine","includeChar","lastIndexOf","isBoundary","any","skipFold","foldLine","startState","nextChar","curr","ln","lastSentencePos","curr_index","last_valid","skip_empty_lines","bracketRegexp","openSym","curChar","chars","len","firstIndex","SearchState","setQuery","getOverlay","searchOverlay","setOverlay","overlay","reversed","getScrollbarAnnotate","annotate","setScrollbarAnnotate","searchState_","splitBySlash","argString","splitBySeparator","findUnescapedSlashes","findUnescapedSeparators","separator","slashes","tokens","escapeNextChar","translateRegex","specials","unescape","out","specialComesNext","charUnescapes","translateRegexReplace","unescapes","unescapeRegexReplace","stream","output","matcher","parseQuery","lastSearchRegister","regexPart","forceIgnoreCase","flagsPart","regexp","createTextNode","nodeType","Object","setAttribute","pre","$color","$whiteSpace","openNotification","alert","innerText","makePrompt","createDocumentFragment","$fontFamily","autocorrect","autocapitalize","spellcheck","shortText","textContent","prompt","regexEqual","r1","r2","props","rawQuery","matchSol","searchState","showMatchesOnScrollbar","lastEndPos","isInRange","getFirstFullyVisibleRow","getLastFullyVisibleRow","undoManager","ExCommandDispatcher","buildCommandMap_","opt_params","that","_processCommand","commandHistoryRegister","previousCommand","inputStream","params","parseInput_","commandName","matchCommand_","parseCommandArgs_","toInput","lineEnd","parseLineSpec_","numberMatch","parseLineSpecOffset_","offsetMatch","delim","argDelimiter","user","unshift","colorscheme","mapArgs","imap","nmap","vmap","setArgs","setCfg","expr","forceGet","optionIsBoolean","oldValue","message","setOptionReturn","setlocal","setglobal","regArgs","regInfo","sort","unique","parseArgs","opts","decimal","hex","octal","err","radix","numPart","textPart","matchPart","compareFn","b","anum","bnum","comparePatternFn","textOld","vglobal","inverted","matchedLines","nextCommand","substitute","replacePart","trailing","count","confirm","startPos","doReplace","write","save","nohlsearch","delmarks","sym","startMark","finishMark","finish","searchCursor","exMode","done","lastPos","modifiedLineNumber","joined","replaceAll","newText","unmodifiedLineNumber","findNextValidMatch","lastMatchTo","_value","savedCallback","detach","insertModeChangeRegister","logInsertModeChange","extra","imc","repeatInsertModeChanges","changeObj","ignoreCount","selectionCount","maybeReset","handleExternalSelection","onKeyFound","repeatForInsert","isAction","cachedInputState","repeatCommand","repeatInsert","changeObject","keyHandler","binding","Vim","specialKey","backspace","esc","right","down","home","pageup","pagedown","enter","hashId","ctrlKey","altKey","shiftKey","cloneVimState","constructor","forEach","isHandled","wasInVisualBlock","wasMultiselect","old","forEachSelection","$desiredColumn","getVim","handler","$id","drawCursor","pixelPos","w","isbackwards","isBackwards","translate","setStyle","$getDirectionForHighlight","handleKeyboard","data","inputKey","inputHash","inputChar","isMac","getCopyText","once","passEvent","$vimModeHandler","updateCursor","updateInputMode","isIntsert","setCommandMode","$keepTextAreaAtCursor","$blockCursor","$cursorLayer","getStatusText","all","toggle","round","aceCommand","vimCmd","delayedExecAceCommand"],"sources":["/home/anasbouzid/code-projects/streamlit/custom-components/CodeEditor/code_editor/frontend/node_modules/ace-builds/src-noconflict/keybinding-vim.js"],"sourcesContent":["ace.define(\"ace/ext/hardwrap\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/editor\",\"ace/config\"], function(require, exports, module){\"use strict\";\nvar Range = require(\"../range\").Range;\nfunction hardWrap(editor, options) {\n    var max = options.column || editor.getOption(\"printMarginColumn\");\n    var allowMerge = options.allowMerge != false;\n    var row = Math.min(options.startRow, options.endRow);\n    var endRow = Math.max(options.startRow, options.endRow);\n    var session = editor.session;\n    while (row <= endRow) {\n        var line = session.getLine(row);\n        if (line.length > max) {\n            var space = findSpace(line, max, 5);\n            if (space) {\n                var indentation = /^\\s*/.exec(line)[0];\n                session.replace(new Range(row, space.start, row, space.end), \"\\n\" + indentation);\n            }\n            endRow++;\n        }\n        else if (allowMerge && /\\S/.test(line) && row != endRow) {\n            var nextLine = session.getLine(row + 1);\n            if (nextLine && /\\S/.test(nextLine)) {\n                var trimmedLine = line.replace(/\\s+$/, \"\");\n                var trimmedNextLine = nextLine.replace(/^\\s+/, \"\");\n                var mergedLine = trimmedLine + \" \" + trimmedNextLine;\n                var space = findSpace(mergedLine, max, 5);\n                if (space && space.start > trimmedLine.length || mergedLine.length < max) {\n                    var replaceRange = new Range(row, trimmedLine.length, row + 1, nextLine.length - trimmedNextLine.length);\n                    session.replace(replaceRange, \" \");\n                    row--;\n                    endRow--;\n                }\n                else if (trimmedLine.length < line.length) {\n                    session.remove(new Range(row, trimmedLine.length, row, line.length));\n                }\n            }\n        }\n        row++;\n    }\n    function findSpace(line, max, min) {\n        if (line.length < max)\n            return;\n        var before = line.slice(0, max);\n        var after = line.slice(max);\n        var spaceAfter = /^(?:(\\s+)|(\\S+)(\\s+))/.exec(after);\n        var spaceBefore = /(?:(\\s+)|(\\s+)(\\S+))$/.exec(before);\n        var start = 0;\n        var end = 0;\n        if (spaceBefore && !spaceBefore[2]) {\n            start = max - spaceBefore[1].length;\n            end = max;\n        }\n        if (spaceAfter && !spaceAfter[2]) {\n            if (!start)\n                start = max;\n            end = max + spaceAfter[1].length;\n        }\n        if (start) {\n            return {\n                start: start,\n                end: end\n            };\n        }\n        if (spaceBefore && spaceBefore[2] && spaceBefore.index > min) {\n            return {\n                start: spaceBefore.index,\n                end: spaceBefore.index + spaceBefore[2].length\n            };\n        }\n        if (spaceAfter && spaceAfter[2]) {\n            start = max + spaceAfter[2].length;\n            return {\n                start: start,\n                end: start + spaceAfter[3].length\n            };\n        }\n    }\n}\nfunction wrapAfterInput(e) {\n    if (e.command.name == \"insertstring\" && /\\S/.test(e.args)) {\n        var editor = e.editor;\n        var cursor = editor.selection.cursor;\n        if (cursor.column <= editor.renderer.$printMarginColumn)\n            return;\n        var lastDelta = editor.session.$undoManager.$lastDelta;\n        hardWrap(editor, {\n            startRow: cursor.row, endRow: cursor.row,\n            allowMerge: false\n        });\n        if (lastDelta != editor.session.$undoManager.$lastDelta)\n            editor.session.markUndoGroup();\n    }\n}\nvar Editor = require(\"../editor\").Editor;\nrequire(\"../config\").defineOptions(Editor.prototype, \"editor\", {\n    hardWrap: {\n        set: function (val) {\n            if (val) {\n                this.commands.on(\"afterExec\", wrapAfterInput);\n            }\n            else {\n                this.commands.off(\"afterExec\", wrapAfterInput);\n            }\n        },\n        value: false\n    }\n});\nexports.hardWrap = hardWrap;\n\n});\n\nace.define(\"ace/keyboard/vim\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/lib/event_emitter\",\"ace/lib/dom\",\"ace/lib/oop\",\"ace/lib/keys\",\"ace/lib/event\",\"ace/search\",\"ace/lib/useragent\",\"ace/search_highlight\",\"ace/commands/multi_select_commands\",\"ace/mode/text\",\"ace/ext/hardwrap\",\"ace/multi_select\"], function(require, exports, module){// CodeMirror, copyright (c) by Marijn Haverbeke and others\n'use strict';\nfunction log() {\n    var d = \"\";\n    function format(p) {\n        if (typeof p != \"object\")\n            return p + \"\";\n        if (\"line\" in p) {\n            return p.line + \":\" + p.ch;\n        }\n        if (\"anchor\" in p) {\n            return format(p.anchor) + \"->\" + format(p.head);\n        }\n        if (Array.isArray(p))\n            return \"[\" + p.map(function (x) {\n                return format(x);\n            }) + \"]\";\n        return JSON.stringify(p);\n    }\n    for (var i = 0; i < arguments.length; i++) {\n        var p = arguments[i];\n        var f = format(p);\n        d += f + \"  \";\n    }\n    console.log(d);\n}\nvar Range = require(\"../range\").Range;\nvar EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\nvar domLib = require(\"../lib/dom\");\nvar oop = require(\"../lib/oop\");\nvar KEYS = require(\"../lib/keys\");\nvar event = require(\"../lib/event\");\nvar Search = require(\"../search\").Search;\nvar useragent = require(\"../lib/useragent\");\nvar SearchHighlight = require(\"../search_highlight\").SearchHighlight;\nvar multiSelectCommands = require(\"../commands/multi_select_commands\");\nvar TextModeTokenRe = require(\"../mode/text\").Mode.prototype.tokenRe;\nvar hardWrap = require(\"../ext/hardwrap\").hardWrap;\nrequire(\"../multi_select\");\nvar CodeMirror = function (ace) {\n    this.ace = ace;\n    this.state = {};\n    this.marks = {};\n    this.options = {};\n    this.$uid = 0;\n    this.onChange = this.onChange.bind(this);\n    this.onSelectionChange = this.onSelectionChange.bind(this);\n    this.onBeforeEndOperation = this.onBeforeEndOperation.bind(this);\n    this.ace.on('change', this.onChange);\n    this.ace.on('changeSelection', this.onSelectionChange);\n    this.ace.on('beforeEndOperation', this.onBeforeEndOperation);\n};\nCodeMirror.Pos = function (line, ch) {\n    if (!(this instanceof Pos))\n        return new Pos(line, ch);\n    this.line = line;\n    this.ch = ch;\n};\nCodeMirror.defineOption = function (name, val, setter) { };\nCodeMirror.commands = {\n    redo: function (cm) { cm.ace.redo(); },\n    undo: function (cm) { cm.ace.undo(); },\n    newlineAndIndent: function (cm) { cm.ace.insert(\"\\n\"); },\n    goLineLeft: function (cm) { cm.ace.selection.moveCursorLineStart(); },\n    goLineRight: function (cm) { cm.ace.selection.moveCursorLineEnd(); }\n};\nCodeMirror.keyMap = {};\nCodeMirror.addClass = CodeMirror.rmClass = function () { };\nCodeMirror.e_stop = CodeMirror.e_preventDefault = event.stopEvent;\nCodeMirror.keyName = function (e) {\n    var key = (KEYS[e.keyCode] || e.key || \"\");\n    if (key.length == 1)\n        key = key.toUpperCase();\n    key = event.getModifierString(e).replace(/(^|-)\\w/g, function (m) {\n        return m.toUpperCase();\n    }) + key;\n    return key;\n};\nCodeMirror.keyMap['default'] = function (key) {\n    return function (cm) {\n        var cmd = cm.ace.commands.commandKeyBinding[key.toLowerCase()];\n        return cmd && cm.ace.execCommand(cmd) !== false;\n    };\n};\nCodeMirror.lookupKey = function lookupKey(key, map, handle) {\n    if (!map)\n        map = \"default\";\n    if (typeof map == \"string\")\n        map = CodeMirror.keyMap[map];\n    var found = typeof map == \"function\" ? map(key) : map[key];\n    if (found === false)\n        return \"nothing\";\n    if (found === \"...\")\n        return \"multi\";\n    if (found != null && handle(found))\n        return \"handled\";\n    if (map.fallthrough) {\n        if (!Array.isArray(map.fallthrough))\n            return lookupKey(key, map.fallthrough, handle);\n        for (var i = 0; i < map.fallthrough.length; i++) {\n            var result = lookupKey(key, map.fallthrough[i], handle);\n            if (result)\n                return result;\n        }\n    }\n};\nCodeMirror.findMatchingTag = function (cm, head) {\n    return cm.findMatchingTag(head);\n};\nCodeMirror.findEnclosingTag = function (cm, head) {\n};\nCodeMirror.signal = function (o, name, e) { return o._signal(name, e); };\nCodeMirror.on = event.addListener;\nCodeMirror.off = event.removeListener;\nCodeMirror.isWordChar = function (ch) {\n    if (ch < \"\\x7f\")\n        return /^\\w$/.test(ch);\n    TextModeTokenRe.lastIndex = 0;\n    return TextModeTokenRe.test(ch);\n};\n(function () {\n    oop.implement(CodeMirror.prototype, EventEmitter);\n    this.destroy = function () {\n        this.ace.off('change', this.onChange);\n        this.ace.off('changeSelection', this.onSelectionChange);\n        this.ace.off('beforeEndOperation', this.onBeforeEndOperation);\n        this.removeOverlay();\n    };\n    this.virtualSelectionMode = function () {\n        return this.ace.inVirtualSelectionMode && this.ace.selection.index;\n    };\n    this.onChange = function (delta) {\n        var change = { text: delta.action[0] == 'i' ? delta.lines : [] };\n        var curOp = this.curOp = this.curOp || {};\n        if (!curOp.changeHandlers)\n            curOp.changeHandlers = this._eventRegistry[\"change\"] && this._eventRegistry[\"change\"].slice();\n        if (!curOp.lastChange) {\n            curOp.lastChange = curOp.change = change;\n        }\n        else {\n            curOp.lastChange.next = curOp.lastChange = change;\n        }\n        this.$updateMarkers(delta);\n    };\n    this.onSelectionChange = function () {\n        var curOp = this.curOp = this.curOp || {};\n        if (!curOp.cursorActivityHandlers)\n            curOp.cursorActivityHandlers = this._eventRegistry[\"cursorActivity\"] && this._eventRegistry[\"cursorActivity\"].slice();\n        this.curOp.cursorActivity = true;\n        if (this.ace.inMultiSelectMode) {\n            this.ace.keyBinding.removeKeyboardHandler(multiSelectCommands.keyboardHandler);\n        }\n    };\n    this.operation = function (fn, force) {\n        if (!force && this.curOp || force && this.curOp && this.curOp.force) {\n            return fn();\n        }\n        if (force || !this.ace.curOp) {\n            if (this.curOp)\n                this.onBeforeEndOperation();\n        }\n        if (!this.ace.curOp) {\n            var prevOp = this.ace.prevOp;\n            this.ace.startOperation({\n                command: { name: \"vim\", scrollIntoView: \"cursor\" }\n            });\n        }\n        var curOp = this.curOp = this.curOp || {};\n        this.curOp.force = force;\n        var result = fn();\n        if (this.ace.curOp && this.ace.curOp.command.name == \"vim\") {\n            if (this.state.dialog)\n                this.ace.curOp.command.scrollIntoView = this.ace.curOp.vimDialogScroll;\n            this.ace.endOperation();\n            if (!curOp.cursorActivity && !curOp.lastChange && prevOp)\n                this.ace.prevOp = prevOp;\n        }\n        if (force || !this.ace.curOp) {\n            if (this.curOp)\n                this.onBeforeEndOperation();\n        }\n        return result;\n    };\n    this.onBeforeEndOperation = function () {\n        var op = this.curOp;\n        if (op) {\n            if (op.change) {\n                this.signal(\"change\", op.change, op);\n            }\n            if (op && op.cursorActivity) {\n                this.signal(\"cursorActivity\", null, op);\n            }\n            this.curOp = null;\n        }\n    };\n    this.signal = function (eventName, e, handlers) {\n        var listeners = handlers ? handlers[eventName + \"Handlers\"]\n            : (this._eventRegistry || {})[eventName];\n        if (!listeners)\n            return;\n        listeners = listeners.slice();\n        for (var i = 0; i < listeners.length; i++)\n            listeners[i](this, e);\n    };\n    this.firstLine = function () { return 0; };\n    this.lastLine = function () { return this.ace.session.getLength() - 1; };\n    this.lineCount = function () { return this.ace.session.getLength(); };\n    this.setCursor = function (line, ch) {\n        if (typeof line === 'object') {\n            ch = line.ch;\n            line = line.line;\n        }\n        var shouldScroll = !this.curOp && !this.ace.inVirtualSelectionMode;\n        if (!this.ace.inVirtualSelectionMode)\n            this.ace.exitMultiSelectMode();\n        this.ace.session.unfold({ row: line, column: ch });\n        this.ace.selection.moveTo(line, ch);\n        if (shouldScroll) {\n            this.ace.renderer.scrollCursorIntoView();\n            this.ace.endOperation();\n        }\n    };\n    this.getCursor = function (p) {\n        var sel = this.ace.selection;\n        var pos = p == 'anchor' ? (sel.isEmpty() ? sel.lead : sel.anchor) :\n            p == 'head' || !p ? sel.lead : sel.getRange()[p];\n        return toCmPos(pos);\n    };\n    this.listSelections = function (p) {\n        var ranges = this.ace.multiSelect.rangeList.ranges;\n        if (!ranges.length || this.ace.inVirtualSelectionMode)\n            return [{ anchor: this.getCursor('anchor'), head: this.getCursor('head') }];\n        return ranges.map(function (r) {\n            return {\n                anchor: this.clipPos(toCmPos(r.cursor == r.end ? r.start : r.end)),\n                head: this.clipPos(toCmPos(r.cursor))\n            };\n        }, this);\n    };\n    this.setSelections = function (p, primIndex) {\n        var sel = this.ace.multiSelect;\n        var ranges = p.map(function (x) {\n            var anchor = toAcePos(x.anchor);\n            var head = toAcePos(x.head);\n            var r = Range.comparePoints(anchor, head) < 0\n                ? new Range.fromPoints(anchor, head)\n                : new Range.fromPoints(head, anchor);\n            r.cursor = Range.comparePoints(r.start, head) ? r.end : r.start;\n            return r;\n        });\n        if (this.ace.inVirtualSelectionMode) {\n            this.ace.selection.fromOrientedRange(ranges[0]);\n            return;\n        }\n        if (!primIndex) {\n            ranges = ranges.reverse();\n        }\n        else if (ranges[primIndex]) {\n            ranges.push(ranges.splice(primIndex, 1)[0]);\n        }\n        sel.toSingleRange(ranges[0].clone());\n        var session = this.ace.session;\n        for (var i = 0; i < ranges.length; i++) {\n            var range = session.$clipRangeToDocument(ranges[i]); // todo why ace doesn't do this?\n            sel.addRange(range);\n        }\n    };\n    this.setSelection = function (a, h, options) {\n        var sel = this.ace.selection;\n        sel.moveTo(a.line, a.ch);\n        sel.selectTo(h.line, h.ch);\n        if (options && options.origin == '*mouse') {\n            this.onBeforeEndOperation();\n        }\n    };\n    this.somethingSelected = function (p) {\n        return !this.ace.selection.isEmpty();\n    };\n    this.clipPos = function (p) {\n        var pos = this.ace.session.$clipPositionToDocument(p.line, p.ch);\n        return toCmPos(pos);\n    };\n    this.foldCode = function (pos) {\n        this.ace.session.$toggleFoldWidget(pos.line, {});\n    };\n    this.markText = function (cursor) {\n        return { clear: function () { }, find: function () { } };\n    };\n    this.$updateMarkers = function (delta) {\n        var isInsert = delta.action == \"insert\";\n        var start = delta.start;\n        var end = delta.end;\n        var rowShift = (end.row - start.row) * (isInsert ? 1 : -1);\n        var colShift = (end.column - start.column) * (isInsert ? 1 : -1);\n        if (isInsert)\n            end = start;\n        for (var i in this.marks) {\n            var point = this.marks[i];\n            var cmp = Range.comparePoints(point, start);\n            if (cmp < 0) {\n                continue; // delta starts after the range\n            }\n            if (cmp === 0) {\n                if (isInsert) {\n                    if (point.bias == 1) {\n                        cmp = 1;\n                    }\n                    else {\n                        point.bias = -1;\n                        continue;\n                    }\n                }\n            }\n            var cmp2 = isInsert ? cmp : Range.comparePoints(point, end);\n            if (cmp2 > 0) {\n                point.row += rowShift;\n                point.column += point.row == end.row ? colShift : 0;\n                continue;\n            }\n            if (!isInsert && cmp2 <= 0) {\n                point.row = start.row;\n                point.column = start.column;\n                if (cmp2 === 0)\n                    point.bias = 1;\n            }\n        }\n    };\n    var Marker = function (cm, id, row, column) {\n        this.cm = cm;\n        this.id = id;\n        this.row = row;\n        this.column = column;\n        cm.marks[this.id] = this;\n    };\n    Marker.prototype.clear = function () { delete this.cm.marks[this.id]; };\n    Marker.prototype.find = function () { return toCmPos(this); };\n    this.setBookmark = function (cursor, options) {\n        var bm = new Marker(this, this.$uid++, cursor.line, cursor.ch);\n        if (!options || !options.insertLeft)\n            bm.$insertRight = true;\n        this.marks[bm.id] = bm;\n        return bm;\n    };\n    this.moveH = function (increment, unit) {\n        if (unit == 'char') {\n            var sel = this.ace.selection;\n            sel.clearSelection();\n            sel.moveCursorBy(0, increment);\n        }\n    };\n    this.findPosV = function (start, amount, unit, goalColumn) {\n        if (unit == 'page') {\n            var renderer = this.ace.renderer;\n            var config = renderer.layerConfig;\n            amount = amount * Math.floor(config.height / config.lineHeight);\n            unit = 'line';\n        }\n        if (unit == 'line') {\n            var screenPos = this.ace.session.documentToScreenPosition(start.line, start.ch);\n            if (goalColumn != null)\n                screenPos.column = goalColumn;\n            screenPos.row += amount;\n            screenPos.row = Math.min(Math.max(0, screenPos.row), this.ace.session.getScreenLength() - 1);\n            var pos = this.ace.session.screenToDocumentPosition(screenPos.row, screenPos.column);\n            return toCmPos(pos);\n        }\n        else {\n            debugger;\n        }\n    };\n    this.charCoords = function (pos, mode) {\n        if (mode == 'div' || !mode) {\n            var sc = this.ace.session.documentToScreenPosition(pos.line, pos.ch);\n            return { left: sc.column, top: sc.row };\n        }\n        if (mode == 'local') {\n            var renderer = this.ace.renderer;\n            var sc = this.ace.session.documentToScreenPosition(pos.line, pos.ch);\n            var lh = renderer.layerConfig.lineHeight;\n            var cw = renderer.layerConfig.characterWidth;\n            var top = lh * sc.row;\n            return { left: sc.column * cw, top: top, bottom: top + lh };\n        }\n    };\n    this.coordsChar = function (pos, mode) {\n        var renderer = this.ace.renderer;\n        if (mode == 'local') {\n            var row = Math.max(0, Math.floor(pos.top / renderer.lineHeight));\n            var col = Math.max(0, Math.floor(pos.left / renderer.characterWidth));\n            var ch = renderer.session.screenToDocumentPosition(row, col);\n            return toCmPos(ch);\n        }\n        else if (mode == 'div') {\n            throw \"not implemented\";\n        }\n    };\n    this.getSearchCursor = function (query, pos, caseFold) {\n        var caseSensitive = false;\n        var isRegexp = false;\n        if (query instanceof RegExp && !query.global) {\n            caseSensitive = !query.ignoreCase;\n            query = query.source;\n            isRegexp = true;\n        }\n        if (query == \"\\\\n\") {\n            query = \"\\n\";\n            isRegexp = false;\n        }\n        var search = new Search();\n        if (pos.ch == undefined)\n            pos.ch = Number.MAX_VALUE;\n        var acePos = { row: pos.line, column: pos.ch };\n        var cm = this;\n        var last = null;\n        return {\n            findNext: function () { return this.find(false); },\n            findPrevious: function () { return this.find(true); },\n            find: function (back) {\n                search.setOptions({\n                    needle: query,\n                    caseSensitive: caseSensitive,\n                    wrap: false,\n                    backwards: back,\n                    regExp: isRegexp,\n                    start: last || acePos\n                });\n                var range = search.find(cm.ace.session);\n                last = range;\n                return last && [!last.isEmpty()];\n            },\n            from: function () { return last && toCmPos(last.start); },\n            to: function () { return last && toCmPos(last.end); },\n            replace: function (text) {\n                if (last) {\n                    last.end = cm.ace.session.doc.replace(last, text);\n                }\n            }\n        };\n    };\n    this.scrollTo = function (x, y) {\n        var renderer = this.ace.renderer;\n        var config = renderer.layerConfig;\n        var maxHeight = config.maxHeight;\n        maxHeight -= (renderer.$size.scrollerHeight - renderer.lineHeight) * renderer.$scrollPastEnd;\n        if (y != null)\n            this.ace.session.setScrollTop(Math.max(0, Math.min(y, maxHeight)));\n        if (x != null)\n            this.ace.session.setScrollLeft(Math.max(0, Math.min(x, config.width)));\n    };\n    this.scrollInfo = function () { return 0; };\n    this.scrollIntoView = function (pos, margin) {\n        if (pos) {\n            var renderer = this.ace.renderer;\n            var viewMargin = { \"top\": 0, \"bottom\": margin };\n            renderer.scrollCursorIntoView(toAcePos(pos), (renderer.lineHeight * 2) / renderer.$size.scrollerHeight, viewMargin);\n        }\n    };\n    this.getLine = function (row) { return this.ace.session.getLine(row); };\n    this.getRange = function (s, e) {\n        return this.ace.session.getTextRange(new Range(s.line, s.ch, e.line, e.ch));\n    };\n    this.replaceRange = function (text, s, e) {\n        if (!e)\n            e = s;\n        var range = new Range(s.line, s.ch, e.line, e.ch);\n        this.ace.session.$clipRangeToDocument(range);\n        return this.ace.session.replace(range, text);\n    };\n    this.replaceSelection =\n        this.replaceSelections = function (p) {\n            var sel = this.ace.selection;\n            if (this.ace.inVirtualSelectionMode) {\n                this.ace.session.replace(sel.getRange(), p[0] || \"\");\n                return;\n            }\n            sel.inVirtualSelectionMode = true;\n            var ranges = sel.rangeList.ranges;\n            if (!ranges.length)\n                ranges = [this.ace.multiSelect.getRange()];\n            for (var i = ranges.length; i--;)\n                this.ace.session.replace(ranges[i], p[i] || \"\");\n            sel.inVirtualSelectionMode = false;\n        };\n    this.getSelection = function () {\n        return this.ace.getSelectedText();\n    };\n    this.getSelections = function () {\n        return this.listSelections().map(function (x) {\n            return this.getRange(x.anchor, x.head);\n        }, this);\n    };\n    this.getInputField = function () {\n        return this.ace.textInput.getElement();\n    };\n    this.getWrapperElement = function () {\n        return this.ace.container;\n    };\n    var optMap = {\n        indentWithTabs: \"useSoftTabs\",\n        indentUnit: \"tabSize\",\n        tabSize: \"tabSize\",\n        firstLineNumber: \"firstLineNumber\",\n        readOnly: \"readOnly\"\n    };\n    this.setOption = function (name, val) {\n        this.state[name] = val;\n        switch (name) {\n            case 'indentWithTabs':\n                name = optMap[name];\n                val = !val;\n                break;\n            case 'keyMap':\n                this.state.$keyMap = val;\n                return;\n                break;\n            default:\n                name = optMap[name];\n        }\n        if (name)\n            this.ace.setOption(name, val);\n    };\n    this.getOption = function (name) {\n        var val;\n        var aceOpt = optMap[name];\n        if (aceOpt)\n            val = this.ace.getOption(aceOpt);\n        switch (name) {\n            case 'indentWithTabs':\n                name = optMap[name];\n                return !val;\n            case 'keyMap':\n                return this.state.$keyMap || 'vim';\n        }\n        return aceOpt ? val : this.state[name];\n    };\n    this.toggleOverwrite = function (on) {\n        this.state.overwrite = on;\n        return this.ace.setOverwrite(on);\n    };\n    this.addOverlay = function (o) {\n        if (!this.$searchHighlight || !this.$searchHighlight.session) {\n            var highlight = new SearchHighlight(null, \"ace_highlight-marker\", \"text\");\n            var marker = this.ace.session.addDynamicMarker(highlight);\n            highlight.id = marker.id;\n            highlight.session = this.ace.session;\n            highlight.destroy = function (o) {\n                highlight.session.off(\"change\", highlight.updateOnChange);\n                highlight.session.off(\"changeEditor\", highlight.destroy);\n                highlight.session.removeMarker(highlight.id);\n                highlight.session = null;\n            };\n            highlight.updateOnChange = function (delta) {\n                var row = delta.start.row;\n                if (row == delta.end.row)\n                    highlight.cache[row] = undefined;\n                else\n                    highlight.cache.splice(row, highlight.cache.length);\n            };\n            highlight.session.on(\"changeEditor\", highlight.destroy);\n            highlight.session.on(\"change\", highlight.updateOnChange);\n        }\n        var re = new RegExp(o.query.source, \"gmi\");\n        this.$searchHighlight = o.highlight = highlight;\n        this.$searchHighlight.setRegexp(re);\n        this.ace.renderer.updateBackMarkers();\n    };\n    this.removeOverlay = function (o) {\n        if (this.$searchHighlight && this.$searchHighlight.session) {\n            this.$searchHighlight.destroy();\n        }\n    };\n    this.getScrollInfo = function () {\n        var renderer = this.ace.renderer;\n        var config = renderer.layerConfig;\n        return {\n            left: renderer.scrollLeft,\n            top: renderer.scrollTop,\n            height: config.maxHeight,\n            width: config.width,\n            clientHeight: config.height,\n            clientWidth: config.width\n        };\n    };\n    this.getValue = function () {\n        return this.ace.getValue();\n    };\n    this.setValue = function (v) {\n        return this.ace.setValue(v, -1);\n    };\n    this.getTokenTypeAt = function (pos) {\n        var token = this.ace.session.getTokenAt(pos.line, pos.ch);\n        return token && /comment|string/.test(token.type) ? \"string\" : \"\";\n    };\n    this.findMatchingBracket = function (pos) {\n        var m = this.ace.session.findMatchingBracket(toAcePos(pos));\n        return { to: m && toCmPos(m) };\n    };\n    this.findMatchingTag = function (pos) {\n        var m = this.ace.session.getMatchingTags(toAcePos(pos));\n        if (!m)\n            return;\n        return {\n            open: {\n                from: toCmPos(m.openTag.start),\n                to: toCmPos(m.openTag.end)\n            },\n            close: {\n                from: toCmPos(m.closeTag.start),\n                to: toCmPos(m.closeTag.end)\n            }\n        };\n    };\n    this.indentLine = function (line, method) {\n        if (method === true)\n            this.ace.session.indentRows(line, line, \"\\t\");\n        else if (method === false)\n            this.ace.session.outdentRows(new Range(line, 0, line, 0));\n    };\n    this.indexFromPos = function (pos) {\n        return this.ace.session.doc.positionToIndex(toAcePos(pos));\n    };\n    this.posFromIndex = function (index) {\n        return toCmPos(this.ace.session.doc.indexToPosition(index));\n    };\n    this.focus = function (index) {\n        return this.ace.textInput.focus();\n    };\n    this.blur = function (index) {\n        return this.ace.blur();\n    };\n    this.defaultTextHeight = function (index) {\n        return this.ace.renderer.layerConfig.lineHeight;\n    };\n    this.scanForBracket = function (pos, dir, _, options) {\n        var re = options.bracketRegex.source;\n        var tokenRe = /paren|text|operator|tag/;\n        if (dir == 1) {\n            var m = this.ace.session.$findClosingBracket(re.slice(1, 2), toAcePos(pos), tokenRe);\n        }\n        else {\n            var m = this.ace.session.$findOpeningBracket(re.slice(-2, -1), { row: pos.line, column: pos.ch + 1 }, tokenRe);\n        }\n        return m && { pos: toCmPos(m) };\n    };\n    this.refresh = function () {\n        return this.ace.resize(true);\n    };\n    this.getMode = function () {\n        return { name: this.getOption(\"mode\") };\n    };\n    this.execCommand = function (name) {\n        if (CodeMirror.commands.hasOwnProperty(name))\n            return CodeMirror.commands[name](this);\n        if (name == \"indentAuto\")\n            return this.ace.execCommand(\"autoindent\");\n        console.log(name + \" is not implemented\");\n    };\n    this.getLineNumber = function (handle) {\n        return handle.row;\n    };\n    this.getLineHandle = function (row) {\n        return { text: this.ace.session.getLine(row), row: row };\n    };\n}).call(CodeMirror.prototype);\nfunction toAcePos(cmPos) {\n    return { row: cmPos.line, column: cmPos.ch };\n}\nfunction toCmPos(acePos) {\n    return new Pos(acePos.row, acePos.column);\n}\nvar StringStream = CodeMirror.StringStream = function (string, tabSize) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n};\nStringStream.prototype = {\n    eol: function () { return this.pos >= this.string.length; },\n    sol: function () { return this.pos == this.lineStart; },\n    peek: function () { return this.string.charAt(this.pos) || undefined; },\n    next: function () {\n        if (this.pos < this.string.length)\n            return this.string.charAt(this.pos++);\n    },\n    eat: function (match) {\n        var ch = this.string.charAt(this.pos);\n        if (typeof match == \"string\")\n            var ok = ch == match;\n        else\n            var ok = ch && (match.test ? match.test(ch) : match(ch));\n        if (ok) {\n            ++this.pos;\n            return ch;\n        }\n    },\n    eatWhile: function (match) {\n        var start = this.pos;\n        while (this.eat(match)) { }\n        return this.pos > start;\n    },\n    eatSpace: function () {\n        var start = this.pos;\n        while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos)))\n            ++this.pos;\n        return this.pos > start;\n    },\n    skipToEnd: function () { this.pos = this.string.length; },\n    skipTo: function (ch) {\n        var found = this.string.indexOf(ch, this.pos);\n        if (found > -1) {\n            this.pos = found;\n            return true;\n        }\n    },\n    backUp: function (n) { this.pos -= n; },\n    column: function () {\n        throw \"not implemented\";\n    },\n    indentation: function () {\n        throw \"not implemented\";\n    },\n    match: function (pattern, consume, caseInsensitive) {\n        if (typeof pattern == \"string\") {\n            var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };\n            var substr = this.string.substr(this.pos, pattern.length);\n            if (cased(substr) == cased(pattern)) {\n                if (consume !== false)\n                    this.pos += pattern.length;\n                return true;\n            }\n        }\n        else {\n            var match = this.string.slice(this.pos).match(pattern);\n            if (match && match.index > 0)\n                return null;\n            if (match && consume !== false)\n                this.pos += match[0].length;\n            return match;\n        }\n    },\n    current: function () { return this.string.slice(this.start, this.pos); },\n    hideFirstChars: function (n, inner) {\n        this.lineStart += n;\n        try {\n            return inner();\n        }\n        finally {\n            this.lineStart -= n;\n        }\n    }\n};\nCodeMirror.defineExtension = function (name, fn) {\n    CodeMirror.prototype[name] = fn;\n};\ndomLib.importCssString(\".normal-mode .ace_cursor{\\n    border: none;\\n    background-color: rgba(255,0,0,0.5);\\n}\\n.normal-mode .ace_hidden-cursors .ace_cursor{\\n  background-color: transparent;\\n  border: 1px solid red;\\n  opacity: 0.7\\n}\\n.ace_dialog {\\n  position: absolute;\\n  left: 0; right: 0;\\n  background: inherit;\\n  z-index: 15;\\n  padding: .1em .8em;\\n  overflow: hidden;\\n  color: inherit;\\n}\\n.ace_dialog-top {\\n  border-bottom: 1px solid #444;\\n  top: 0;\\n}\\n.ace_dialog-bottom {\\n  border-top: 1px solid #444;\\n  bottom: 0;\\n}\\n.ace_dialog input {\\n  border: none;\\n  outline: none;\\n  background: transparent;\\n  width: 20em;\\n  color: inherit;\\n  font-family: monospace;\\n}\", \"vimMode\", false);\n(function () {\n    function dialogDiv(cm, template, bottom) {\n        var wrap = cm.ace.container;\n        var dialog;\n        dialog = wrap.appendChild(document.createElement(\"div\"));\n        if (bottom)\n            dialog.className = \"ace_dialog ace_dialog-bottom\";\n        else\n            dialog.className = \"ace_dialog ace_dialog-top\";\n        if (typeof template == \"string\") {\n            dialog.innerHTML = template;\n        }\n        else { // Assuming it's a detached DOM element.\n            dialog.appendChild(template);\n        }\n        return dialog;\n    }\n    function closeNotification(cm, newVal) {\n        if (cm.state.currentNotificationClose)\n            cm.state.currentNotificationClose();\n        cm.state.currentNotificationClose = newVal;\n    }\n    CodeMirror.defineExtension(\"openDialog\", function (template, callback, options) {\n        if (this.virtualSelectionMode())\n            return;\n        if (!options)\n            options = {};\n        closeNotification(this, null);\n        var dialog = dialogDiv(this, template, options.bottom);\n        var closed = false, me = this;\n        this.state.dialog = dialog;\n        function close(newVal) {\n            if (typeof newVal == 'string') {\n                inp.value = newVal;\n            }\n            else {\n                if (closed)\n                    return;\n                if (newVal && newVal.type == \"blur\") {\n                    if (document.activeElement === inp)\n                        return;\n                }\n                if (me.state.dialog == dialog) {\n                    me.state.dialog = null;\n                    me.focus();\n                }\n                closed = true;\n                dialog.remove();\n                if (options.onClose)\n                    options.onClose(dialog);\n                var cm = me;\n                if (cm.state.vim) {\n                    cm.state.vim.status = null;\n                    cm.ace._signal(\"changeStatus\");\n                    cm.ace.renderer.$loop.schedule(cm.ace.renderer.CHANGE_CURSOR);\n                }\n            }\n        }\n        var inp = dialog.getElementsByTagName(\"input\")[0], button;\n        if (inp) {\n            if (options.value) {\n                inp.value = options.value;\n                if (options.selectValueOnOpen !== false)\n                    inp.select();\n            }\n            if (options.onInput)\n                CodeMirror.on(inp, \"input\", function (e) { options.onInput(e, inp.value, close); });\n            if (options.onKeyUp)\n                CodeMirror.on(inp, \"keyup\", function (e) { options.onKeyUp(e, inp.value, close); });\n            CodeMirror.on(inp, \"keydown\", function (e) {\n                if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) {\n                    return;\n                }\n                if (e.keyCode == 13)\n                    callback(inp.value);\n                if (e.keyCode == 27 || (options.closeOnEnter !== false && e.keyCode == 13)) {\n                    CodeMirror.e_stop(e);\n                    close();\n                }\n            });\n            if (options.closeOnBlur !== false)\n                CodeMirror.on(inp, \"blur\", close);\n            inp.focus();\n        }\n        else if (button = dialog.getElementsByTagName(\"button\")[0]) {\n            CodeMirror.on(button, \"click\", function () {\n                close();\n                me.focus();\n            });\n            if (options.closeOnBlur !== false)\n                CodeMirror.on(button, \"blur\", close);\n            button.focus();\n        }\n        return close;\n    });\n    CodeMirror.defineExtension(\"openNotification\", function (template, options) {\n        if (this.virtualSelectionMode())\n            return;\n        closeNotification(this, close);\n        var dialog = dialogDiv(this, template, options && options.bottom);\n        var closed = false, doneTimer;\n        var duration = options && typeof options.duration !== \"undefined\" ? options.duration : 5000;\n        function close() {\n            if (closed)\n                return;\n            closed = true;\n            clearTimeout(doneTimer);\n            dialog.remove();\n        }\n        CodeMirror.on(dialog, 'click', function (e) {\n            CodeMirror.e_preventDefault(e);\n            close();\n        });\n        if (duration)\n            doneTimer = setTimeout(close, duration);\n        return close;\n    });\n})();\nvar Pos = CodeMirror.Pos;\nfunction transformCursor(cm, range) {\n    var vim = cm.state.vim;\n    if (!vim || vim.insertMode)\n        return range.head;\n    var head = vim.sel.head;\n    if (!head)\n        return range.head;\n    if (vim.visualBlock) {\n        if (range.head.line != head.line) {\n            return;\n        }\n    }\n    if (range.from() == range.anchor && !range.empty()) {\n        if (range.head.line == head.line && range.head.ch != head.ch)\n            return new Pos(range.head.line, range.head.ch - 1);\n    }\n    return range.head;\n}\nfunction updateSelectionForSurrogateCharacters(cm, curStart, curEnd) {\n    if (curStart.line === curEnd.line && curStart.ch >= curEnd.ch - 1) {\n        var text = cm.getLine(curStart.line);\n        var charCode = text.charCodeAt(curStart.ch);\n        if (0xD800 <= charCode && charCode <= 0xD8FF) {\n            curEnd.ch += 1;\n        }\n    }\n    return { start: curStart, end: curEnd };\n}\nvar defaultKeymap = [\n    { keys: '<Left>', type: 'keyToKey', toKeys: 'h' },\n    { keys: '<Right>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<Up>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<Down>', type: 'keyToKey', toKeys: 'j' },\n    { keys: 'g<Up>', type: 'keyToKey', toKeys: 'gk' },\n    { keys: 'g<Down>', type: 'keyToKey', toKeys: 'gj' },\n    { keys: '<Space>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<BS>', type: 'keyToKey', toKeys: 'h', context: 'normal' },\n    { keys: '<Del>', type: 'keyToKey', toKeys: 'x', context: 'normal' },\n    { keys: '<C-Space>', type: 'keyToKey', toKeys: 'W' },\n    { keys: '<C-BS>', type: 'keyToKey', toKeys: 'B', context: 'normal' },\n    { keys: '<S-Space>', type: 'keyToKey', toKeys: 'w' },\n    { keys: '<S-BS>', type: 'keyToKey', toKeys: 'b', context: 'normal' },\n    { keys: '<C-n>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<C-p>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-Esc>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-Esc>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: 's', type: 'keyToKey', toKeys: 'cl', context: 'normal' },\n    { keys: 's', type: 'keyToKey', toKeys: 'c', context: 'visual' },\n    { keys: 'S', type: 'keyToKey', toKeys: 'cc', context: 'normal' },\n    { keys: 'S', type: 'keyToKey', toKeys: 'VdO', context: 'visual' },\n    { keys: '<Home>', type: 'keyToKey', toKeys: '0' },\n    { keys: '<End>', type: 'keyToKey', toKeys: '$' },\n    { keys: '<PageUp>', type: 'keyToKey', toKeys: '<C-b>' },\n    { keys: '<PageDown>', type: 'keyToKey', toKeys: '<C-f>' },\n    { keys: '<CR>', type: 'keyToKey', toKeys: 'j^', context: 'normal' },\n    { keys: '<Ins>', type: 'keyToKey', toKeys: 'i', context: 'normal' },\n    { keys: '<Ins>', type: 'action', action: 'toggleOverwrite', context: 'insert' },\n    { keys: 'H', type: 'motion', motion: 'moveToTopLine', motionArgs: { linewise: true, toJumplist: true } },\n    { keys: 'M', type: 'motion', motion: 'moveToMiddleLine', motionArgs: { linewise: true, toJumplist: true } },\n    { keys: 'L', type: 'motion', motion: 'moveToBottomLine', motionArgs: { linewise: true, toJumplist: true } },\n    { keys: 'h', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: false } },\n    { keys: 'l', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: true } },\n    { keys: 'j', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, linewise: true } },\n    { keys: 'k', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, linewise: true } },\n    { keys: 'gj', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: true } },\n    { keys: 'gk', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: false } },\n    { keys: 'w', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false } },\n    { keys: 'W', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false, bigWord: true } },\n    { keys: 'e', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, inclusive: true } },\n    { keys: 'E', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true } },\n    { keys: 'b', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false } },\n    { keys: 'B', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false, bigWord: true } },\n    { keys: 'ge', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, inclusive: true } },\n    { keys: 'gE', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true } },\n    { keys: '{', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: false, toJumplist: true } },\n    { keys: '}', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: true, toJumplist: true } },\n    { keys: '(', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: false } },\n    { keys: ')', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: true } },\n    { keys: '<C-f>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: true } },\n    { keys: '<C-b>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: false } },\n    { keys: '<C-d>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: true, explicitRepeat: true } },\n    { keys: '<C-u>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: false, explicitRepeat: true } },\n    { keys: 'gg', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true } },\n    { keys: 'G', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true } },\n    { keys: \"g$\", type: \"motion\", motion: \"moveToEndOfDisplayLine\" },\n    { keys: \"g^\", type: \"motion\", motion: \"moveToStartOfDisplayLine\" },\n    { keys: \"g0\", type: \"motion\", motion: \"moveToStartOfDisplayLine\" },\n    { keys: '0', type: 'motion', motion: 'moveToStartOfLine' },\n    { keys: '^', type: 'motion', motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '+', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar: true } },\n    { keys: '-', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, toFirstChar: true } },\n    { keys: '_', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar: true, repeatOffset: -1 } },\n    { keys: '$', type: 'motion', motion: 'moveToEol', motionArgs: { inclusive: true } },\n    { keys: '%', type: 'motion', motion: 'moveToMatchedSymbol', motionArgs: { inclusive: true, toJumplist: true } },\n    { keys: 'f<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: true, inclusive: true } },\n    { keys: 'F<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: false } },\n    { keys: 't<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: true, inclusive: true } },\n    { keys: 'T<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: false } },\n    { keys: ';', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: true } },\n    { keys: ',', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: false } },\n    { keys: '\\'<character>', type: 'motion', motion: 'goToMark', motionArgs: { toJumplist: true, linewise: true } },\n    { keys: '`<character>', type: 'motion', motion: 'goToMark', motionArgs: { toJumplist: true } },\n    { keys: ']`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true } },\n    { keys: '[`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false } },\n    { keys: ']\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true, linewise: true } },\n    { keys: '[\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false, linewise: true } },\n    { keys: ']p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true } },\n    { keys: '[p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true } },\n    { keys: ']<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: true, toJumplist: true } },\n    { keys: '[<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: false, toJumplist: true } },\n    { keys: '|', type: 'motion', motion: 'moveToColumn' },\n    { keys: 'o', type: 'motion', motion: 'moveToOtherHighlightedEnd', context: 'visual' },\n    { keys: 'O', type: 'motion', motion: 'moveToOtherHighlightedEnd', motionArgs: { sameLine: true }, context: 'visual' },\n    { keys: 'd', type: 'operator', operator: 'delete' },\n    { keys: 'y', type: 'operator', operator: 'yank' },\n    { keys: 'c', type: 'operator', operator: 'change' },\n    { keys: '=', type: 'operator', operator: 'indentAuto' },\n    { keys: '>', type: 'operator', operator: 'indent', operatorArgs: { indentRight: true } },\n    { keys: '<', type: 'operator', operator: 'indent', operatorArgs: { indentRight: false } },\n    { keys: 'g~', type: 'operator', operator: 'changeCase' },\n    { keys: 'gu', type: 'operator', operator: 'changeCase', operatorArgs: { toLower: true }, isEdit: true },\n    { keys: 'gU', type: 'operator', operator: 'changeCase', operatorArgs: { toLower: false }, isEdit: true },\n    { keys: 'n', type: 'motion', motion: 'findNext', motionArgs: { forward: true, toJumplist: true } },\n    { keys: 'N', type: 'motion', motion: 'findNext', motionArgs: { forward: false, toJumplist: true } },\n    { keys: 'gn', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: true } },\n    { keys: 'gN', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: false } },\n    { keys: 'x', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false } },\n    { keys: 'X', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true } },\n    { keys: 'D', type: 'operatorMotion', operator: 'delete', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal' },\n    { keys: 'D', type: 'operator', operator: 'delete', operatorArgs: { linewise: true }, context: 'visual' },\n    { keys: 'Y', type: 'operatorMotion', operator: 'yank', motion: 'expandToLine', motionArgs: { linewise: true }, context: 'normal' },\n    { keys: 'Y', type: 'operator', operator: 'yank', operatorArgs: { linewise: true }, context: 'visual' },\n    { keys: 'C', type: 'operatorMotion', operator: 'change', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal' },\n    { keys: 'C', type: 'operator', operator: 'change', operatorArgs: { linewise: true }, context: 'visual' },\n    { keys: '~', type: 'operatorMotion', operator: 'changeCase', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: 'normal' },\n    { keys: '~', type: 'operator', operator: 'changeCase', context: 'visual' },\n    { keys: '<C-u>', type: 'operatorMotion', operator: 'delete', motion: 'moveToStartOfLine', context: 'insert' },\n    { keys: '<C-w>', type: 'operatorMotion', operator: 'delete', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }, context: 'insert' },\n    { keys: '<C-w>', type: 'idle', context: 'normal' },\n    { keys: '<C-i>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: true } },\n    { keys: '<C-o>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: false } },\n    { keys: '<C-e>', type: 'action', action: 'scroll', actionArgs: { forward: true, linewise: true } },\n    { keys: '<C-y>', type: 'action', action: 'scroll', actionArgs: { forward: false, linewise: true } },\n    { keys: 'a', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'charAfter' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'eol' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'endOfSelectedArea' }, context: 'visual' },\n    { keys: 'i', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'inplace' }, context: 'normal' },\n    { keys: 'gi', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'lastEdit' }, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'firstNonBlank' }, context: 'normal' },\n    { keys: 'gI', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'bol' }, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'startOfSelectedArea' }, context: 'visual' },\n    { keys: 'o', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: 'normal' },\n    { keys: 'O', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: 'normal' },\n    { keys: 'v', type: 'action', action: 'toggleVisualMode' },\n    { keys: 'V', type: 'action', action: 'toggleVisualMode', actionArgs: { linewise: true } },\n    { keys: '<C-v>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true } },\n    { keys: '<C-q>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true } },\n    { keys: 'gv', type: 'action', action: 'reselectLastSelection' },\n    { keys: 'J', type: 'action', action: 'joinLines', isEdit: true },\n    { keys: 'gJ', type: 'action', action: 'joinLines', actionArgs: { keepSpaces: true }, isEdit: true },\n    { keys: 'p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true } },\n    { keys: 'P', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true } },\n    { keys: 'r<character>', type: 'action', action: 'replace', isEdit: true },\n    { keys: '@<character>', type: 'action', action: 'replayMacro' },\n    { keys: 'q<character>', type: 'action', action: 'enterMacroRecordMode' },\n    { keys: 'R', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { replace: true }, context: 'normal' },\n    { keys: 'R', type: 'operator', operator: 'change', operatorArgs: { linewise: true, fullLine: true }, context: 'visual', exitVisualBlock: true },\n    { keys: 'u', type: 'action', action: 'undo', context: 'normal' },\n    { keys: 'u', type: 'operator', operator: 'changeCase', operatorArgs: { toLower: true }, context: 'visual', isEdit: true },\n    { keys: 'U', type: 'operator', operator: 'changeCase', operatorArgs: { toLower: false }, context: 'visual', isEdit: true },\n    { keys: '<C-r>', type: 'action', action: 'redo' },\n    { keys: 'm<character>', type: 'action', action: 'setMark' },\n    { keys: '\"<character>', type: 'action', action: 'setRegister' },\n    { keys: 'zz', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' } },\n    { keys: 'z.', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zt', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' } },\n    { keys: 'z<CR>', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zb', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' } },\n    { keys: 'z-', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '.', type: 'action', action: 'repeatLastEdit' },\n    { keys: '<C-a>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: { increase: true, backtrack: false } },\n    { keys: '<C-x>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: { increase: false, backtrack: false } },\n    { keys: '<C-t>', type: 'action', action: 'indent', actionArgs: { indentRight: true }, context: 'insert' },\n    { keys: '<C-d>', type: 'action', action: 'indent', actionArgs: { indentRight: false }, context: 'insert' },\n    { keys: 'a<character>', type: 'motion', motion: 'textObjectManipulation' },\n    { keys: 'i<character>', type: 'motion', motion: 'textObjectManipulation', motionArgs: { textObjectInner: true } },\n    { keys: '/', type: 'search', searchArgs: { forward: true, querySrc: 'prompt', toJumplist: true } },\n    { keys: '?', type: 'search', searchArgs: { forward: false, querySrc: 'prompt', toJumplist: true } },\n    { keys: '*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true } },\n    { keys: '#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true } },\n    { keys: 'g*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', toJumplist: true } },\n    { keys: 'g#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', toJumplist: true } },\n    { keys: ':', type: 'ex' }\n];\nvar defaultKeymapLength = defaultKeymap.length;\nvar defaultExCommandMap = [\n    { name: 'colorscheme', shortName: 'colo' },\n    { name: 'map' },\n    { name: 'imap', shortName: 'im' },\n    { name: 'nmap', shortName: 'nm' },\n    { name: 'vmap', shortName: 'vm' },\n    { name: 'unmap' },\n    { name: 'write', shortName: 'w' },\n    { name: 'undo', shortName: 'u' },\n    { name: 'redo', shortName: 'red' },\n    { name: 'set', shortName: 'se' },\n    { name: 'setlocal', shortName: 'setl' },\n    { name: 'setglobal', shortName: 'setg' },\n    { name: 'sort', shortName: 'sor' },\n    { name: 'substitute', shortName: 's', possiblyAsync: true },\n    { name: 'nohlsearch', shortName: 'noh' },\n    { name: 'yank', shortName: 'y' },\n    { name: 'delmarks', shortName: 'delm' },\n    { name: 'registers', shortName: 'reg', excludeFromCommandHistory: true },\n    { name: 'vglobal', shortName: 'v' },\n    { name: 'global', shortName: 'g' }\n];\nfunction enterVimMode(cm) {\n    cm.setOption('disableInput', true);\n    cm.setOption('showCursorWhenSelecting', false);\n    CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"normal\" });\n    cm.on('cursorActivity', onCursorActivity);\n    maybeInitVimState(cm);\n    CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n}\nfunction leaveVimMode(cm) {\n    cm.setOption('disableInput', false);\n    cm.off('cursorActivity', onCursorActivity);\n    CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    cm.state.vim = null;\n    if (highlightTimeout)\n        clearTimeout(highlightTimeout);\n}\nfunction detachVimMap(cm, next) {\n    if (this == CodeMirror.keyMap.vim) {\n        cm.options.$customCursor = null;\n        CodeMirror.rmClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n    }\n    if (!next || next.attach != attachVimMap)\n        leaveVimMode(cm);\n}\nfunction attachVimMap(cm, prev) {\n    if (this == CodeMirror.keyMap.vim) {\n        if (cm.curOp)\n            cm.curOp.selectionChanged = true;\n        cm.options.$customCursor = transformCursor;\n        CodeMirror.addClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n    }\n    if (!prev || prev.attach != attachVimMap)\n        enterVimMode(cm);\n}\nCodeMirror.defineOption('vimMode', false, function (cm, val, prev) {\n    if (val && cm.getOption(\"keyMap\") != \"vim\")\n        cm.setOption(\"keyMap\", \"vim\");\n    else if (!val && prev != CodeMirror.Init && /^vim/.test(cm.getOption(\"keyMap\")))\n        cm.setOption(\"keyMap\", \"default\");\n});\nfunction cmKey(key, cm) {\n    if (!cm) {\n        return undefined;\n    }\n    if (this[key]) {\n        return this[key];\n    }\n    var vimKey = cmKeyToVimKey(key);\n    if (!vimKey) {\n        return false;\n    }\n    var cmd = vimApi.findKey(cm, vimKey);\n    if (typeof cmd == 'function') {\n        CodeMirror.signal(cm, 'vim-keypress', vimKey);\n    }\n    return cmd;\n}\nvar modifiers = { Shift: 'S', Ctrl: 'C', Alt: 'A', Cmd: 'D', Mod: 'A', CapsLock: '' };\nvar specialKeys = { Enter: 'CR', Backspace: 'BS', Delete: 'Del', Insert: 'Ins' };\nfunction cmKeyToVimKey(key) {\n    if (key.charAt(0) == '\\'') {\n        return key.charAt(1);\n    }\n    var pieces = key.split(/-(?!$)/);\n    var lastPiece = pieces[pieces.length - 1];\n    if (pieces.length == 1 && pieces[0].length == 1) {\n        return false;\n    }\n    else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {\n        return false;\n    }\n    var hasCharacter = false;\n    for (var i = 0; i < pieces.length; i++) {\n        var piece = pieces[i];\n        if (piece in modifiers) {\n            pieces[i] = modifiers[piece];\n        }\n        else {\n            hasCharacter = true;\n        }\n        if (piece in specialKeys) {\n            pieces[i] = specialKeys[piece];\n        }\n    }\n    if (!hasCharacter) {\n        return false;\n    }\n    if (isUpperCase(lastPiece)) {\n        pieces[pieces.length - 1] = lastPiece.toLowerCase();\n    }\n    return '<' + pieces.join('-') + '>';\n}\nfunction getOnPasteFn(cm) {\n    var vim = cm.state.vim;\n    if (!vim.onPasteFn) {\n        vim.onPasteFn = function () {\n            if (!vim.insertMode) {\n                cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n                actions.enterInsertMode(cm, {}, vim);\n            }\n        };\n    }\n    return vim.onPasteFn;\n}\nvar numberRegex = /[\\d]/;\nvar wordCharTest = [CodeMirror.isWordChar, function (ch) {\n        return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n    }], bigWordCharTest = [function (ch) {\n        return /\\S/.test(ch);\n    }];\nfunction makeKeyRange(start, size) {\n    var keys = [];\n    for (var i = start; i < start + size; i++) {\n        keys.push(String.fromCharCode(i));\n    }\n    return keys;\n}\nvar upperCaseAlphabet = makeKeyRange(65, 26);\nvar lowerCaseAlphabet = makeKeyRange(97, 26);\nvar numbers = makeKeyRange(48, 10);\nvar validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);\nvar validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '\"', '.', ':', '_', '/', '+']);\nvar upperCaseChars;\ntry {\n    upperCaseChars = new RegExp(\"^[\\\\p{Lu}]$\", \"u\");\n}\ncatch (_) {\n    upperCaseChars = /^[A-Z]$/;\n}\nfunction isLine(cm, line) {\n    return line >= cm.firstLine() && line <= cm.lastLine();\n}\nfunction isLowerCase(k) {\n    return (/^[a-z]$/).test(k);\n}\nfunction isMatchableSymbol(k) {\n    return '()[]{}'.indexOf(k) != -1;\n}\nfunction isNumber(k) {\n    return numberRegex.test(k);\n}\nfunction isUpperCase(k) {\n    return upperCaseChars.test(k);\n}\nfunction isWhiteSpaceString(k) {\n    return (/^\\s*$/).test(k);\n}\nfunction isEndOfSentenceSymbol(k) {\n    return '.?!'.indexOf(k) != -1;\n}\nfunction inArray(val, arr) {\n    for (var i = 0; i < arr.length; i++) {\n        if (arr[i] == val) {\n            return true;\n        }\n    }\n    return false;\n}\nvar options = {};\nfunction defineOption(name, defaultValue, type, aliases, callback) {\n    if (defaultValue === undefined && !callback) {\n        throw Error('defaultValue is required unless callback is provided');\n    }\n    if (!type) {\n        type = 'string';\n    }\n    options[name] = {\n        type: type,\n        defaultValue: defaultValue,\n        callback: callback\n    };\n    if (aliases) {\n        for (var i = 0; i < aliases.length; i++) {\n            options[aliases[i]] = options[name];\n        }\n    }\n    if (defaultValue) {\n        setOption(name, defaultValue);\n    }\n}\nfunction setOption(name, value, cm, cfg) {\n    var option = options[name];\n    cfg = cfg || {};\n    var scope = cfg.scope;\n    if (!option) {\n        return new Error('Unknown option: ' + name);\n    }\n    if (option.type == 'boolean') {\n        if (value && value !== true) {\n            return new Error('Invalid argument: ' + name + '=' + value);\n        }\n        else if (value !== false) {\n            value = true;\n        }\n    }\n    if (option.callback) {\n        if (scope !== 'local') {\n            option.callback(value, undefined);\n        }\n        if (scope !== 'global' && cm) {\n            option.callback(value, cm);\n        }\n    }\n    else {\n        if (scope !== 'local') {\n            option.value = option.type == 'boolean' ? !!value : value;\n        }\n        if (scope !== 'global' && cm) {\n            cm.state.vim.options[name] = { value: value };\n        }\n    }\n}\nfunction getOption(name, cm, cfg) {\n    var option = options[name];\n    cfg = cfg || {};\n    var scope = cfg.scope;\n    if (!option) {\n        return new Error('Unknown option: ' + name);\n    }\n    if (option.callback) {\n        var local = cm && option.callback(undefined, cm);\n        if (scope !== 'global' && local !== undefined) {\n            return local;\n        }\n        if (scope !== 'local') {\n            return option.callback();\n        }\n        return;\n    }\n    else {\n        var local = (scope !== 'global') && (cm && cm.state.vim.options[name]);\n        return (local || (scope !== 'local') && option || {}).value;\n    }\n}\ndefineOption('filetype', undefined, 'string', ['ft'], function (name, cm) {\n    if (cm === undefined) {\n        return;\n    }\n    if (name === undefined) {\n        var mode = cm.getOption('mode');\n        return mode == 'null' ? '' : mode;\n    }\n    else {\n        var mode = name == '' ? 'null' : name;\n        cm.setOption('mode', mode);\n    }\n});\nvar createCircularJumpList = function () {\n    var size = 100;\n    var pointer = -1;\n    var head = 0;\n    var tail = 0;\n    var buffer = new Array(size);\n    function add(cm, oldCur, newCur) {\n        var current = pointer % size;\n        var curMark = buffer[current];\n        function useNextSlot(cursor) {\n            var next = ++pointer % size;\n            var trashMark = buffer[next];\n            if (trashMark) {\n                trashMark.clear();\n            }\n            buffer[next] = cm.setBookmark(cursor);\n        }\n        if (curMark) {\n            var markPos = curMark.find();\n            if (markPos && !cursorEqual(markPos, oldCur)) {\n                useNextSlot(oldCur);\n            }\n        }\n        else {\n            useNextSlot(oldCur);\n        }\n        useNextSlot(newCur);\n        head = pointer;\n        tail = pointer - size + 1;\n        if (tail < 0) {\n            tail = 0;\n        }\n    }\n    function move(cm, offset) {\n        pointer += offset;\n        if (pointer > head) {\n            pointer = head;\n        }\n        else if (pointer < tail) {\n            pointer = tail;\n        }\n        var mark = buffer[(size + pointer) % size];\n        if (mark && !mark.find()) {\n            var inc = offset > 0 ? 1 : -1;\n            var newCur;\n            var oldCur = cm.getCursor();\n            do {\n                pointer += inc;\n                mark = buffer[(size + pointer) % size];\n                if (mark &&\n                    (newCur = mark.find()) &&\n                    !cursorEqual(oldCur, newCur)) {\n                    break;\n                }\n            } while (pointer < head && pointer > tail);\n        }\n        return mark;\n    }\n    function find(cm, offset) {\n        var oldPointer = pointer;\n        var mark = move(cm, offset);\n        pointer = oldPointer;\n        return mark && mark.find();\n    }\n    return {\n        cachedCursor: undefined,\n        add: add,\n        find: find,\n        move: move\n    };\n};\nvar createInsertModeChanges = function (c) {\n    if (c) {\n        return {\n            changes: c.changes,\n            expectCursorActivityForChange: c.expectCursorActivityForChange\n        };\n    }\n    return {\n        changes: [],\n        expectCursorActivityForChange: false\n    };\n};\nfunction MacroModeState() {\n    this.latestRegister = undefined;\n    this.isPlaying = false;\n    this.isRecording = false;\n    this.replaySearchQueries = [];\n    this.onRecordingDone = undefined;\n    this.lastInsertModeChanges = createInsertModeChanges();\n}\nMacroModeState.prototype = {\n    exitMacroRecordMode: function () {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.onRecordingDone) {\n            macroModeState.onRecordingDone(); // close dialog\n        }\n        macroModeState.onRecordingDone = undefined;\n        macroModeState.isRecording = false;\n    },\n    enterMacroRecordMode: function (cm, registerName) {\n        var register = vimGlobalState.registerController.getRegister(registerName);\n        if (register) {\n            register.clear();\n            this.latestRegister = registerName;\n            if (cm.openDialog) {\n                var template = dom('span', { class: 'cm-vim-message' }, 'recording @' + registerName);\n                this.onRecordingDone = cm.openDialog(template, null, { bottom: true });\n            }\n            this.isRecording = true;\n        }\n    }\n};\nfunction maybeInitVimState(cm) {\n    if (!cm.state.vim) {\n        cm.state.vim = {\n            inputState: new InputState(),\n            lastEditInputState: undefined,\n            lastEditActionCommand: undefined,\n            lastHPos: -1,\n            lastHSPos: -1,\n            lastMotion: null,\n            marks: {},\n            insertMode: false,\n            insertModeRepeat: undefined,\n            visualMode: false,\n            visualLine: false,\n            visualBlock: false,\n            lastSelection: null,\n            lastPastedText: null,\n            sel: {},\n            options: {}\n        };\n    }\n    return cm.state.vim;\n}\nvar vimGlobalState;\nfunction resetVimGlobalState() {\n    vimGlobalState = {\n        searchQuery: null,\n        searchIsReversed: false,\n        lastSubstituteReplacePart: undefined,\n        jumpList: createCircularJumpList(),\n        macroModeState: new MacroModeState,\n        lastCharacterSearch: { increment: 0, forward: true, selectedCharacter: '' },\n        registerController: new RegisterController({}),\n        searchHistoryController: new HistoryController(),\n        exCommandHistoryController: new HistoryController()\n    };\n    for (var optionName in options) {\n        var option = options[optionName];\n        option.value = option.defaultValue;\n    }\n}\nvar lastInsertModeKeyTimer;\nvar vimApi = {\n    enterVimMode: enterVimMode,\n    leaveVimMode: leaveVimMode,\n    buildKeyMap: function () {\n    },\n    getRegisterController: function () {\n        return vimGlobalState.registerController;\n    },\n    resetVimGlobalState_: resetVimGlobalState,\n    getVimGlobalState_: function () {\n        return vimGlobalState;\n    },\n    maybeInitVimState_: maybeInitVimState,\n    suppressErrorLogging: false,\n    InsertModeKey: InsertModeKey,\n    map: function (lhs, rhs, ctx) {\n        exCommandDispatcher.map(lhs, rhs, ctx);\n    },\n    unmap: function (lhs, ctx) {\n        return exCommandDispatcher.unmap(lhs, ctx);\n    },\n    noremap: function (lhs, rhs, ctx) {\n        function toCtxArray(ctx) {\n            return ctx ? [ctx] : ['normal', 'insert', 'visual'];\n        }\n        var ctxsToMap = toCtxArray(ctx);\n        var actualLength = defaultKeymap.length, origLength = defaultKeymapLength;\n        for (var i = actualLength - origLength; i < actualLength && ctxsToMap.length; i++) {\n            var mapping = defaultKeymap[i];\n            if (mapping.keys == rhs &&\n                (!ctx || !mapping.context || mapping.context === ctx) &&\n                mapping.type.substr(0, 2) !== 'ex' &&\n                mapping.type.substr(0, 3) !== 'key') {\n                var newMapping = {};\n                for (var key in mapping) {\n                    newMapping[key] = mapping[key];\n                }\n                newMapping.keys = lhs;\n                if (ctx && !newMapping.context) {\n                    newMapping.context = ctx;\n                }\n                this._mapCommand(newMapping);\n                var mappedCtxs = toCtxArray(mapping.context);\n                ctxsToMap = ctxsToMap.filter(function (el) { return mappedCtxs.indexOf(el) === -1; });\n            }\n        }\n    },\n    mapclear: function (ctx) {\n        var actualLength = defaultKeymap.length, origLength = defaultKeymapLength;\n        var userKeymap = defaultKeymap.slice(0, actualLength - origLength);\n        defaultKeymap = defaultKeymap.slice(actualLength - origLength);\n        if (ctx) {\n            for (var i = userKeymap.length - 1; i >= 0; i--) {\n                var mapping = userKeymap[i];\n                if (ctx !== mapping.context) {\n                    if (mapping.context) {\n                        this._mapCommand(mapping);\n                    }\n                    else {\n                        var contexts = ['normal', 'insert', 'visual'];\n                        for (var j in contexts) {\n                            if (contexts[j] !== ctx) {\n                                var newMapping = {};\n                                for (var key in mapping) {\n                                    newMapping[key] = mapping[key];\n                                }\n                                newMapping.context = contexts[j];\n                                this._mapCommand(newMapping);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    },\n    setOption: setOption,\n    getOption: getOption,\n    defineOption: defineOption,\n    defineEx: function (name, prefix, func) {\n        if (!prefix) {\n            prefix = name;\n        }\n        else if (name.indexOf(prefix) !== 0) {\n            throw new Error('(Vim.defineEx) \"' + prefix + '\" is not a prefix of \"' + name + '\", command not registered');\n        }\n        exCommands[name] = func;\n        exCommandDispatcher.commandMap_[prefix] = { name: name, shortName: prefix, type: 'api' };\n    },\n    handleKey: function (cm, key, origin) {\n        var command = this.findKey(cm, key, origin);\n        if (typeof command === 'function') {\n            return command();\n        }\n    },\n    multiSelectHandleKey: multiSelectHandleKey,\n    findKey: function (cm, key, origin) {\n        var vim = maybeInitVimState(cm);\n        function handleMacroRecording() {\n            var macroModeState = vimGlobalState.macroModeState;\n            if (macroModeState.isRecording) {\n                if (key == 'q') {\n                    macroModeState.exitMacroRecordMode();\n                    clearInputState(cm);\n                    return true;\n                }\n                if (origin != 'mapping') {\n                    logKey(macroModeState, key);\n                }\n            }\n        }\n        function handleEsc() {\n            if (key == '<Esc>') {\n                if (vim.visualMode) {\n                    exitVisualMode(cm);\n                }\n                else if (vim.insertMode) {\n                    exitInsertMode(cm);\n                }\n                else {\n                    return;\n                }\n                clearInputState(cm);\n                return true;\n            }\n        }\n        function doKeyToKey(keys) {\n            var match;\n            while (keys) {\n                match = (/<\\w+-.+?>|<\\w+>|./).exec(keys);\n                key = match[0];\n                keys = keys.substring(match.index + key.length);\n                vimApi.handleKey(cm, key, 'mapping');\n            }\n        }\n        function handleKeyInsertMode() {\n            if (handleEsc()) {\n                return true;\n            }\n            var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n            var keysAreChars = key.length == 1;\n            var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n            while (keys.length > 1 && match.type != 'full') {\n                var keys = vim.inputState.keyBuffer = keys.slice(1);\n                var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n                if (thisMatch.type != 'none') {\n                    match = thisMatch;\n                }\n            }\n            if (match.type == 'none') {\n                clearInputState(cm);\n                return false;\n            }\n            else if (match.type == 'partial') {\n                if (lastInsertModeKeyTimer) {\n                    window.clearTimeout(lastInsertModeKeyTimer);\n                }\n                lastInsertModeKeyTimer = window.setTimeout(function () { if (vim.insertMode && vim.inputState.keyBuffer) {\n                    clearInputState(cm);\n                } }, getOption('insertModeEscKeysTimeout'));\n                return !keysAreChars;\n            }\n            if (lastInsertModeKeyTimer) {\n                window.clearTimeout(lastInsertModeKeyTimer);\n            }\n            if (keysAreChars) {\n                var selections = cm.listSelections();\n                for (var i = 0; i < selections.length; i++) {\n                    var here = selections[i].head;\n                    cm.replaceRange('', offsetCursor(here, 0, -(keys.length - 1)), here, '+input');\n                }\n                vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n            }\n            clearInputState(cm);\n            return match.command;\n        }\n        function handleKeyNonInsertMode() {\n            if (handleMacroRecording() || handleEsc()) {\n                return true;\n            }\n            var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n            if (/^[1-9]\\d*$/.test(keys)) {\n                return true;\n            }\n            var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n            if (!keysMatcher) {\n                clearInputState(cm);\n                return false;\n            }\n            var context = vim.visualMode ? 'visual' :\n                'normal';\n            var mainKey = keysMatcher[2] || keysMatcher[1];\n            if (vim.inputState.operatorShortcut && vim.inputState.operatorShortcut.slice(-1) == mainKey) {\n                mainKey = vim.inputState.operatorShortcut;\n            }\n            var match = commandDispatcher.matchCommand(mainKey, defaultKeymap, vim.inputState, context);\n            if (match.type == 'none') {\n                clearInputState(cm);\n                return false;\n            }\n            else if (match.type == 'partial') {\n                return true;\n            }\n            else if (match.type == 'clear') {\n                clearInputState(cm);\n                return true;\n            }\n            vim.inputState.keyBuffer = '';\n            keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n            if (keysMatcher[1] && keysMatcher[1] != '0') {\n                vim.inputState.pushRepeatDigit(keysMatcher[1]);\n            }\n            return match.command;\n        }\n        var command;\n        if (vim.insertMode) {\n            command = handleKeyInsertMode();\n        }\n        else {\n            command = handleKeyNonInsertMode();\n        }\n        if (command === false) {\n            return undefined; //ace_patch\n        }\n        else if (command === true) {\n            return function () { return true; };\n        }\n        else {\n            return function () {\n                if ((command.operator || command.isEdit) && cm.getOption('readOnly'))\n                    return; // ace_patch\n                return cm.operation(function () {\n                    cm.curOp.isVimOp = true;\n                    try {\n                        if (command.type == 'keyToKey') {\n                            doKeyToKey(command.toKeys);\n                        }\n                        else {\n                            commandDispatcher.processCommand(cm, vim, command);\n                        }\n                    }\n                    catch (e) {\n                        cm.state.vim = undefined;\n                        maybeInitVimState(cm);\n                        if (!vimApi.suppressErrorLogging) {\n                            console['log'](e);\n                        }\n                        throw e;\n                    }\n                    return true;\n                });\n            };\n        }\n    },\n    handleEx: function (cm, input) {\n        exCommandDispatcher.processCommand(cm, input);\n    },\n    defineMotion: defineMotion,\n    defineAction: defineAction,\n    defineOperator: defineOperator,\n    mapCommand: mapCommand,\n    _mapCommand: _mapCommand,\n    defineRegister: defineRegister,\n    exitVisualMode: exitVisualMode,\n    exitInsertMode: exitInsertMode\n};\nfunction InputState() {\n    this.prefixRepeat = [];\n    this.motionRepeat = [];\n    this.operator = null;\n    this.operatorArgs = null;\n    this.motion = null;\n    this.motionArgs = null;\n    this.keyBuffer = []; // For matching multi-key commands.\n    this.registerName = null; // Defaults to the unnamed register.\n}\nInputState.prototype.pushRepeatDigit = function (n) {\n    if (!this.operator) {\n        this.prefixRepeat = this.prefixRepeat.concat(n);\n    }\n    else {\n        this.motionRepeat = this.motionRepeat.concat(n);\n    }\n};\nInputState.prototype.getRepeat = function () {\n    var repeat = 0;\n    if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n        repeat = 1;\n        if (this.prefixRepeat.length > 0) {\n            repeat *= parseInt(this.prefixRepeat.join(''), 10);\n        }\n        if (this.motionRepeat.length > 0) {\n            repeat *= parseInt(this.motionRepeat.join(''), 10);\n        }\n    }\n    return repeat;\n};\nfunction clearInputState(cm, reason) {\n    cm.state.vim.inputState = new InputState();\n    CodeMirror.signal(cm, 'vim-command-done', reason);\n}\nfunction Register(text, linewise, blockwise) {\n    this.clear();\n    this.keyBuffer = [text || ''];\n    this.insertModeChanges = [];\n    this.searchQueries = [];\n    this.linewise = !!linewise;\n    this.blockwise = !!blockwise;\n}\nRegister.prototype = {\n    setText: function (text, linewise, blockwise) {\n        this.keyBuffer = [text || ''];\n        this.linewise = !!linewise;\n        this.blockwise = !!blockwise;\n    },\n    pushText: function (text, linewise) {\n        if (linewise) {\n            if (!this.linewise) {\n                this.keyBuffer.push('\\n');\n            }\n            this.linewise = true;\n        }\n        this.keyBuffer.push(text);\n    },\n    pushInsertModeChanges: function (changes) {\n        this.insertModeChanges.push(createInsertModeChanges(changes));\n    },\n    pushSearchQuery: function (query) {\n        this.searchQueries.push(query);\n    },\n    clear: function () {\n        this.keyBuffer = [];\n        this.insertModeChanges = [];\n        this.searchQueries = [];\n        this.linewise = false;\n    },\n    toString: function () {\n        return this.keyBuffer.join('');\n    }\n};\nfunction defineRegister(name, register) {\n    var registers = vimGlobalState.registerController.registers;\n    if (!name || name.length != 1) {\n        throw Error('Register name must be 1 character');\n    }\n    registers[name] = register;\n    validRegisters.push(name);\n}\nfunction RegisterController(registers) {\n    this.registers = registers;\n    this.unnamedRegister = registers['\"'] = new Register();\n    registers['.'] = new Register();\n    registers[':'] = new Register();\n    registers['/'] = new Register();\n    registers['+'] = new Register();\n}\nRegisterController.prototype = {\n    pushText: function (registerName, operator, text, linewise, blockwise) {\n        if (registerName === '_')\n            return;\n        if (linewise && text.charAt(text.length - 1) !== '\\n') {\n            text += '\\n';\n        }\n        var register = this.isValidRegister(registerName) ?\n            this.getRegister(registerName) : null;\n        if (!register) {\n            switch (operator) {\n                case 'yank':\n                    this.registers['0'] = new Register(text, linewise, blockwise);\n                    break;\n                case 'delete':\n                case 'change':\n                    if (text.indexOf('\\n') == -1) {\n                        this.registers['-'] = new Register(text, linewise);\n                    }\n                    else {\n                        this.shiftNumericRegisters_();\n                        this.registers['1'] = new Register(text, linewise);\n                    }\n                    break;\n            }\n            this.unnamedRegister.setText(text, linewise, blockwise);\n            return;\n        }\n        var append = isUpperCase(registerName);\n        if (append) {\n            register.pushText(text, linewise);\n        }\n        else {\n            register.setText(text, linewise, blockwise);\n        }\n        if (registerName === '+') {\n            navigator.clipboard.writeText(text);\n        }\n        this.unnamedRegister.setText(register.toString(), linewise);\n    },\n    getRegister: function (name) {\n        if (!this.isValidRegister(name)) {\n            return this.unnamedRegister;\n        }\n        name = name.toLowerCase();\n        if (!this.registers[name]) {\n            this.registers[name] = new Register();\n        }\n        return this.registers[name];\n    },\n    isValidRegister: function (name) {\n        return name && inArray(name, validRegisters);\n    },\n    shiftNumericRegisters_: function () {\n        for (var i = 9; i >= 2; i--) {\n            this.registers[i] = this.getRegister('' + (i - 1));\n        }\n    }\n};\nfunction HistoryController() {\n    this.historyBuffer = [];\n    this.iterator = 0;\n    this.initialPrefix = null;\n}\nHistoryController.prototype = {\n    nextMatch: function (input, up) {\n        var historyBuffer = this.historyBuffer;\n        var dir = up ? -1 : 1;\n        if (this.initialPrefix === null)\n            this.initialPrefix = input;\n        for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i += dir) {\n            var element = historyBuffer[i];\n            for (var j = 0; j <= element.length; j++) {\n                if (this.initialPrefix == element.substring(0, j)) {\n                    this.iterator = i;\n                    return element;\n                }\n            }\n        }\n        if (i >= historyBuffer.length) {\n            this.iterator = historyBuffer.length;\n            return this.initialPrefix;\n        }\n        if (i < 0)\n            return input;\n    },\n    pushInput: function (input) {\n        var index = this.historyBuffer.indexOf(input);\n        if (index > -1)\n            this.historyBuffer.splice(index, 1);\n        if (input.length)\n            this.historyBuffer.push(input);\n    },\n    reset: function () {\n        this.initialPrefix = null;\n        this.iterator = this.historyBuffer.length;\n    }\n};\nvar commandDispatcher = {\n    matchCommand: function (keys, keyMap, inputState, context) {\n        var matches = commandMatches(keys, keyMap, context, inputState);\n        if (!matches.full && !matches.partial) {\n            return { type: 'none' };\n        }\n        else if (!matches.full && matches.partial) {\n            return { type: 'partial' };\n        }\n        var bestMatch;\n        for (var i = 0; i < matches.full.length; i++) {\n            var match = matches.full[i];\n            if (!bestMatch) {\n                bestMatch = match;\n            }\n        }\n        if (bestMatch.keys.slice(-11) == '<character>') {\n            var character = lastChar(keys);\n            if (!character || character.length > 1)\n                return { type: 'clear' };\n            inputState.selectedCharacter = character;\n        }\n        return { type: 'full', command: bestMatch };\n    },\n    processCommand: function (cm, vim, command) {\n        vim.inputState.repeatOverride = command.repeatOverride;\n        switch (command.type) {\n            case 'motion':\n                this.processMotion(cm, vim, command);\n                break;\n            case 'operator':\n                this.processOperator(cm, vim, command);\n                break;\n            case 'operatorMotion':\n                this.processOperatorMotion(cm, vim, command);\n                break;\n            case 'action':\n                this.processAction(cm, vim, command);\n                break;\n            case 'search':\n                this.processSearch(cm, vim, command);\n                break;\n            case 'ex':\n            case 'keyToEx':\n                this.processEx(cm, vim, command);\n                break;\n            default:\n                break;\n        }\n    },\n    processMotion: function (cm, vim, command) {\n        vim.inputState.motion = command.motion;\n        vim.inputState.motionArgs = copyArgs(command.motionArgs);\n        this.evalInput(cm, vim);\n    },\n    processOperator: function (cm, vim, command) {\n        var inputState = vim.inputState;\n        if (inputState.operator) {\n            if (inputState.operator == command.operator) {\n                inputState.motion = 'expandToLine';\n                inputState.motionArgs = { linewise: true };\n                this.evalInput(cm, vim);\n                return;\n            }\n            else {\n                clearInputState(cm);\n            }\n        }\n        inputState.operator = command.operator;\n        inputState.operatorArgs = copyArgs(command.operatorArgs);\n        if (command.keys.length > 1) {\n            inputState.operatorShortcut = command.keys;\n        }\n        if (command.exitVisualBlock) {\n            vim.visualBlock = false;\n            updateCmSelection(cm);\n        }\n        if (vim.visualMode) {\n            this.evalInput(cm, vim);\n        }\n    },\n    processOperatorMotion: function (cm, vim, command) {\n        var visualMode = vim.visualMode;\n        var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n        if (operatorMotionArgs) {\n            if (visualMode && operatorMotionArgs.visualLine) {\n                vim.visualLine = true;\n            }\n        }\n        this.processOperator(cm, vim, command);\n        if (!visualMode) {\n            this.processMotion(cm, vim, command);\n        }\n    },\n    processAction: function (cm, vim, command) {\n        var inputState = vim.inputState;\n        var repeat = inputState.getRepeat();\n        var repeatIsExplicit = !!repeat;\n        var actionArgs = copyArgs(command.actionArgs) || {};\n        if (inputState.selectedCharacter) {\n            actionArgs.selectedCharacter = inputState.selectedCharacter;\n        }\n        if (command.operator) {\n            this.processOperator(cm, vim, command);\n        }\n        if (command.motion) {\n            this.processMotion(cm, vim, command);\n        }\n        if (command.motion || command.operator) {\n            this.evalInput(cm, vim);\n        }\n        actionArgs.repeat = repeat || 1;\n        actionArgs.repeatIsExplicit = repeatIsExplicit;\n        actionArgs.registerName = inputState.registerName;\n        clearInputState(cm);\n        vim.lastMotion = null;\n        if (command.isEdit) {\n            this.recordLastEdit(vim, inputState, command);\n        }\n        actions[command.action](cm, actionArgs, vim);\n    },\n    processSearch: function (cm, vim, command) {\n        if (!cm.getSearchCursor) {\n            return;\n        }\n        var forward = command.searchArgs.forward;\n        var wholeWordOnly = command.searchArgs.wholeWordOnly;\n        getSearchState(cm).setReversed(!forward);\n        var promptPrefix = (forward) ? '/' : '?';\n        var originalQuery = getSearchState(cm).getQuery();\n        var originalScrollPos = cm.getScrollInfo();\n        function handleQuery(query, ignoreCase, smartCase) {\n            vimGlobalState.searchHistoryController.pushInput(query);\n            vimGlobalState.searchHistoryController.reset();\n            try {\n                updateSearchQuery(cm, query, ignoreCase, smartCase);\n            }\n            catch (e) {\n                showConfirm(cm, 'Invalid regex: ' + query);\n                clearInputState(cm);\n                return;\n            }\n            commandDispatcher.processMotion(cm, vim, {\n                type: 'motion',\n                motion: 'findNext',\n                motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }\n            });\n        }\n        function onPromptClose(query) {\n            handleQuery(query, true /** ignoreCase */, true /** smartCase */);\n            var macroModeState = vimGlobalState.macroModeState;\n            if (macroModeState.isRecording) {\n                logSearchQuery(macroModeState, query);\n            }\n        }\n        function onPromptKeyUp(e, query, close) {\n            var keyName = CodeMirror.keyName(e), up, offset;\n            if (keyName == 'Up' || keyName == 'Down') {\n                up = keyName == 'Up' ? true : false;\n                offset = e.target ? e.target.selectionEnd : 0;\n                query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n                close(query);\n                if (offset && e.target)\n                    e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n            }\n            else {\n                if (keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n                    vimGlobalState.searchHistoryController.reset();\n            }\n            var parsedQuery;\n            try {\n                parsedQuery = updateSearchQuery(cm, query, true /** ignoreCase */, true /** smartCase */);\n            }\n            catch (e) {\n            }\n            if (parsedQuery) {\n                cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\n            }\n            else {\n                clearSearchHighlight(cm);\n                cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n            }\n        }\n        function onPromptKeyDown(e, query, close) {\n            var keyName = CodeMirror.keyName(e);\n            if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n                (keyName == 'Backspace' && query == '')) {\n                vimGlobalState.searchHistoryController.pushInput(query);\n                vimGlobalState.searchHistoryController.reset();\n                updateSearchQuery(cm, originalQuery);\n                clearSearchHighlight(cm);\n                cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n                CodeMirror.e_stop(e);\n                clearInputState(cm);\n                close();\n                cm.focus();\n            }\n            else if (keyName == 'Up' || keyName == 'Down') {\n                CodeMirror.e_stop(e);\n            }\n            else if (keyName == 'Ctrl-U') {\n                CodeMirror.e_stop(e);\n                close('');\n            }\n        }\n        switch (command.searchArgs.querySrc) {\n            case 'prompt':\n                var macroModeState = vimGlobalState.macroModeState;\n                if (macroModeState.isPlaying) {\n                    var query = macroModeState.replaySearchQueries.shift();\n                    handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n                }\n                else {\n                    showPrompt(cm, {\n                        onClose: onPromptClose,\n                        prefix: promptPrefix,\n                        desc: '(JavaScript regexp)',\n                        onKeyUp: onPromptKeyUp,\n                        onKeyDown: onPromptKeyDown\n                    });\n                }\n                break;\n            case 'wordUnderCursor':\n                var word = expandWordUnderCursor(cm, false /** inclusive */, true /** forward */, false /** bigWord */, true /** noSymbol */);\n                var isKeyword = true;\n                if (!word) {\n                    word = expandWordUnderCursor(cm, false /** inclusive */, true /** forward */, false /** bigWord */, false /** noSymbol */);\n                    isKeyword = false;\n                }\n                if (!word) {\n                    return;\n                }\n                var query = cm.getLine(word.start.line).substring(word.start.ch, word.end.ch);\n                if (isKeyword && wholeWordOnly) {\n                    query = '\\\\b' + query + '\\\\b';\n                }\n                else {\n                    query = escapeRegex(query);\n                }\n                vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n                cm.setCursor(word.start);\n                handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n                break;\n        }\n    },\n    processEx: function (cm, vim, command) {\n        function onPromptClose(input) {\n            vimGlobalState.exCommandHistoryController.pushInput(input);\n            vimGlobalState.exCommandHistoryController.reset();\n            exCommandDispatcher.processCommand(cm, input);\n            if (cm.state.vim)\n                clearInputState(cm);\n        }\n        function onPromptKeyDown(e, input, close) {\n            var keyName = CodeMirror.keyName(e), up, offset;\n            if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n                (keyName == 'Backspace' && input == '')) {\n                vimGlobalState.exCommandHistoryController.pushInput(input);\n                vimGlobalState.exCommandHistoryController.reset();\n                CodeMirror.e_stop(e);\n                clearInputState(cm);\n                close();\n                cm.focus();\n            }\n            if (keyName == 'Up' || keyName == 'Down') {\n                CodeMirror.e_stop(e);\n                up = keyName == 'Up' ? true : false;\n                offset = e.target ? e.target.selectionEnd : 0;\n                input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n                close(input);\n                if (offset && e.target)\n                    e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n            }\n            else if (keyName == 'Ctrl-U') {\n                CodeMirror.e_stop(e);\n                close('');\n            }\n            else {\n                if (keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n                    vimGlobalState.exCommandHistoryController.reset();\n            }\n        }\n        if (command.type == 'keyToEx') {\n            exCommandDispatcher.processCommand(cm, command.exArgs.input);\n        }\n        else {\n            if (vim.visualMode) {\n                showPrompt(cm, { onClose: onPromptClose, prefix: ':', value: '\\'<,\\'>',\n                    onKeyDown: onPromptKeyDown, selectValueOnOpen: false });\n            }\n            else {\n                showPrompt(cm, { onClose: onPromptClose, prefix: ':',\n                    onKeyDown: onPromptKeyDown });\n            }\n        }\n    },\n    evalInput: function (cm, vim) {\n        var inputState = vim.inputState;\n        var motion = inputState.motion;\n        var motionArgs = inputState.motionArgs || {};\n        var operator = inputState.operator;\n        var operatorArgs = inputState.operatorArgs || {};\n        var registerName = inputState.registerName;\n        var sel = vim.sel;\n        var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head) : cm.getCursor('head'));\n        var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n        var oldHead = copyCursor(origHead);\n        var oldAnchor = copyCursor(origAnchor);\n        var newHead, newAnchor;\n        var repeat;\n        if (operator) {\n            this.recordLastEdit(vim, inputState);\n        }\n        if (inputState.repeatOverride !== undefined) {\n            repeat = inputState.repeatOverride;\n        }\n        else {\n            repeat = inputState.getRepeat();\n        }\n        if (repeat > 0 && motionArgs.explicitRepeat) {\n            motionArgs.repeatIsExplicit = true;\n        }\n        else if (motionArgs.noRepeat ||\n            (!motionArgs.explicitRepeat && repeat === 0)) {\n            repeat = 1;\n            motionArgs.repeatIsExplicit = false;\n        }\n        if (inputState.selectedCharacter) {\n            motionArgs.selectedCharacter = operatorArgs.selectedCharacter =\n                inputState.selectedCharacter;\n        }\n        motionArgs.repeat = repeat;\n        clearInputState(cm);\n        if (motion) {\n            var motionResult = motions[motion](cm, origHead, motionArgs, vim, inputState);\n            vim.lastMotion = motions[motion];\n            if (!motionResult) {\n                return;\n            }\n            if (motionArgs.toJumplist) {\n                if (!operator && cm.ace.curOp != null)\n                    cm.ace.curOp.command.scrollIntoView = \"center-animate\"; // ace_patch\n                var jumpList = vimGlobalState.jumpList;\n                var cachedCursor = jumpList.cachedCursor;\n                if (cachedCursor) {\n                    recordJumpPosition(cm, cachedCursor, motionResult);\n                    delete jumpList.cachedCursor;\n                }\n                else {\n                    recordJumpPosition(cm, origHead, motionResult);\n                }\n            }\n            if (motionResult instanceof Array) {\n                newAnchor = motionResult[0];\n                newHead = motionResult[1];\n            }\n            else {\n                newHead = motionResult;\n            }\n            if (!newHead) {\n                newHead = copyCursor(origHead);\n            }\n            if (vim.visualMode) {\n                if (!(vim.visualBlock && newHead.ch === Infinity)) {\n                    newHead = clipCursorToContent(cm, newHead, oldHead);\n                }\n                if (newAnchor) {\n                    newAnchor = clipCursorToContent(cm, newAnchor);\n                }\n                newAnchor = newAnchor || oldAnchor;\n                sel.anchor = newAnchor;\n                sel.head = newHead;\n                updateCmSelection(cm);\n                updateMark(cm, vim, '<', cursorIsBefore(newAnchor, newHead) ? newAnchor\n                    : newHead);\n                updateMark(cm, vim, '>', cursorIsBefore(newAnchor, newHead) ? newHead\n                    : newAnchor);\n            }\n            else if (!operator) {\n                if (cm.ace.curOp)\n                    cm.ace.curOp.vimDialogScroll = \"center-animate\"; // ace_patch\n                newHead = clipCursorToContent(cm, newHead, oldHead);\n                cm.setCursor(newHead.line, newHead.ch);\n            }\n        }\n        if (operator) {\n            if (operatorArgs.lastSel) {\n                newAnchor = oldAnchor;\n                var lastSel = operatorArgs.lastSel;\n                var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n                var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n                if (lastSel.visualLine) {\n                    newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n                }\n                else if (lastSel.visualBlock) {\n                    newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n                }\n                else if (lastSel.head.line == lastSel.anchor.line) {\n                    newHead = new Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n                }\n                else {\n                    newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n                }\n                vim.visualMode = true;\n                vim.visualLine = lastSel.visualLine;\n                vim.visualBlock = lastSel.visualBlock;\n                sel = vim.sel = {\n                    anchor: newAnchor,\n                    head: newHead\n                };\n                updateCmSelection(cm);\n            }\n            else if (vim.visualMode) {\n                operatorArgs.lastSel = {\n                    anchor: copyCursor(sel.anchor),\n                    head: copyCursor(sel.head),\n                    visualBlock: vim.visualBlock,\n                    visualLine: vim.visualLine\n                };\n            }\n            var curStart, curEnd, linewise, mode;\n            var cmSel;\n            if (vim.visualMode) {\n                curStart = cursorMin(sel.head, sel.anchor);\n                curEnd = cursorMax(sel.head, sel.anchor);\n                linewise = vim.visualLine || operatorArgs.linewise;\n                mode = vim.visualBlock ? 'block' :\n                    linewise ? 'line' :\n                        'char';\n                var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n                cmSel = makeCmSelection(cm, {\n                    anchor: newPositions.start,\n                    head: newPositions.end\n                }, mode);\n                if (linewise) {\n                    var ranges = cmSel.ranges;\n                    if (mode == 'block') {\n                        for (var i = 0; i < ranges.length; i++) {\n                            ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n                        }\n                    }\n                    else if (mode == 'line') {\n                        ranges[0].head = new Pos(ranges[0].head.line + 1, 0);\n                    }\n                }\n            }\n            else {\n                curStart = copyCursor(newAnchor || oldAnchor);\n                curEnd = copyCursor(newHead || oldHead);\n                if (cursorIsBefore(curEnd, curStart)) {\n                    var tmp = curStart;\n                    curStart = curEnd;\n                    curEnd = tmp;\n                }\n                linewise = motionArgs.linewise || operatorArgs.linewise;\n                if (linewise) {\n                    expandSelectionToLine(cm, curStart, curEnd);\n                }\n                else if (motionArgs.forward) {\n                    clipToLine(cm, curStart, curEnd);\n                }\n                mode = 'char';\n                var exclusive = !motionArgs.inclusive || linewise;\n                var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n                cmSel = makeCmSelection(cm, {\n                    anchor: newPositions.start,\n                    head: newPositions.end\n                }, mode, exclusive);\n            }\n            cm.setSelections(cmSel.ranges, cmSel.primary);\n            vim.lastMotion = null;\n            operatorArgs.repeat = repeat; // For indent in visual mode.\n            operatorArgs.registerName = registerName;\n            operatorArgs.linewise = linewise;\n            var operatorMoveTo = operators[operator](cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n            if (vim.visualMode) {\n                exitVisualMode(cm, operatorMoveTo != null);\n            }\n            if (operatorMoveTo) {\n                cm.setCursor(operatorMoveTo);\n            }\n        }\n    },\n    recordLastEdit: function (vim, inputState, actionCommand) {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) {\n            return;\n        }\n        vim.lastEditInputState = inputState;\n        vim.lastEditActionCommand = actionCommand;\n        macroModeState.lastInsertModeChanges.changes = [];\n        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n        macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;\n    }\n};\nvar motions = {\n    moveToTopLine: function (cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).top + motionArgs.repeat - 1;\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    moveToMiddleLine: function (cm) {\n        var range = getUserVisibleLines(cm);\n        var line = Math.floor((range.top + range.bottom) * 0.5);\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    moveToBottomLine: function (cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat + 1;\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    expandToLine: function (_cm, head, motionArgs) {\n        var cur = head;\n        return new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n    },\n    findNext: function (cm, _head, motionArgs) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        if (!query) {\n            return;\n        }\n        var prev = !motionArgs.forward;\n        prev = (state.isReversed()) ? !prev : prev;\n        highlightSearchMatches(cm, query);\n        return findNext(cm, prev /** prev */, query, motionArgs.repeat);\n    },\n    findAndSelectNextInclusive: function (cm, _head, motionArgs, vim, prevInputState) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        if (!query) {\n            return;\n        }\n        var prev = !motionArgs.forward;\n        prev = (state.isReversed()) ? !prev : prev;\n        var next = findNextFromAndToInclusive(cm, prev, query, motionArgs.repeat, vim);\n        if (!next) {\n            return;\n        }\n        if (prevInputState.operator) {\n            return next;\n        }\n        var from = next[0];\n        var to = new Pos(next[1].line, next[1].ch - 1);\n        if (vim.visualMode) {\n            if (vim.visualLine || vim.visualBlock) {\n                vim.visualLine = false;\n                vim.visualBlock = false;\n                CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"visual\", subMode: \"\" });\n            }\n            var anchor = vim.sel.anchor;\n            if (anchor) {\n                if (state.isReversed()) {\n                    if (motionArgs.forward) {\n                        return [anchor, from];\n                    }\n                    return [anchor, to];\n                }\n                else {\n                    if (motionArgs.forward) {\n                        return [anchor, to];\n                    }\n                    return [anchor, from];\n                }\n            }\n        }\n        else {\n            vim.visualMode = true;\n            vim.visualLine = false;\n            vim.visualBlock = false;\n            CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"visual\", subMode: \"\" });\n        }\n        return prev ? [to, from] : [from, to];\n    },\n    goToMark: function (cm, _head, motionArgs, vim) {\n        var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\n        if (pos) {\n            return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;\n        }\n        return null;\n    },\n    moveToOtherHighlightedEnd: function (cm, _head, motionArgs, vim) {\n        if (vim.visualBlock && motionArgs.sameLine) {\n            var sel = vim.sel;\n            return [\n                clipCursorToContent(cm, new Pos(sel.anchor.line, sel.head.ch)),\n                clipCursorToContent(cm, new Pos(sel.head.line, sel.anchor.ch))\n            ];\n        }\n        else {\n            return ([vim.sel.head, vim.sel.anchor]);\n        }\n    },\n    jumpToMark: function (cm, head, motionArgs, vim) {\n        var best = head;\n        for (var i = 0; i < motionArgs.repeat; i++) {\n            var cursor = best;\n            for (var key in vim.marks) {\n                if (!isLowerCase(key)) {\n                    continue;\n                }\n                var mark = vim.marks[key].find();\n                var isWrongDirection = (motionArgs.forward) ?\n                    cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n                if (isWrongDirection) {\n                    continue;\n                }\n                if (motionArgs.linewise && (mark.line == cursor.line)) {\n                    continue;\n                }\n                var equal = cursorEqual(cursor, best);\n                var between = (motionArgs.forward) ?\n                    cursorIsBetween(cursor, mark, best) :\n                    cursorIsBetween(best, mark, cursor);\n                if (equal || between) {\n                    best = mark;\n                }\n            }\n        }\n        if (motionArgs.linewise) {\n            best = new Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n        }\n        return best;\n    },\n    moveByCharacters: function (_cm, head, motionArgs) {\n        var cur = head;\n        var repeat = motionArgs.repeat;\n        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n        return new Pos(cur.line, ch);\n    },\n    moveByLines: function (cm, head, motionArgs, vim) {\n        var cur = head;\n        var endCh = cur.ch;\n        switch (vim.lastMotion) {\n            case this.moveByLines:\n            case this.moveByDisplayLines:\n            case this.moveByScroll:\n            case this.moveToColumn:\n            case this.moveToEol:\n                endCh = vim.lastHPos;\n                break;\n            default:\n                vim.lastHPos = endCh;\n        }\n        var repeat = motionArgs.repeat + (motionArgs.repeatOffset || 0);\n        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n        var first = cm.firstLine();\n        var last = cm.lastLine();\n        if (line < first && cur.line == first) {\n            return this.moveToStartOfLine(cm, head, motionArgs, vim);\n        }\n        else if (line > last && cur.line == last) {\n            return moveToEol(cm, head, motionArgs, vim, true);\n        }\n        var fold = cm.ace.session.getFoldLine(line);\n        if (fold) {\n            if (motionArgs.forward) {\n                if (line > fold.start.row)\n                    line = fold.end.row + 1;\n            }\n            else {\n                line = fold.start.row;\n            }\n        }\n        if (motionArgs.toFirstChar) {\n            endCh = findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n            vim.lastHPos = endCh;\n        }\n        vim.lastHSPos = cm.charCoords(new Pos(line, endCh), 'div').left;\n        return new Pos(line, endCh);\n    },\n    moveByDisplayLines: function (cm, head, motionArgs, vim) {\n        var cur = head;\n        switch (vim.lastMotion) {\n            case this.moveByDisplayLines:\n            case this.moveByScroll:\n            case this.moveByLines:\n            case this.moveToColumn:\n            case this.moveToEol:\n                break;\n            default:\n                vim.lastHSPos = cm.charCoords(cur, 'div').left;\n        }\n        var repeat = motionArgs.repeat;\n        var res = cm.findPosV(cur, (motionArgs.forward ? repeat : -repeat), 'line', vim.lastHSPos);\n        if (res.hitSide) {\n            if (motionArgs.forward) {\n                var lastCharCoords = cm.charCoords(res, 'div');\n                var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };\n                var res = cm.coordsChar(goalCoords, 'div');\n            }\n            else {\n                var resCoords = cm.charCoords(new Pos(cm.firstLine(), 0), 'div');\n                resCoords.left = vim.lastHSPos;\n                res = cm.coordsChar(resCoords, 'div');\n            }\n        }\n        vim.lastHPos = res.ch;\n        return res;\n    },\n    moveByPage: function (cm, head, motionArgs) {\n        var curStart = head;\n        var repeat = motionArgs.repeat;\n        return cm.findPosV(curStart, (motionArgs.forward ? repeat : -repeat), 'page');\n    },\n    moveByParagraph: function (cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findParagraph(cm, head, motionArgs.repeat, dir);\n    },\n    moveBySentence: function (cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findSentence(cm, head, motionArgs.repeat, dir);\n    },\n    moveByScroll: function (cm, head, motionArgs, vim) {\n        var scrollbox = cm.getScrollInfo();\n        var curEnd = null;\n        var repeat = motionArgs.repeat;\n        if (!repeat) {\n            repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n        }\n        var orig = cm.charCoords(head, 'local');\n        motionArgs.repeat = repeat;\n        curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n        if (!curEnd) {\n            return null;\n        }\n        var dest = cm.charCoords(curEnd, 'local');\n        cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n        return curEnd;\n    },\n    moveByWords: function (cm, head, motionArgs) {\n        return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward, !!motionArgs.wordEnd, !!motionArgs.bigWord);\n    },\n    moveTillCharacter: function (cm, _head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        var curEnd = moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter);\n        var increment = motionArgs.forward ? -1 : 1;\n        recordLastCharacterSearch(increment, motionArgs);\n        if (!curEnd)\n            return null;\n        curEnd.ch += increment;\n        return curEnd;\n    },\n    moveToCharacter: function (cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        recordLastCharacterSearch(0, motionArgs);\n        return moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter) || head;\n    },\n    moveToSymbol: function (cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        return findSymbol(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter) || head;\n    },\n    moveToColumn: function (cm, head, motionArgs, vim) {\n        var repeat = motionArgs.repeat;\n        vim.lastHPos = repeat - 1;\n        vim.lastHSPos = cm.charCoords(head, 'div').left;\n        return moveToColumn(cm, repeat);\n    },\n    moveToEol: function (cm, head, motionArgs, vim) {\n        return moveToEol(cm, head, motionArgs, vim, false);\n    },\n    moveToFirstNonWhiteSpaceCharacter: function (cm, head) {\n        var cursor = head;\n        return new Pos(cursor.line, findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n    },\n    moveToMatchedSymbol: function (cm, head) {\n        var cursor = head;\n        var line = cursor.line;\n        var ch = cursor.ch;\n        var lineText = cm.getLine(line);\n        var symbol;\n        for (; ch < lineText.length; ch++) {\n            symbol = lineText.charAt(ch);\n            if (symbol && isMatchableSymbol(symbol)) {\n                var style = cm.getTokenTypeAt(new Pos(line, ch + 1));\n                if (style !== \"string\" && style !== \"comment\") {\n                    break;\n                }\n            }\n        }\n        if (ch < lineText.length) {\n            var re = /[<>]/.test(lineText[ch]) ? /[(){}[\\]<>]/ : /[(){}[\\]]/; //ace_patch?\n            var matched = cm.findMatchingBracket(new Pos(line, ch + 1), { bracketRegex: re });\n            return matched.to;\n        }\n        else {\n            return cursor;\n        }\n    },\n    moveToStartOfLine: function (_cm, head) {\n        return new Pos(head.line, 0);\n    },\n    moveToLineOrEdgeOfDocument: function (cm, _head, motionArgs) {\n        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n        if (motionArgs.repeatIsExplicit) {\n            lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n        }\n        return new Pos(lineNum, findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n    },\n    moveToStartOfDisplayLine: function (cm) {\n        cm.execCommand(\"goLineLeft\");\n        return cm.getCursor();\n    },\n    moveToEndOfDisplayLine: function (cm) {\n        cm.execCommand(\"goLineRight\");\n        var head = cm.getCursor();\n        if (head.sticky == \"before\")\n            head.ch--;\n        return head;\n    },\n    textObjectManipulation: function (cm, head, motionArgs, vim) {\n        var mirroredPairs = { '(': ')', ')': '(',\n            '{': '}', '}': '{',\n            '[': ']', ']': '[',\n            '<': '>', '>': '<' };\n        var selfPaired = { '\\'': true, '\"': true, '`': true };\n        var character = motionArgs.selectedCharacter;\n        if (character == 'b') {\n            character = '(';\n        }\n        else if (character == 'B') {\n            character = '{';\n        }\n        var inclusive = !motionArgs.textObjectInner;\n        var tmp;\n        if (mirroredPairs[character]) {\n            tmp = selectCompanionObject(cm, head, character, inclusive);\n        }\n        else if (selfPaired[character]) {\n            tmp = findBeginningAndEnd(cm, head, character, inclusive);\n        }\n        else if (character === 'W') {\n            tmp = expandWordUnderCursor(cm, inclusive, true /** forward */, true /** bigWord */);\n        }\n        else if (character === 'w') {\n            tmp = expandWordUnderCursor(cm, inclusive, true /** forward */, false /** bigWord */);\n        }\n        else if (character === 'p') {\n            tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n            motionArgs.linewise = true;\n            if (vim.visualMode) {\n                if (!vim.visualLine) {\n                    vim.visualLine = true;\n                }\n            }\n            else {\n                var operatorArgs = vim.inputState.operatorArgs;\n                if (operatorArgs) {\n                    operatorArgs.linewise = true;\n                }\n                tmp.end.line--;\n            }\n        }\n        else if (character === 't') {\n            tmp = expandTagUnderCursor(cm, head, inclusive);\n        }\n        else if (character === 's') {\n            var content = cm.getLine(head.line);\n            if (head.ch > 0 && isEndOfSentenceSymbol(content[head.ch])) {\n                head.ch -= 1;\n            }\n            var end = getSentence(cm, head, motionArgs.repeat, 1, inclusive);\n            var start = getSentence(cm, head, motionArgs.repeat, -1, inclusive);\n            if (isWhiteSpaceString(cm.getLine(start.line)[start.ch])\n                && isWhiteSpaceString(cm.getLine(end.line)[end.ch - 1])) {\n                start = { line: start.line, ch: start.ch + 1 };\n            }\n            tmp = { start: start, end: end };\n        }\n        else {\n            return null;\n        }\n        if (!cm.state.vim.visualMode) {\n            return [tmp.start, tmp.end];\n        }\n        else {\n            return expandSelection(cm, tmp.start, tmp.end);\n        }\n    },\n    repeatLastCharacterSearch: function (cm, head, motionArgs) {\n        var lastSearch = vimGlobalState.lastCharacterSearch;\n        var repeat = motionArgs.repeat;\n        var forward = motionArgs.forward === lastSearch.forward;\n        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n        cm.moveH(-increment, 'char');\n        motionArgs.inclusive = forward ? true : false;\n        var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n        if (!curEnd) {\n            cm.moveH(increment, 'char');\n            return head;\n        }\n        curEnd.ch += increment;\n        return curEnd;\n    }\n};\nfunction defineMotion(name, fn) {\n    motions[name] = fn;\n}\nfunction fillArray(val, times) {\n    var arr = [];\n    for (var i = 0; i < times; i++) {\n        arr.push(val);\n    }\n    return arr;\n}\nvar operators = {\n    change: function (cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        var anchor = ranges[0].anchor, head = ranges[0].head;\n        if (!vim.visualMode) {\n            text = cm.getRange(anchor, head);\n            var lastState = vim.lastEditInputState || {};\n            if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n                var match = (/\\s+$/).exec(text);\n                if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n                    head = offsetCursor(head, 0, -match[0].length);\n                    text = text.slice(0, -match[0].length);\n                }\n            }\n            var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);\n            var wasLastLine = cm.firstLine() == cm.lastLine();\n            if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {\n                cm.replaceRange('', prevLineEnd, head);\n            }\n            else {\n                cm.replaceRange('', anchor, head);\n            }\n            if (args.linewise) {\n                if (!wasLastLine) {\n                    cm.setCursor(prevLineEnd);\n                    CodeMirror.commands.newlineAndIndent(cm);\n                }\n                anchor.ch = Number.MAX_VALUE;\n            }\n            finalHead = anchor;\n        }\n        else if (args.fullLine) {\n            head.ch = Number.MAX_VALUE;\n            head.line--;\n            cm.setSelection(anchor, head);\n            text = cm.getSelection();\n            cm.replaceSelection(\"\");\n            finalHead = anchor;\n        }\n        else {\n            text = cm.getSelection();\n            var replacement = fillArray('', ranges.length);\n            cm.replaceSelections(replacement);\n            finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(args.registerName, 'change', text, args.linewise, ranges.length > 1);\n        actions.enterInsertMode(cm, { head: finalHead }, cm.state.vim);\n    },\n    'delete': function (cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        if (!vim.visualBlock) {\n            var anchor = ranges[0].anchor, head = ranges[0].head;\n            if (args.linewise &&\n                head.line != cm.firstLine() &&\n                anchor.line == cm.lastLine() &&\n                anchor.line == head.line - 1) {\n                if (anchor.line == cm.firstLine()) {\n                    anchor.ch = 0;\n                }\n                else {\n                    anchor = new Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n                }\n            }\n            text = cm.getRange(anchor, head);\n            cm.replaceRange('', anchor, head);\n            finalHead = anchor;\n            if (args.linewise) {\n                finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n            }\n        }\n        else {\n            text = cm.getSelection();\n            var replacement = fillArray('', ranges.length);\n            cm.replaceSelections(replacement);\n            finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(args.registerName, 'delete', text, args.linewise, vim.visualBlock);\n        return clipCursorToContent(cm, finalHead);\n    },\n    indent: function (cm, args, ranges) {\n        var vim = cm.state.vim;\n        if (cm.indentMore) {\n            var repeat = (vim.visualMode) ? args.repeat : 1;\n            for (var j = 0; j < repeat; j++) {\n                if (args.indentRight)\n                    cm.indentMore();\n                else\n                    cm.indentLess();\n            }\n        }\n        else {\n            var startLine = ranges[0].anchor.line;\n            var endLine = vim.visualBlock ?\n                ranges[ranges.length - 1].anchor.line :\n                ranges[0].head.line;\n            var repeat = (vim.visualMode) ? args.repeat : 1;\n            if (args.linewise) {\n                endLine--;\n            }\n            for (var i = startLine; i <= endLine; i++) {\n                for (var j = 0; j < repeat; j++) {\n                    cm.indentLine(i, args.indentRight);\n                }\n            }\n        }\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n    },\n    indentAuto: function (cm, _args, ranges) {\n        if (ranges.length > 1) { // ace_patch\n            cm.setSelection(ranges[0].anchor, ranges[ranges.length - 1].head);\n        }\n        cm.execCommand(\"indentAuto\");\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n    },\n    changeCase: function (cm, args, ranges, oldAnchor, newHead) {\n        var selections = cm.getSelections();\n        var swapped = [];\n        var toLower = args.toLower;\n        for (var j = 0; j < selections.length; j++) {\n            var toSwap = selections[j];\n            var text = '';\n            if (toLower === true) {\n                text = toSwap.toLowerCase();\n            }\n            else if (toLower === false) {\n                text = toSwap.toUpperCase();\n            }\n            else {\n                for (var i = 0; i < toSwap.length; i++) {\n                    var character = toSwap.charAt(i);\n                    text += isUpperCase(character) ? character.toLowerCase() :\n                        character.toUpperCase();\n                }\n            }\n            swapped.push(text);\n        }\n        cm.replaceSelections(swapped);\n        if (args.shouldMoveCursor) {\n            return newHead;\n        }\n        else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n            return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n        }\n        else if (args.linewise) {\n            return oldAnchor;\n        }\n        else {\n            return cursorMin(ranges[0].anchor, ranges[0].head);\n        }\n    },\n    yank: function (cm, args, ranges, oldAnchor) {\n        var vim = cm.state.vim;\n        var text = cm.getSelection();\n        var endPos = vim.visualMode\n            ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor)\n            : oldAnchor;\n        vimGlobalState.registerController.pushText(args.registerName, 'yank', text, args.linewise, vim.visualBlock);\n        return endPos;\n    }\n};\nfunction defineOperator(name, fn) {\n    operators[name] = fn;\n}\nvar actions = {\n    jumpListWalk: function (cm, actionArgs, vim) {\n        if (vim.visualMode) {\n            return;\n        }\n        var repeat = actionArgs.repeat;\n        var forward = actionArgs.forward;\n        var jumpList = vimGlobalState.jumpList;\n        var mark = jumpList.move(cm, forward ? repeat : -repeat);\n        var markPos = mark ? mark.find() : undefined;\n        markPos = markPos ? markPos : cm.getCursor();\n        cm.setCursor(markPos);\n        cm.ace.curOp.command.scrollIntoView = \"center-animate\"; // ace_patch\n    },\n    scroll: function (cm, actionArgs, vim) {\n        if (vim.visualMode) {\n            return;\n        }\n        var repeat = actionArgs.repeat || 1;\n        var lineHeight = cm.defaultTextHeight();\n        var top = cm.getScrollInfo().top;\n        var delta = lineHeight * repeat;\n        var newPos = actionArgs.forward ? top + delta : top - delta;\n        var cursor = copyCursor(cm.getCursor());\n        var cursorCoords = cm.charCoords(cursor, 'local');\n        if (actionArgs.forward) {\n            if (newPos > cursorCoords.top) {\n                cursor.line += (newPos - cursorCoords.top) / lineHeight;\n                cursor.line = Math.ceil(cursor.line);\n                cm.setCursor(cursor);\n                cursorCoords = cm.charCoords(cursor, 'local');\n                cm.scrollTo(null, cursorCoords.top);\n            }\n            else {\n                cm.scrollTo(null, newPos);\n            }\n        }\n        else {\n            var newBottom = newPos + cm.getScrollInfo().clientHeight;\n            if (newBottom < cursorCoords.bottom) {\n                cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n                cursor.line = Math.floor(cursor.line);\n                cm.setCursor(cursor);\n                cursorCoords = cm.charCoords(cursor, 'local');\n                cm.scrollTo(null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n            }\n            else {\n                cm.scrollTo(null, newPos);\n            }\n        }\n    },\n    scrollToCursor: function (cm, actionArgs) {\n        var lineNum = cm.getCursor().line;\n        var charCoords = cm.charCoords(new Pos(lineNum, 0), 'local');\n        var height = cm.getScrollInfo().clientHeight;\n        var y = charCoords.top;\n        switch (actionArgs.position) {\n            case 'center':\n                y = charCoords.bottom - height / 2;\n                break;\n            case 'bottom':\n                var lineLastCharPos = new Pos(lineNum, cm.getLine(lineNum).length - 1);\n                var lineLastCharCoords = cm.charCoords(lineLastCharPos, 'local');\n                var lineHeight = lineLastCharCoords.bottom - y;\n                y = y - height + lineHeight;\n                break;\n        }\n        cm.scrollTo(null, y);\n    },\n    replayMacro: function (cm, actionArgs, vim) {\n        var registerName = actionArgs.selectedCharacter;\n        var repeat = actionArgs.repeat;\n        var macroModeState = vimGlobalState.macroModeState;\n        if (registerName == '@') {\n            registerName = macroModeState.latestRegister;\n        }\n        else {\n            macroModeState.latestRegister = registerName;\n        }\n        while (repeat--) {\n            executeMacroRegister(cm, vim, macroModeState, registerName);\n        }\n    },\n    enterMacroRecordMode: function (cm, actionArgs) {\n        var macroModeState = vimGlobalState.macroModeState;\n        var registerName = actionArgs.selectedCharacter;\n        if (vimGlobalState.registerController.isValidRegister(registerName)) {\n            macroModeState.enterMacroRecordMode(cm, registerName);\n        }\n    },\n    toggleOverwrite: function (cm) {\n        if (!cm.state.overwrite) {\n            cm.toggleOverwrite(true);\n            cm.setOption('keyMap', 'vim-replace');\n            CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"replace\" });\n        }\n        else {\n            cm.toggleOverwrite(false);\n            cm.setOption('keyMap', 'vim-insert');\n            CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"insert\" });\n        }\n    },\n    enterInsertMode: function (cm, actionArgs, vim) {\n        if (cm.getOption('readOnly')) {\n            return;\n        }\n        vim.insertMode = true;\n        vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n        var insertAt = (actionArgs) ? actionArgs.insertAt : null;\n        var sel = vim.sel;\n        var head = actionArgs.head || cm.getCursor('head');\n        var height = cm.listSelections().length;\n        if (insertAt == 'eol') {\n            head = new Pos(head.line, lineLength(cm, head.line));\n        }\n        else if (insertAt == 'bol') {\n            head = new Pos(head.line, 0);\n        }\n        else if (insertAt == 'charAfter') {\n            var newPosition = updateSelectionForSurrogateCharacters(cm, head, offsetCursor(head, 0, 1));\n            head = newPosition.end;\n        }\n        else if (insertAt == 'firstNonBlank') {\n            var newPosition = updateSelectionForSurrogateCharacters(cm, head, motions.moveToFirstNonWhiteSpaceCharacter(cm, head));\n            head = newPosition.end;\n        }\n        else if (insertAt == 'startOfSelectedArea') {\n            if (!vim.visualMode)\n                return;\n            if (!vim.visualBlock) {\n                if (sel.head.line < sel.anchor.line) {\n                    head = sel.head;\n                }\n                else {\n                    head = new Pos(sel.anchor.line, 0);\n                }\n            }\n            else {\n                head = new Pos(Math.min(sel.head.line, sel.anchor.line), Math.min(sel.head.ch, sel.anchor.ch));\n                height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n            }\n        }\n        else if (insertAt == 'endOfSelectedArea') {\n            if (!vim.visualMode)\n                return;\n            if (!vim.visualBlock) {\n                if (sel.head.line >= sel.anchor.line) {\n                    head = offsetCursor(sel.head, 0, 1);\n                }\n                else {\n                    head = new Pos(sel.anchor.line, 0);\n                }\n            }\n            else {\n                head = new Pos(Math.min(sel.head.line, sel.anchor.line), Math.max(sel.head.ch, sel.anchor.ch) + 1);\n                height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n            }\n        }\n        else if (insertAt == 'inplace') {\n            if (vim.visualMode) {\n                return;\n            }\n        }\n        else if (insertAt == 'lastEdit') {\n            head = getLastEditPos(cm) || head;\n        }\n        cm.setOption('disableInput', false);\n        if (actionArgs && actionArgs.replace) {\n            cm.toggleOverwrite(true);\n            cm.setOption('keyMap', 'vim-replace');\n            CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"replace\" });\n        }\n        else {\n            cm.toggleOverwrite(false);\n            cm.setOption('keyMap', 'vim-insert');\n            CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"insert\" });\n        }\n        if (!vimGlobalState.macroModeState.isPlaying) {\n            cm.on('change', onChange);\n            CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n        }\n        if (vim.visualMode) {\n            exitVisualMode(cm);\n        }\n        selectForInsert(cm, head, height);\n    },\n    toggleVisualMode: function (cm, actionArgs, vim) {\n        var repeat = actionArgs.repeat;\n        var anchor = cm.getCursor();\n        var head;\n        if (!vim.visualMode) {\n            vim.visualMode = true;\n            vim.visualLine = !!actionArgs.linewise;\n            vim.visualBlock = !!actionArgs.blockwise;\n            head = clipCursorToContent(cm, new Pos(anchor.line, anchor.ch + repeat - 1));\n            var newPosition = updateSelectionForSurrogateCharacters(cm, anchor, head);\n            vim.sel = {\n                anchor: newPosition.start,\n                head: newPosition.end\n            };\n            CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\" });\n            updateCmSelection(cm);\n            updateMark(cm, vim, '<', cursorMin(anchor, head));\n            updateMark(cm, vim, '>', cursorMax(anchor, head));\n        }\n        else if (vim.visualLine ^ actionArgs.linewise ||\n            vim.visualBlock ^ actionArgs.blockwise) {\n            vim.visualLine = !!actionArgs.linewise;\n            vim.visualBlock = !!actionArgs.blockwise;\n            CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\" });\n            updateCmSelection(cm);\n        }\n        else {\n            exitVisualMode(cm);\n        }\n    },\n    reselectLastSelection: function (cm, _actionArgs, vim) {\n        var lastSelection = vim.lastSelection;\n        if (vim.visualMode) {\n            updateLastSelection(cm, vim);\n        }\n        if (lastSelection) {\n            var anchor = lastSelection.anchorMark.find();\n            var head = lastSelection.headMark.find();\n            if (!anchor || !head) {\n                return;\n            }\n            vim.sel = {\n                anchor: anchor,\n                head: head\n            };\n            vim.visualMode = true;\n            vim.visualLine = lastSelection.visualLine;\n            vim.visualBlock = lastSelection.visualBlock;\n            updateCmSelection(cm);\n            updateMark(cm, vim, '<', cursorMin(anchor, head));\n            updateMark(cm, vim, '>', cursorMax(anchor, head));\n            CodeMirror.signal(cm, 'vim-mode-change', {\n                mode: 'visual',\n                subMode: vim.visualLine ? 'linewise' :\n                    vim.visualBlock ? 'blockwise' : ''\n            });\n        }\n    },\n    joinLines: function (cm, actionArgs, vim) {\n        var curStart, curEnd;\n        if (vim.visualMode) {\n            curStart = cm.getCursor('anchor');\n            curEnd = cm.getCursor('head');\n            if (cursorIsBefore(curEnd, curStart)) {\n                var tmp = curEnd;\n                curEnd = curStart;\n                curStart = tmp;\n            }\n            curEnd.ch = lineLength(cm, curEnd.line) - 1;\n        }\n        else {\n            var repeat = Math.max(actionArgs.repeat, 2);\n            curStart = cm.getCursor();\n            curEnd = clipCursorToContent(cm, new Pos(curStart.line + repeat - 1, Infinity));\n        }\n        var finalCh = 0;\n        for (var i = curStart.line; i < curEnd.line; i++) {\n            finalCh = lineLength(cm, curStart.line);\n            var text = '';\n            var nextStartCh = 0;\n            if (!actionArgs.keepSpaces) {\n                var nextLine = cm.getLine(curStart.line + 1);\n                nextStartCh = nextLine.search(/\\S/);\n                if (nextStartCh == -1) {\n                    nextStartCh = nextLine.length;\n                }\n                else {\n                    text = \" \";\n                }\n            }\n            cm.replaceRange(text, new Pos(curStart.line, finalCh), new Pos(curStart.line + 1, nextStartCh));\n        }\n        var curFinalPos = clipCursorToContent(cm, new Pos(curStart.line, finalCh));\n        if (vim.visualMode) {\n            exitVisualMode(cm, false);\n        }\n        cm.setCursor(curFinalPos);\n    },\n    newLineAndEnterInsertMode: function (cm, actionArgs, vim) {\n        vim.insertMode = true;\n        var insertAt = copyCursor(cm.getCursor());\n        if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n            cm.replaceRange('\\n', new Pos(cm.firstLine(), 0));\n            cm.setCursor(cm.firstLine(), 0);\n        }\n        else {\n            insertAt.line = (actionArgs.after) ? insertAt.line :\n                insertAt.line - 1;\n            insertAt.ch = lineLength(cm, insertAt.line);\n            cm.setCursor(insertAt);\n            var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment ||\n                CodeMirror.commands.newlineAndIndent;\n            newlineFn(cm);\n        }\n        this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);\n    },\n    paste: function (cm, actionArgs, vim) {\n        var _this = this;\n        var register = vimGlobalState.registerController.getRegister(actionArgs.registerName);\n        if (actionArgs.registerName === '+') {\n            navigator.clipboard.readText().then(function (value) {\n                _this.continuePaste(cm, actionArgs, vim, value, register);\n            });\n        }\n        else {\n            var text = register.toString();\n            this.continuePaste(cm, actionArgs, vim, text, register);\n        }\n    },\n    continuePaste: function (cm, actionArgs, vim, text, register) {\n        var cur = copyCursor(cm.getCursor());\n        if (!text) {\n            return;\n        }\n        if (actionArgs.matchIndent) {\n            var tabSize = cm.getOption(\"tabSize\");\n            var whitespaceLength = function (str) {\n                var tabs = (str.split(\"\\t\").length - 1);\n                var spaces = (str.split(\" \").length - 1);\n                return tabs * tabSize + spaces * 1;\n            };\n            var currentLine = cm.getLine(cm.getCursor().line);\n            var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\n            var chompedText = text.replace(/\\n$/, '');\n            var wasChomped = text !== chompedText;\n            var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n            var text = chompedText.replace(/^\\s*/gm, function (wspace) {\n                var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n                if (newIndent < 0) {\n                    return \"\";\n                }\n                else if (cm.getOption(\"indentWithTabs\")) {\n                    var quotient = Math.floor(newIndent / tabSize);\n                    return Array(quotient + 1).join('\\t');\n                }\n                else {\n                    return Array(newIndent + 1).join(' ');\n                }\n            });\n            text += wasChomped ? \"\\n\" : \"\";\n        }\n        if (actionArgs.repeat > 1) {\n            var text = Array(actionArgs.repeat + 1).join(text);\n        }\n        var linewise = register.linewise;\n        var blockwise = register.blockwise;\n        if (blockwise) {\n            text = text.split('\\n');\n            if (linewise) {\n                text.pop();\n            }\n            for (var i = 0; i < text.length; i++) {\n                text[i] = (text[i] == '') ? ' ' : text[i];\n            }\n            cur.ch += actionArgs.after ? 1 : 0;\n            cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);\n        }\n        else if (linewise) {\n            if (vim.visualMode) {\n                text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n            }\n            else if (actionArgs.after) {\n                text = '\\n' + text.slice(0, text.length - 1);\n                cur.ch = lineLength(cm, cur.line);\n            }\n            else {\n                cur.ch = 0;\n            }\n        }\n        else {\n            cur.ch += actionArgs.after ? 1 : 0;\n        }\n        var curPosFinal;\n        var idx;\n        if (vim.visualMode) {\n            vim.lastPastedText = text;\n            var lastSelectionCurEnd;\n            var selectedArea = getSelectedAreaRange(cm, vim);\n            var selectionStart = selectedArea[0];\n            var selectionEnd = selectedArea[1];\n            var selectedText = cm.getSelection();\n            var selections = cm.listSelections();\n            var emptyStrings = new Array(selections.length).join('1').split('1');\n            if (vim.lastSelection) {\n                lastSelectionCurEnd = vim.lastSelection.headMark.find();\n            }\n            vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n            if (blockwise) {\n                cm.replaceSelections(emptyStrings);\n                selectionEnd = new Pos(selectionStart.line + text.length - 1, selectionStart.ch);\n                cm.setCursor(selectionStart);\n                selectBlock(cm, selectionEnd);\n                cm.replaceSelections(text);\n                curPosFinal = selectionStart;\n            }\n            else if (vim.visualBlock) {\n                cm.replaceSelections(emptyStrings);\n                cm.setCursor(selectionStart);\n                cm.replaceRange(text, selectionStart, selectionStart);\n                curPosFinal = selectionStart;\n            }\n            else {\n                cm.replaceRange(text, selectionStart, selectionEnd);\n                curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n            }\n            if (lastSelectionCurEnd) {\n                vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n            }\n            if (linewise) {\n                curPosFinal.ch = 0;\n            }\n        }\n        else {\n            if (blockwise) {\n                cm.setCursor(cur);\n                for (var i = 0; i < text.length; i++) {\n                    var line = cur.line + i;\n                    if (line > cm.lastLine()) {\n                        cm.replaceRange('\\n', new Pos(line, 0));\n                    }\n                    var lastCh = lineLength(cm, line);\n                    if (lastCh < cur.ch) {\n                        extendLineToColumn(cm, line, cur.ch);\n                    }\n                }\n                cm.setCursor(cur);\n                selectBlock(cm, new Pos(cur.line + text.length - 1, cur.ch));\n                cm.replaceSelections(text);\n                curPosFinal = cur;\n            }\n            else {\n                cm.replaceRange(text, cur);\n                if (linewise && actionArgs.after) {\n                    curPosFinal = new Pos(cur.line + 1, findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));\n                }\n                else if (linewise && !actionArgs.after) {\n                    curPosFinal = new Pos(cur.line, findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));\n                }\n                else if (!linewise && actionArgs.after) {\n                    idx = cm.indexFromPos(cur);\n                    curPosFinal = cm.posFromIndex(idx + text.length - 1);\n                }\n                else {\n                    idx = cm.indexFromPos(cur);\n                    curPosFinal = cm.posFromIndex(idx + text.length);\n                }\n            }\n        }\n        if (vim.visualMode) {\n            exitVisualMode(cm, false);\n        }\n        cm.setCursor(curPosFinal);\n    },\n    undo: function (cm, actionArgs) {\n        cm.operation(function () {\n            repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n            cm.setCursor(clipCursorToContent(cm, cm.getCursor('start')));\n        });\n    },\n    redo: function (cm, actionArgs) {\n        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n    },\n    setRegister: function (_cm, actionArgs, vim) {\n        vim.inputState.registerName = actionArgs.selectedCharacter;\n    },\n    setMark: function (cm, actionArgs, vim) {\n        var markName = actionArgs.selectedCharacter;\n        updateMark(cm, vim, markName, cm.getCursor());\n    },\n    replace: function (cm, actionArgs, vim) {\n        var replaceWith = actionArgs.selectedCharacter;\n        var curStart = cm.getCursor();\n        var replaceTo;\n        var curEnd;\n        var selections = cm.listSelections();\n        if (vim.visualMode) {\n            curStart = cm.getCursor('start');\n            curEnd = cm.getCursor('end');\n        }\n        else {\n            var line = cm.getLine(curStart.line);\n            replaceTo = curStart.ch + actionArgs.repeat;\n            if (replaceTo > line.length) {\n                replaceTo = line.length;\n            }\n            curEnd = new Pos(curStart.line, replaceTo);\n        }\n        var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n        curStart = newPositions.start;\n        curEnd = newPositions.end;\n        if (replaceWith == '\\n') {\n            if (!vim.visualMode)\n                cm.replaceRange('', curStart, curEnd);\n            (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n        }\n        else {\n            var replaceWithStr = cm.getRange(curStart, curEnd);\n            replaceWithStr = replaceWithStr.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, replaceWith);\n            replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n            if (vim.visualBlock) {\n                var spaces = new Array(cm.getOption(\"tabSize\") + 1).join(' ');\n                replaceWithStr = cm.getSelection();\n                replaceWithStr = replaceWithStr.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, replaceWith);\n                replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n                cm.replaceSelections(replaceWithStr);\n            }\n            else {\n                cm.replaceRange(replaceWithStr, curStart, curEnd);\n            }\n            if (vim.visualMode) {\n                curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ?\n                    selections[0].anchor : selections[0].head;\n                cm.setCursor(curStart);\n                exitVisualMode(cm, false);\n            }\n            else {\n                cm.setCursor(offsetCursor(curEnd, 0, -1));\n            }\n        }\n    },\n    incrementNumberToken: function (cm, actionArgs) {\n        var cur = cm.getCursor();\n        var lineStr = cm.getLine(cur.line);\n        var re = /(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;\n        var match;\n        var start;\n        var end;\n        var numberStr;\n        while ((match = re.exec(lineStr)) !== null) {\n            start = match.index;\n            end = start + match[0].length;\n            if (cur.ch < end)\n                break;\n        }\n        if (!actionArgs.backtrack && (end <= cur.ch))\n            return;\n        if (match) {\n            var baseStr = match[2] || match[4];\n            var digits = match[3] || match[5];\n            var increment = actionArgs.increase ? 1 : -1;\n            var base = { '0b': 2, '0': 8, '': 10, '0x': 16 }[baseStr.toLowerCase()];\n            var number = parseInt(match[1] + digits, base) + (increment * actionArgs.repeat);\n            numberStr = number.toString(base);\n            var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : '';\n            if (numberStr.charAt(0) === '-') {\n                numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);\n            }\n            else {\n                numberStr = baseStr + zeroPadding + numberStr;\n            }\n            var from = new Pos(cur.line, start);\n            var to = new Pos(cur.line, end);\n            cm.replaceRange(numberStr, from, to);\n        }\n        else {\n            return;\n        }\n        cm.setCursor(new Pos(cur.line, start + numberStr.length - 1));\n    },\n    repeatLastEdit: function (cm, actionArgs, vim) {\n        var lastEditInputState = vim.lastEditInputState;\n        if (!lastEditInputState) {\n            return;\n        }\n        var repeat = actionArgs.repeat;\n        if (repeat && actionArgs.repeatIsExplicit) {\n            vim.lastEditInputState.repeatOverride = repeat;\n        }\n        else {\n            repeat = vim.lastEditInputState.repeatOverride || repeat;\n        }\n        repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\n    },\n    indent: function (cm, actionArgs) {\n        cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n    },\n    exitInsertMode: exitInsertMode\n};\nfunction defineAction(name, fn) {\n    actions[name] = fn;\n}\nfunction clipCursorToContent(cm, cur, oldCur) {\n    var vim = cm.state.vim;\n    var includeLineBreak = vim.insertMode || vim.visualMode;\n    var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine());\n    var text = cm.getLine(line);\n    var maxCh = text.length - 1 + !!includeLineBreak;\n    var ch = Math.min(Math.max(0, cur.ch), maxCh);\n    var charCode = text.charCodeAt(ch);\n    if (0xDC00 < charCode && charCode < 0xDFFF) {\n        var direction = 1;\n        if (oldCur && oldCur.line == line) {\n            if (oldCur.ch > ch) {\n                direction = -1;\n            }\n        }\n        ch += direction;\n        if (ch > maxCh)\n            ch -= 2;\n    }\n    return new Pos(line, ch);\n}\nfunction copyArgs(args) {\n    var ret = {};\n    for (var prop in args) {\n        if (args.hasOwnProperty(prop)) {\n            ret[prop] = args[prop];\n        }\n    }\n    return ret;\n}\nfunction offsetCursor(cur, offsetLine, offsetCh) {\n    if (typeof offsetLine === 'object') {\n        offsetCh = offsetLine.ch;\n        offsetLine = offsetLine.line;\n    }\n    return new Pos(cur.line + offsetLine, cur.ch + offsetCh);\n}\nfunction commandMatches(keys, keyMap, context, inputState) {\n    var match, partial = [], full = [];\n    for (var i = 0; i < keyMap.length; i++) {\n        var command = keyMap[i];\n        if (context == 'insert' && command.context != 'insert' ||\n            command.context && command.context != context ||\n            inputState.operator && command.type == 'action' ||\n            !(match = commandMatch(keys, command.keys))) {\n            continue;\n        }\n        if (match == 'partial') {\n            partial.push(command);\n        }\n        if (match == 'full') {\n            full.push(command);\n        }\n    }\n    return {\n        partial: partial.length && partial,\n        full: full.length && full\n    };\n}\nfunction commandMatch(pressed, mapped) {\n    if (mapped.slice(-11) == '<character>') {\n        var prefixLen = mapped.length - 11;\n        var pressedPrefix = pressed.slice(0, prefixLen);\n        var mappedPrefix = mapped.slice(0, prefixLen);\n        return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' :\n            mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n    }\n    else {\n        return pressed == mapped ? 'full' :\n            mapped.indexOf(pressed) == 0 ? 'partial' : false;\n    }\n}\nfunction lastChar(keys) {\n    var match = /^.*(<[^>]+>)$/.exec(keys);\n    var selectedCharacter = match ? match[1] : keys.slice(-1);\n    if (selectedCharacter.length > 1) {\n        switch (selectedCharacter) {\n            case '<CR>':\n                selectedCharacter = '\\n';\n                break;\n            case '<Space>':\n                selectedCharacter = ' ';\n                break;\n            default:\n                selectedCharacter = '';\n                break;\n        }\n    }\n    return selectedCharacter;\n}\nfunction repeatFn(cm, fn, repeat) {\n    return function () {\n        for (var i = 0; i < repeat; i++) {\n            fn(cm);\n        }\n    };\n}\nfunction copyCursor(cur) {\n    return new Pos(cur.line, cur.ch);\n}\nfunction cursorEqual(cur1, cur2) {\n    return cur1.ch == cur2.ch && cur1.line == cur2.line;\n}\nfunction cursorIsBefore(cur1, cur2) {\n    if (cur1.line < cur2.line) {\n        return true;\n    }\n    if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n        return true;\n    }\n    return false;\n}\nfunction cursorMin(cur1, cur2) {\n    if (arguments.length > 2) {\n        cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n    }\n    return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n}\nfunction cursorMax(cur1, cur2) {\n    if (arguments.length > 2) {\n        cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n    }\n    return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n}\nfunction cursorIsBetween(cur1, cur2, cur3) {\n    var cur1before2 = cursorIsBefore(cur1, cur2);\n    var cur2before3 = cursorIsBefore(cur2, cur3);\n    return cur1before2 && cur2before3;\n}\nfunction lineLength(cm, lineNum) {\n    return cm.getLine(lineNum).length;\n}\nfunction trim(s) {\n    if (s.trim) {\n        return s.trim();\n    }\n    return s.replace(/^\\s+|\\s+$/g, '');\n}\nfunction escapeRegex(s) {\n    return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n}\nfunction extendLineToColumn(cm, lineNum, column) {\n    var endCh = lineLength(cm, lineNum);\n    var spaces = new Array(column - endCh + 1).join(' ');\n    cm.setCursor(new Pos(lineNum, endCh));\n    cm.replaceRange(spaces, cm.getCursor());\n}\nfunction selectBlock(cm, selectionEnd) {\n    var selections = [], ranges = cm.listSelections();\n    var head = copyCursor(cm.clipPos(selectionEnd));\n    var isClipped = !cursorEqual(selectionEnd, head);\n    var curHead = cm.getCursor('head');\n    var primIndex = getIndex(ranges, curHead);\n    var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n    var max = ranges.length - 1;\n    var index = max - primIndex > primIndex ? max : 0;\n    var base = ranges[index].anchor;\n    var firstLine = Math.min(base.line, head.line);\n    var lastLine = Math.max(base.line, head.line);\n    var baseCh = base.ch, headCh = head.ch;\n    var dir = ranges[index].head.ch - baseCh;\n    var newDir = headCh - baseCh;\n    if (dir > 0 && newDir <= 0) {\n        baseCh++;\n        if (!isClipped) {\n            headCh--;\n        }\n    }\n    else if (dir < 0 && newDir >= 0) {\n        baseCh--;\n        if (!wasClipped) {\n            headCh++;\n        }\n    }\n    else if (dir < 0 && newDir == -1) {\n        baseCh--;\n        headCh++;\n    }\n    for (var line = firstLine; line <= lastLine; line++) {\n        var range = { anchor: new Pos(line, baseCh), head: new Pos(line, headCh) };\n        selections.push(range);\n    }\n    cm.setSelections(selections);\n    selectionEnd.ch = headCh;\n    base.ch = baseCh;\n    return base;\n}\nfunction selectForInsert(cm, head, height) {\n    var sel = [];\n    for (var i = 0; i < height; i++) {\n        var lineHead = offsetCursor(head, i, 0);\n        sel.push({ anchor: lineHead, head: lineHead });\n    }\n    cm.setSelections(sel, 0);\n}\nfunction getIndex(ranges, cursor, end) {\n    for (var i = 0; i < ranges.length; i++) {\n        var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n        var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n        if (atAnchor || atHead) {\n            return i;\n        }\n    }\n    return -1;\n}\nfunction getSelectedAreaRange(cm, vim) {\n    var lastSelection = vim.lastSelection;\n    var getCurrentSelectedAreaRange = function () {\n        var selections = cm.listSelections();\n        var start = selections[0];\n        var end = selections[selections.length - 1];\n        var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n        var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n        return [selectionStart, selectionEnd];\n    };\n    var getLastSelectedAreaRange = function () {\n        var selectionStart = cm.getCursor();\n        var selectionEnd = cm.getCursor();\n        var block = lastSelection.visualBlock;\n        if (block) {\n            var width = block.width;\n            var height = block.height;\n            selectionEnd = new Pos(selectionStart.line + height, selectionStart.ch + width);\n            var selections = [];\n            for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n                var anchor = new Pos(i, selectionStart.ch);\n                var head = new Pos(i, selectionEnd.ch);\n                var range = { anchor: anchor, head: head };\n                selections.push(range);\n            }\n            cm.setSelections(selections);\n        }\n        else {\n            var start = lastSelection.anchorMark.find();\n            var end = lastSelection.headMark.find();\n            var line = end.line - start.line;\n            var ch = end.ch - start.ch;\n            selectionEnd = { line: selectionEnd.line + line, ch: line ? selectionEnd.ch : ch + selectionEnd.ch };\n            if (lastSelection.visualLine) {\n                selectionStart = new Pos(selectionStart.line, 0);\n                selectionEnd = new Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n            }\n            cm.setSelection(selectionStart, selectionEnd);\n        }\n        return [selectionStart, selectionEnd];\n    };\n    if (!vim.visualMode) {\n        return getLastSelectedAreaRange();\n    }\n    else {\n        return getCurrentSelectedAreaRange();\n    }\n}\nfunction updateLastSelection(cm, vim) {\n    var anchor = vim.sel.anchor;\n    var head = vim.sel.head;\n    if (vim.lastPastedText) {\n        head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n        vim.lastPastedText = null;\n    }\n    vim.lastSelection = { 'anchorMark': cm.setBookmark(anchor),\n        'headMark': cm.setBookmark(head),\n        'anchor': copyCursor(anchor),\n        'head': copyCursor(head),\n        'visualMode': vim.visualMode,\n        'visualLine': vim.visualLine,\n        'visualBlock': vim.visualBlock };\n}\nfunction expandSelection(cm, start, end) {\n    var sel = cm.state.vim.sel;\n    var head = sel.head;\n    var anchor = sel.anchor;\n    var tmp;\n    if (cursorIsBefore(end, start)) {\n        tmp = end;\n        end = start;\n        start = tmp;\n    }\n    if (cursorIsBefore(head, anchor)) {\n        head = cursorMin(start, head);\n        anchor = cursorMax(anchor, end);\n    }\n    else {\n        anchor = cursorMin(start, anchor);\n        head = cursorMax(head, end);\n        head = offsetCursor(head, 0, -1);\n        if (head.ch == -1 && head.line != cm.firstLine()) {\n            head = new Pos(head.line - 1, lineLength(cm, head.line - 1));\n        }\n    }\n    return [anchor, head];\n}\nfunction updateCmSelection(cm, sel, mode) {\n    var vim = cm.state.vim;\n    sel = sel || vim.sel;\n    var mode = mode ||\n        vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n    var cmSel = makeCmSelection(cm, sel, mode);\n    cm.setSelections(cmSel.ranges, cmSel.primary);\n}\nfunction makeCmSelection(cm, sel, mode, exclusive) {\n    var head = copyCursor(sel.head);\n    var anchor = copyCursor(sel.anchor);\n    if (mode == 'char') {\n        var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        head = offsetCursor(sel.head, 0, headOffset);\n        anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n        return {\n            ranges: [{ anchor: anchor, head: head }],\n            primary: 0\n        };\n    }\n    else if (mode == 'line') {\n        if (!cursorIsBefore(sel.head, sel.anchor)) {\n            anchor.ch = 0;\n            var lastLine = cm.lastLine();\n            if (head.line > lastLine) {\n                head.line = lastLine;\n            }\n            head.ch = lineLength(cm, head.line);\n        }\n        else {\n            head.ch = 0;\n            anchor.ch = lineLength(cm, anchor.line);\n        }\n        return {\n            ranges: [{ anchor: anchor, head: head }],\n            primary: 0\n        };\n    }\n    else if (mode == 'block') {\n        var top = Math.min(anchor.line, head.line), fromCh = anchor.ch, bottom = Math.max(anchor.line, head.line), toCh = head.ch;\n        if (fromCh < toCh) {\n            toCh += 1;\n        }\n        else {\n            fromCh += 1;\n        }\n        ;\n        var height = bottom - top + 1;\n        var primary = head.line == top ? 0 : height - 1;\n        var ranges = [];\n        for (var i = 0; i < height; i++) {\n            ranges.push({\n                anchor: new Pos(top + i, fromCh),\n                head: new Pos(top + i, toCh)\n            });\n        }\n        return {\n            ranges: ranges,\n            primary: primary\n        };\n    }\n}\nfunction getHead(cm) {\n    var cur = cm.getCursor('head');\n    if (cm.getSelection().length == 1) {\n        cur = cursorMin(cur, cm.getCursor('anchor'));\n    }\n    return cur;\n}\nfunction exitVisualMode(cm, moveHead) {\n    var vim = cm.state.vim;\n    if (moveHead !== false) {\n        cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n    }\n    updateLastSelection(cm, vim);\n    vim.visualMode = false;\n    vim.visualLine = false;\n    vim.visualBlock = false;\n    if (!vim.insertMode)\n        CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"normal\" });\n}\nfunction clipToLine(cm, curStart, curEnd) {\n    var selection = cm.getRange(curStart, curEnd);\n    if (/\\n\\s*$/.test(selection)) {\n        var lines = selection.split('\\n');\n        lines.pop();\n        var line;\n        for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n            curEnd.line--;\n            curEnd.ch = 0;\n        }\n        if (line) {\n            curEnd.line--;\n            curEnd.ch = lineLength(cm, curEnd.line);\n        }\n        else {\n            curEnd.ch = 0;\n        }\n    }\n}\nfunction expandSelectionToLine(_cm, curStart, curEnd) {\n    curStart.ch = 0;\n    curEnd.ch = 0;\n    curEnd.line++;\n}\nfunction findFirstNonWhiteSpaceCharacter(text) {\n    if (!text) {\n        return 0;\n    }\n    var firstNonWS = text.search(/\\S/);\n    return firstNonWS == -1 ? text.length : firstNonWS;\n}\nfunction expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {\n    var cur = getHead(cm);\n    var line = cm.getLine(cur.line);\n    var idx = cur.ch;\n    var test = noSymbol ? wordCharTest[0] : bigWordCharTest[0];\n    while (!test(line.charAt(idx))) {\n        idx++;\n        if (idx >= line.length) {\n            return null;\n        }\n    }\n    if (bigWord) {\n        test = bigWordCharTest[0];\n    }\n    else {\n        test = wordCharTest[0];\n        if (!test(line.charAt(idx))) {\n            test = wordCharTest[1];\n        }\n    }\n    var end = idx, start = idx;\n    while (test(line.charAt(end)) && end < line.length) {\n        end++;\n    }\n    while (test(line.charAt(start)) && start >= 0) {\n        start--;\n    }\n    start++;\n    if (inclusive) {\n        var wordEnd = end;\n        while (/\\s/.test(line.charAt(end)) && end < line.length) {\n            end++;\n        }\n        if (wordEnd == end) {\n            var wordStart = start;\n            while (/\\s/.test(line.charAt(start - 1)) && start > 0) {\n                start--;\n            }\n            if (!start) {\n                start = wordStart;\n            }\n        }\n    }\n    return { start: new Pos(cur.line, start), end: new Pos(cur.line, end) };\n}\nfunction expandTagUnderCursor(cm, head, inclusive) {\n    var cur = head;\n    if (!CodeMirror.findMatchingTag || !CodeMirror.findEnclosingTag) {\n        return { start: cur, end: cur };\n    }\n    var tags = CodeMirror.findMatchingTag(cm, head) || CodeMirror.findEnclosingTag(cm, head);\n    if (!tags || !tags.open || !tags.close) {\n        return { start: cur, end: cur };\n    }\n    if (inclusive) {\n        return { start: tags.open.from, end: tags.close.to };\n    }\n    return { start: tags.open.to, end: tags.close.from };\n}\nfunction recordJumpPosition(cm, oldCur, newCur) {\n    if (!cursorEqual(oldCur, newCur)) {\n        vimGlobalState.jumpList.add(cm, oldCur, newCur);\n    }\n}\nfunction recordLastCharacterSearch(increment, args) {\n    vimGlobalState.lastCharacterSearch.increment = increment;\n    vimGlobalState.lastCharacterSearch.forward = args.forward;\n    vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n}\nvar symbolToMode = {\n    '(': 'bracket', ')': 'bracket', '{': 'bracket', '}': 'bracket',\n    '[': 'section', ']': 'section',\n    '*': 'comment', '/': 'comment',\n    'm': 'method', 'M': 'method',\n    '#': 'preprocess'\n};\nvar findSymbolModes = {\n    bracket: {\n        isComplete: function (state) {\n            if (state.nextCh === state.symb) {\n                state.depth++;\n                if (state.depth >= 1)\n                    return true;\n            }\n            else if (state.nextCh === state.reverseSymb) {\n                state.depth--;\n            }\n            return false;\n        }\n    },\n    section: {\n        init: function (state) {\n            state.curMoveThrough = true;\n            state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n        },\n        isComplete: function (state) {\n            return state.index === 0 && state.nextCh === state.symb;\n        }\n    },\n    comment: {\n        isComplete: function (state) {\n            var found = state.lastCh === '*' && state.nextCh === '/';\n            state.lastCh = state.nextCh;\n            return found;\n        }\n    },\n    method: {\n        init: function (state) {\n            state.symb = (state.symb === 'm' ? '{' : '}');\n            state.reverseSymb = state.symb === '{' ? '}' : '{';\n        },\n        isComplete: function (state) {\n            if (state.nextCh === state.symb)\n                return true;\n            return false;\n        }\n    },\n    preprocess: {\n        init: function (state) {\n            state.index = 0;\n        },\n        isComplete: function (state) {\n            if (state.nextCh === '#') {\n                var token = state.lineText.match(/^#(\\w+)/)[1];\n                if (token === 'endif') {\n                    if (state.forward && state.depth === 0) {\n                        return true;\n                    }\n                    state.depth++;\n                }\n                else if (token === 'if') {\n                    if (!state.forward && state.depth === 0) {\n                        return true;\n                    }\n                    state.depth--;\n                }\n                if (token === 'else' && state.depth === 0)\n                    return true;\n            }\n            return false;\n        }\n    }\n};\nfunction findSymbol(cm, repeat, forward, symb) {\n    var cur = copyCursor(cm.getCursor());\n    var increment = forward ? 1 : -1;\n    var endLine = forward ? cm.lineCount() : -1;\n    var curCh = cur.ch;\n    var line = cur.line;\n    var lineText = cm.getLine(line);\n    var state = {\n        lineText: lineText,\n        nextCh: lineText.charAt(curCh),\n        lastCh: null,\n        index: curCh,\n        symb: symb,\n        reverseSymb: (forward ? { ')': '(', '}': '{' } : { '(': ')', '{': '}' })[symb],\n        forward: forward,\n        depth: 0,\n        curMoveThrough: false\n    };\n    var mode = symbolToMode[symb];\n    if (!mode)\n        return cur;\n    var init = findSymbolModes[mode].init;\n    var isComplete = findSymbolModes[mode].isComplete;\n    if (init) {\n        init(state);\n    }\n    while (line !== endLine && repeat) {\n        state.index += increment;\n        state.nextCh = state.lineText.charAt(state.index);\n        if (!state.nextCh) {\n            line += increment;\n            state.lineText = cm.getLine(line) || '';\n            if (increment > 0) {\n                state.index = 0;\n            }\n            else {\n                var lineLen = state.lineText.length;\n                state.index = (lineLen > 0) ? (lineLen - 1) : 0;\n            }\n            state.nextCh = state.lineText.charAt(state.index);\n        }\n        if (isComplete(state)) {\n            cur.line = line;\n            cur.ch = state.index;\n            repeat--;\n        }\n    }\n    if (state.nextCh || state.curMoveThrough) {\n        return new Pos(line, state.index);\n    }\n    return cur;\n}\nfunction findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n    var lineNum = cur.line;\n    var pos = cur.ch;\n    var line = cm.getLine(lineNum);\n    var dir = forward ? 1 : -1;\n    var charTests = bigWord ? bigWordCharTest : wordCharTest;\n    if (emptyLineIsWord && line == '') {\n        lineNum += dir;\n        line = cm.getLine(lineNum);\n        if (!isLine(cm, lineNum)) {\n            return null;\n        }\n        pos = (forward) ? 0 : line.length;\n    }\n    while (true) {\n        if (emptyLineIsWord && line == '') {\n            return { from: 0, to: 0, line: lineNum };\n        }\n        var stop = (dir > 0) ? line.length : -1;\n        var wordStart = stop, wordEnd = stop;\n        while (pos != stop) {\n            var foundWord = false;\n            for (var i = 0; i < charTests.length && !foundWord; ++i) {\n                if (charTests[i](line.charAt(pos))) {\n                    wordStart = pos;\n                    while (pos != stop && charTests[i](line.charAt(pos))) {\n                        pos += dir;\n                    }\n                    wordEnd = pos;\n                    foundWord = wordStart != wordEnd;\n                    if (wordStart == cur.ch && lineNum == cur.line &&\n                        wordEnd == wordStart + dir) {\n                        continue;\n                    }\n                    else {\n                        return {\n                            from: Math.min(wordStart, wordEnd + 1),\n                            to: Math.max(wordStart, wordEnd),\n                            line: lineNum\n                        };\n                    }\n                }\n            }\n            if (!foundWord) {\n                pos += dir;\n            }\n        }\n        lineNum += dir;\n        if (!isLine(cm, lineNum)) {\n            return null;\n        }\n        line = cm.getLine(lineNum);\n        pos = (dir > 0) ? 0 : line.length;\n    }\n}\nfunction moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n    var curStart = copyCursor(cur);\n    var words = [];\n    if (forward && !wordEnd || !forward && wordEnd) {\n        repeat++;\n    }\n    var emptyLineIsWord = !(forward && wordEnd);\n    for (var i = 0; i < repeat; i++) {\n        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n        if (!word) {\n            var eodCh = lineLength(cm, cm.lastLine());\n            words.push(forward\n                ? { line: cm.lastLine(), from: eodCh, to: eodCh }\n                : { line: 0, from: 0, to: 0 });\n            break;\n        }\n        words.push(word);\n        cur = new Pos(word.line, forward ? (word.to - 1) : word.from);\n    }\n    var shortCircuit = words.length != repeat;\n    var firstWord = words[0];\n    var lastWord = words.pop();\n    if (forward && !wordEnd) {\n        if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n            lastWord = words.pop();\n        }\n        return new Pos(lastWord.line, lastWord.from);\n    }\n    else if (forward && wordEnd) {\n        return new Pos(lastWord.line, lastWord.to - 1);\n    }\n    else if (!forward && wordEnd) {\n        if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n            lastWord = words.pop();\n        }\n        return new Pos(lastWord.line, lastWord.to);\n    }\n    else {\n        return new Pos(lastWord.line, lastWord.from);\n    }\n}\nfunction moveToEol(cm, head, motionArgs, vim, keepHPos) {\n    var cur = head;\n    var retval = new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n    var end = cm.clipPos(retval);\n    end.ch--;\n    if (!keepHPos) {\n        vim.lastHPos = Infinity;\n        vim.lastHSPos = cm.charCoords(end, 'div').left;\n    }\n    return retval;\n}\nfunction moveToCharacter(cm, repeat, forward, character) {\n    var cur = cm.getCursor();\n    var start = cur.ch;\n    var idx;\n    for (var i = 0; i < repeat; i++) {\n        var line = cm.getLine(cur.line);\n        idx = charIdxInLine(start, line, character, forward, true);\n        if (idx == -1) {\n            return null;\n        }\n        start = idx;\n    }\n    return new Pos(cm.getCursor().line, idx);\n}\nfunction moveToColumn(cm, repeat) {\n    var line = cm.getCursor().line;\n    return clipCursorToContent(cm, new Pos(line, repeat - 1));\n}\nfunction updateMark(cm, vim, markName, pos) {\n    if (!inArray(markName, validMarks)) {\n        return;\n    }\n    if (vim.marks[markName]) {\n        vim.marks[markName].clear();\n    }\n    vim.marks[markName] = cm.setBookmark(pos);\n}\nfunction charIdxInLine(start, line, character, forward, includeChar) {\n    var idx;\n    if (forward) {\n        idx = line.indexOf(character, start + 1);\n        if (idx != -1 && !includeChar) {\n            idx -= 1;\n        }\n    }\n    else {\n        idx = line.lastIndexOf(character, start - 1);\n        if (idx != -1 && !includeChar) {\n            idx += 1;\n        }\n    }\n    return idx;\n}\nfunction findParagraph(cm, head, repeat, dir, inclusive) {\n    var line = head.line;\n    var min = cm.firstLine();\n    var max = cm.lastLine();\n    var start, end, i = line;\n    function isEmpty(i) { return !/\\S/.test(cm.getLine(i)); } // ace_patch\n    function isBoundary(i, dir, any) {\n        if (any) {\n            return isEmpty(i) != isEmpty(i + dir);\n        }\n        return !isEmpty(i) && isEmpty(i + dir);\n    }\n    function skipFold(i) {\n        dir = dir > 0 ? 1 : -1;\n        var foldLine = cm.ace.session.getFoldLine(i);\n        if (foldLine) {\n            if (i + dir > foldLine.start.row && i + dir < foldLine.end.row)\n                dir = (dir > 0 ? foldLine.end.row : foldLine.start.row) - i;\n        }\n    }\n    if (dir) {\n        while (min <= i && i <= max && repeat > 0) {\n            skipFold(i);\n            if (isBoundary(i, dir)) {\n                repeat--;\n            }\n            i += dir;\n        }\n        return new Pos(i, 0);\n    }\n    var vim = cm.state.vim;\n    if (vim.visualLine && isBoundary(line, 1, true)) {\n        var anchor = vim.sel.anchor;\n        if (isBoundary(anchor.line, -1, true)) {\n            if (!inclusive || anchor.line != line) {\n                line += 1;\n            }\n        }\n    }\n    var startState = isEmpty(line);\n    for (i = line; i <= max && repeat; i++) {\n        if (isBoundary(i, 1, true)) {\n            if (!inclusive || isEmpty(i) != startState) {\n                repeat--;\n            }\n        }\n    }\n    end = new Pos(i, 0);\n    if (i > max && !startState) {\n        startState = true;\n    }\n    else {\n        inclusive = false;\n    }\n    for (i = line; i > min; i--) {\n        if (!inclusive || isEmpty(i) == startState || i == line) {\n            if (isBoundary(i, -1, true)) {\n                break;\n            }\n        }\n    }\n    start = new Pos(i, 0);\n    return { start: start, end: end };\n}\nfunction getSentence(cm, cur, repeat, dir, inclusive /*includes whitespace*/) {\n    function nextChar(curr) {\n        if (curr.pos + curr.dir < 0 || curr.pos + curr.dir >= curr.line.length) {\n            curr.line = null;\n        }\n        else {\n            curr.pos += curr.dir;\n        }\n    }\n    function forward(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var curr = {\n            line: line,\n            ln: ln,\n            pos: pos,\n            dir: dir,\n        };\n        if (curr.line === \"\") {\n            return { ln: curr.ln, pos: curr.pos };\n        }\n        var lastSentencePos = curr.pos;\n        nextChar(curr);\n        while (curr.line !== null) {\n            lastSentencePos = curr.pos;\n            if (isEndOfSentenceSymbol(curr.line[curr.pos])) {\n                if (!inclusive) {\n                    return { ln: curr.ln, pos: curr.pos + 1 };\n                }\n                else {\n                    nextChar(curr);\n                    while (curr.line !== null) {\n                        if (isWhiteSpaceString(curr.line[curr.pos])) {\n                            lastSentencePos = curr.pos;\n                            nextChar(curr);\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                    return { ln: curr.ln, pos: lastSentencePos + 1 };\n                }\n            }\n            nextChar(curr);\n        }\n        return { ln: curr.ln, pos: lastSentencePos + 1 };\n    }\n    function reverse(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var curr = {\n            line: line,\n            ln: ln,\n            pos: pos,\n            dir: dir,\n        };\n        if (curr.line === \"\") {\n            return { ln: curr.ln, pos: curr.pos };\n        }\n        var lastSentencePos = curr.pos;\n        nextChar(curr);\n        while (curr.line !== null) {\n            if (!isWhiteSpaceString(curr.line[curr.pos]) && !isEndOfSentenceSymbol(curr.line[curr.pos])) {\n                lastSentencePos = curr.pos;\n            }\n            else if (isEndOfSentenceSymbol(curr.line[curr.pos])) {\n                if (!inclusive) {\n                    return { ln: curr.ln, pos: lastSentencePos };\n                }\n                else {\n                    if (isWhiteSpaceString(curr.line[curr.pos + 1])) {\n                        return { ln: curr.ln, pos: curr.pos + 1 };\n                    }\n                    else {\n                        return { ln: curr.ln, pos: lastSentencePos };\n                    }\n                }\n            }\n            nextChar(curr);\n        }\n        curr.line = line;\n        if (inclusive && isWhiteSpaceString(curr.line[curr.pos])) {\n            return { ln: curr.ln, pos: curr.pos };\n        }\n        else {\n            return { ln: curr.ln, pos: lastSentencePos };\n        }\n    }\n    var curr_index = {\n        ln: cur.line,\n        pos: cur.ch,\n    };\n    while (repeat > 0) {\n        if (dir < 0) {\n            curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        else {\n            curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        repeat--;\n    }\n    return new Pos(curr_index.ln, curr_index.pos);\n}\nfunction findSentence(cm, cur, repeat, dir) {\n    function nextChar(cm, idx) {\n        if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {\n            idx.ln += idx.dir;\n            if (!isLine(cm, idx.ln)) {\n                idx.line = null;\n                idx.ln = null;\n                idx.pos = null;\n                return;\n            }\n            idx.line = cm.getLine(idx.ln);\n            idx.pos = (idx.dir > 0) ? 0 : idx.line.length - 1;\n        }\n        else {\n            idx.pos += idx.dir;\n        }\n    }\n    function forward(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var stop = (line === \"\");\n        var curr = {\n            line: line,\n            ln: ln,\n            pos: pos,\n            dir: dir,\n        };\n        var last_valid = {\n            ln: curr.ln,\n            pos: curr.pos,\n        };\n        var skip_empty_lines = (curr.line === \"\");\n        nextChar(cm, curr);\n        while (curr.line !== null) {\n            last_valid.ln = curr.ln;\n            last_valid.pos = curr.pos;\n            if (curr.line === \"\" && !skip_empty_lines) {\n                return { ln: curr.ln, pos: curr.pos, };\n            }\n            else if (stop && curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n                return { ln: curr.ln, pos: curr.pos, };\n            }\n            else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n                && !stop\n                && (curr.pos === curr.line.length - 1\n                    || isWhiteSpaceString(curr.line[curr.pos + 1]))) {\n                stop = true;\n            }\n            nextChar(cm, curr);\n        }\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for (var i = line.length - 1; i >= 0; --i) {\n            if (!isWhiteSpaceString(line[i])) {\n                last_valid.pos = i;\n                break;\n            }\n        }\n        return last_valid;\n    }\n    function reverse(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var curr = {\n            line: line,\n            ln: ln,\n            pos: pos,\n            dir: dir,\n        };\n        var last_valid = {\n            ln: curr.ln,\n            pos: null,\n        };\n        var skip_empty_lines = (curr.line === \"\");\n        nextChar(cm, curr);\n        while (curr.line !== null) {\n            if (curr.line === \"\" && !skip_empty_lines) {\n                if (last_valid.pos !== null) {\n                    return last_valid;\n                }\n                else {\n                    return { ln: curr.ln, pos: curr.pos };\n                }\n            }\n            else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n                && last_valid.pos !== null\n                && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {\n                return last_valid;\n            }\n            else if (curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n                skip_empty_lines = false;\n                last_valid = { ln: curr.ln, pos: curr.pos };\n            }\n            nextChar(cm, curr);\n        }\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for (var i = 0; i < line.length; ++i) {\n            if (!isWhiteSpaceString(line[i])) {\n                last_valid.pos = i;\n                break;\n            }\n        }\n        return last_valid;\n    }\n    var curr_index = {\n        ln: cur.line,\n        pos: cur.ch,\n    };\n    while (repeat > 0) {\n        if (dir < 0) {\n            curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        else {\n            curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        repeat--;\n    }\n    return new Pos(curr_index.ln, curr_index.pos);\n}\nfunction selectCompanionObject(cm, head, symb, inclusive) {\n    var cur = head, start, end;\n    var bracketRegexp = ({\n        '(': /[()]/, ')': /[()]/,\n        '[': /[[\\]]/, ']': /[[\\]]/,\n        '{': /[{}]/, '}': /[{}]/,\n        '<': /[<>]/, '>': /[<>]/\n    })[symb];\n    var openSym = ({\n        '(': '(', ')': '(',\n        '[': '[', ']': '[',\n        '{': '{', '}': '{',\n        '<': '<', '>': '<'\n    })[symb];\n    var curChar = cm.getLine(cur.line).charAt(cur.ch);\n    var offset = curChar === openSym ? 1 : 0;\n    start = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), -1, undefined, { 'bracketRegex': bracketRegexp });\n    end = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), 1, undefined, { 'bracketRegex': bracketRegexp });\n    if (!start || !end) {\n        return { start: cur, end: cur };\n    }\n    start = start.pos;\n    end = end.pos;\n    if ((start.line == end.line && start.ch > end.ch)\n        || (start.line > end.line)) {\n        var tmp = start;\n        start = end;\n        end = tmp;\n    }\n    if (inclusive) {\n        end.ch += 1;\n    }\n    else {\n        start.ch += 1;\n    }\n    return { start: start, end: end };\n}\nfunction findBeginningAndEnd(cm, head, symb, inclusive) {\n    var cur = copyCursor(head);\n    var line = cm.getLine(cur.line);\n    var chars = line.split('');\n    var start, end, i, len;\n    var firstIndex = chars.indexOf(symb);\n    if (cur.ch < firstIndex) {\n        cur.ch = firstIndex;\n    }\n    else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n        end = cur.ch; // assign end to the current cursor\n        --cur.ch; // make sure to look backwards\n    }\n    if (chars[cur.ch] == symb && !end) {\n        start = cur.ch + 1; // assign start to ahead of the cursor\n    }\n    else {\n        for (i = cur.ch; i > -1 && !start; i--) {\n            if (chars[i] == symb) {\n                start = i + 1;\n            }\n        }\n    }\n    if (start && !end) {\n        for (i = start, len = chars.length; i < len && !end; i++) {\n            if (chars[i] == symb) {\n                end = i;\n            }\n        }\n    }\n    if (!start || !end) {\n        return { start: cur, end: cur };\n    }\n    if (inclusive) {\n        --start;\n        ++end;\n    }\n    return {\n        start: new Pos(cur.line, start),\n        end: new Pos(cur.line, end)\n    };\n}\ndefineOption('pcre', true, 'boolean');\nfunction SearchState() { }\nSearchState.prototype = {\n    getQuery: function () {\n        return vimGlobalState.query;\n    },\n    setQuery: function (query) {\n        vimGlobalState.query = query;\n    },\n    getOverlay: function () {\n        return this.searchOverlay;\n    },\n    setOverlay: function (overlay) {\n        this.searchOverlay = overlay;\n    },\n    isReversed: function () {\n        return vimGlobalState.isReversed;\n    },\n    setReversed: function (reversed) {\n        vimGlobalState.isReversed = reversed;\n    },\n    getScrollbarAnnotate: function () {\n        return this.annotate;\n    },\n    setScrollbarAnnotate: function (annotate) {\n        this.annotate = annotate;\n    }\n};\nfunction getSearchState(cm) {\n    var vim = cm.state.vim;\n    return vim.searchState_ || (vim.searchState_ = new SearchState());\n}\nfunction splitBySlash(argString) {\n    return splitBySeparator(argString, '/');\n}\nfunction findUnescapedSlashes(argString) {\n    return findUnescapedSeparators(argString, '/');\n}\nfunction splitBySeparator(argString, separator) {\n    var slashes = findUnescapedSeparators(argString, separator) || [];\n    if (!slashes.length)\n        return [];\n    var tokens = [];\n    if (slashes[0] !== 0)\n        return;\n    for (var i = 0; i < slashes.length; i++) {\n        if (typeof slashes[i] == 'number')\n            tokens.push(argString.substring(slashes[i] + 1, slashes[i + 1]));\n    }\n    return tokens;\n}\nfunction findUnescapedSeparators(str, separator) {\n    if (!separator)\n        separator = '/';\n    var escapeNextChar = false;\n    var slashes = [];\n    for (var i = 0; i < str.length; i++) {\n        var c = str.charAt(i);\n        if (!escapeNextChar && c == separator) {\n            slashes.push(i);\n        }\n        escapeNextChar = !escapeNextChar && (c == '\\\\');\n    }\n    return slashes;\n}\nfunction translateRegex(str) {\n    var specials = '|(){';\n    var unescape = '}';\n    var escapeNextChar = false;\n    var out = [];\n    for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i + 1) || '';\n        var specialComesNext = (n && specials.indexOf(n) != -1);\n        if (escapeNextChar) {\n            if (c !== '\\\\' || !specialComesNext) {\n                out.push(c);\n            }\n            escapeNextChar = false;\n        }\n        else {\n            if (c === '\\\\') {\n                escapeNextChar = true;\n                if (n && unescape.indexOf(n) != -1) {\n                    specialComesNext = true;\n                }\n                if (!specialComesNext || n === '\\\\') {\n                    out.push(c);\n                }\n            }\n            else {\n                out.push(c);\n                if (specialComesNext && n !== '\\\\') {\n                    out.push('\\\\');\n                }\n            }\n        }\n    }\n    return out.join('');\n}\nvar charUnescapes = { '\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t' };\nfunction translateRegexReplace(str) {\n    var escapeNextChar = false;\n    var out = [];\n    for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i + 1) || '';\n        if (charUnescapes[c + n]) {\n            out.push(charUnescapes[c + n]);\n            i++;\n        }\n        else if (escapeNextChar) {\n            out.push(c);\n            escapeNextChar = false;\n        }\n        else {\n            if (c === '\\\\') {\n                escapeNextChar = true;\n                if ((isNumber(n) || n === '$')) {\n                    out.push('$');\n                }\n                else if (n !== '/' && n !== '\\\\') {\n                    out.push('\\\\');\n                }\n            }\n            else {\n                if (c === '$') {\n                    out.push('$');\n                }\n                out.push(c);\n                if (n === '/') {\n                    out.push('\\\\');\n                }\n            }\n        }\n    }\n    return out.join('');\n}\nvar unescapes = { '\\\\/': '/', '\\\\\\\\': '\\\\', '\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t', '\\\\&': '&' };\nfunction unescapeRegexReplace(str) {\n    var stream = new CodeMirror.StringStream(str);\n    var output = [];\n    while (!stream.eol()) {\n        while (stream.peek() && stream.peek() != '\\\\') {\n            output.push(stream.next());\n        }\n        var matched = false;\n        for (var matcher in unescapes) {\n            if (stream.match(matcher, true)) {\n                matched = true;\n                output.push(unescapes[matcher]);\n                break;\n            }\n        }\n        if (!matched) {\n            output.push(stream.next());\n        }\n    }\n    return output.join('');\n}\nfunction parseQuery(query, ignoreCase, smartCase) {\n    var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n    lastSearchRegister.setText(query);\n    if (query instanceof RegExp) {\n        return query;\n    }\n    var slashes = findUnescapedSlashes(query);\n    var regexPart;\n    var forceIgnoreCase;\n    if (!slashes.length) {\n        regexPart = query;\n    }\n    else {\n        regexPart = query.substring(0, slashes[0]);\n        var flagsPart = query.substring(slashes[0]);\n        forceIgnoreCase = (flagsPart.indexOf('i') != -1);\n    }\n    if (!regexPart) {\n        return null;\n    }\n    if (!getOption('pcre')) {\n        regexPart = translateRegex(regexPart);\n    }\n    if (smartCase) {\n        ignoreCase = (/^[^A-Z]*$/).test(regexPart);\n    }\n    var regexp = new RegExp(regexPart, (ignoreCase || forceIgnoreCase) ? 'im' : 'm');\n    return regexp;\n}\nfunction dom(n) {\n    if (typeof n === 'string')\n        n = document.createElement(n);\n    for (var a, i = 1; i < arguments.length; i++) {\n        if (!(a = arguments[i]))\n            continue;\n        if (typeof a !== 'object')\n            a = document.createTextNode(a);\n        if (a.nodeType)\n            n.appendChild(a);\n        else\n            for (var key in a) {\n                if (!Object.prototype.hasOwnProperty.call(a, key))\n                    continue;\n                if (key[0] === '$')\n                    n.style[key.slice(1)] = a[key];\n                else\n                    n.setAttribute(key, a[key]);\n            }\n    }\n    return n;\n}\nfunction showConfirm(cm, template) {\n    var pre = dom('div', { $color: 'red', $whiteSpace: 'pre', class: 'cm-vim-message' }, template);\n    if (cm.openNotification) {\n        cm.openNotification(pre, { bottom: true, duration: 5000 });\n    }\n    else {\n        alert(pre.innerText);\n    }\n}\nfunction makePrompt(prefix, desc) {\n    return dom(document.createDocumentFragment(), dom('span', { $fontFamily: 'monospace', $whiteSpace: 'pre' }, prefix, dom('input', { type: 'text', autocorrect: 'off',\n        autocapitalize: 'off', spellcheck: 'false' })), desc && dom('span', { $color: '#888' }, desc));\n}\nfunction showPrompt(cm, options) {\n    var template = makePrompt(options.prefix, options.desc);\n    if (cm.openDialog) {\n        cm.openDialog(template, options.onClose, {\n            onKeyDown: options.onKeyDown, onKeyUp: options.onKeyUp,\n            bottom: true, selectValueOnOpen: false, value: options.value\n        });\n    }\n    else {\n        var shortText = '';\n        if (typeof options.prefix != \"string\" && options.prefix)\n            shortText += options.prefix.textContent;\n        if (options.desc)\n            shortText += \" \" + options.desc;\n        options.onClose(prompt(shortText, ''));\n    }\n}\nfunction regexEqual(r1, r2) {\n    if (r1 instanceof RegExp && r2 instanceof RegExp) {\n        var props = ['global', 'multiline', 'ignoreCase', 'source'];\n        for (var i = 0; i < props.length; i++) {\n            var prop = props[i];\n            if (r1[prop] !== r2[prop]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}\nfunction updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n    if (!rawQuery) {\n        return;\n    }\n    var state = getSearchState(cm);\n    var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n    if (!query) {\n        return;\n    }\n    highlightSearchMatches(cm, query);\n    if (regexEqual(query, state.getQuery())) {\n        return query;\n    }\n    state.setQuery(query);\n    return query;\n}\nfunction searchOverlay(query) {\n    if (query.source.charAt(0) == '^') {\n        var matchSol = true;\n    }\n    return {\n        token: function (stream) {\n            if (matchSol && !stream.sol()) {\n                stream.skipToEnd();\n                return;\n            }\n            var match = stream.match(query, false);\n            if (match) {\n                if (match[0].length == 0) {\n                    stream.next();\n                    return 'searching';\n                }\n                if (!stream.sol()) {\n                    stream.backUp(1);\n                    if (!query.exec(stream.next() + match[0])) {\n                        stream.next();\n                        return null;\n                    }\n                }\n                stream.match(query);\n                return 'searching';\n            }\n            while (!stream.eol()) {\n                stream.next();\n                if (stream.match(query, false))\n                    break;\n            }\n        },\n        query: query\n    };\n}\nvar highlightTimeout = 0;\nfunction highlightSearchMatches(cm, query) {\n    clearTimeout(highlightTimeout);\n    highlightTimeout = setTimeout(function () {\n        if (!cm.state.vim)\n            return;\n        var searchState = getSearchState(cm);\n        var overlay = searchState.getOverlay();\n        if (!overlay || query != overlay.query) {\n            if (overlay) {\n                cm.removeOverlay(overlay);\n            }\n            overlay = searchOverlay(query);\n            cm.addOverlay(overlay);\n            if (cm.showMatchesOnScrollbar) {\n                if (searchState.getScrollbarAnnotate()) {\n                    searchState.getScrollbarAnnotate().clear();\n                }\n                searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n            }\n            searchState.setOverlay(overlay);\n        }\n    }, 50);\n}\nfunction findNext(cm, prev, query, repeat) {\n    if (repeat === undefined) {\n        repeat = 1;\n    }\n    return cm.operation(function () {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n        for (var i = 0; i < repeat; i++) {\n            var found = cursor.find(prev);\n            if (i == 0 && found && cursorEqual(cursor.from(), pos)) {\n                var lastEndPos = prev ? cursor.from() : cursor.to();\n                found = cursor.find(prev);\n                if (found && !found[0] && cursorEqual(cursor.from(), lastEndPos)) {\n                    if (cm.getLine(lastEndPos.line).length == lastEndPos.ch)\n                        found = cursor.find(prev);\n                }\n            }\n            if (!found) {\n                cursor = cm.getSearchCursor(query, (prev) ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0));\n                if (!cursor.find(prev)) {\n                    return;\n                }\n            }\n        }\n        return cursor.from();\n    });\n}\nfunction findNextFromAndToInclusive(cm, prev, query, repeat, vim) {\n    if (repeat === undefined) {\n        repeat = 1;\n    }\n    return cm.operation(function () {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n        var found = cursor.find(!prev);\n        if (!vim.visualMode && found && cursorEqual(cursor.from(), pos)) {\n            cursor.find(!prev);\n        }\n        for (var i = 0; i < repeat; i++) {\n            found = cursor.find(prev);\n            if (!found) {\n                cursor = cm.getSearchCursor(query, (prev) ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0));\n                if (!cursor.find(prev)) {\n                    return;\n                }\n            }\n        }\n        return [cursor.from(), cursor.to()];\n    });\n}\nfunction clearSearchHighlight(cm) {\n    var state = getSearchState(cm);\n    cm.removeOverlay(getSearchState(cm).getOverlay());\n    state.setOverlay(null);\n    if (state.getScrollbarAnnotate()) {\n        state.getScrollbarAnnotate().clear();\n        state.setScrollbarAnnotate(null);\n    }\n}\nfunction isInRange(pos, start, end) {\n    if (typeof pos != 'number') {\n        pos = pos.line;\n    }\n    if (start instanceof Array) {\n        return inArray(pos, start);\n    }\n    else {\n        if (typeof end == 'number') {\n            return (pos >= start && pos <= end);\n        }\n        else {\n            return pos == start;\n        }\n    }\n}\nfunction getUserVisibleLines(cm) {\n    var renderer = cm.ace.renderer;\n    return {\n        top: renderer.getFirstFullyVisibleRow(),\n        bottom: renderer.getLastFullyVisibleRow()\n    };\n}\nfunction getMarkPos(cm, vim, markName) {\n    if (markName == '\\'' || markName == '`') {\n        return vimGlobalState.jumpList.find(cm, -1) || new Pos(0, 0);\n    }\n    else if (markName == '.') {\n        return getLastEditPos(cm);\n    }\n    var mark = vim.marks[markName];\n    return mark && mark.find();\n}\nfunction getLastEditPos(cm) {\n    var undoManager = cm.ace.session.$undoManager;\n    if (undoManager && undoManager.$lastDelta)\n        return toCmPos(undoManager.$lastDelta.end);\n}\nvar ExCommandDispatcher = function () {\n    this.buildCommandMap_();\n};\nExCommandDispatcher.prototype = {\n    processCommand: function (cm, input, opt_params) {\n        var that = this;\n        cm.operation(function () {\n            cm.curOp.isVimOp = true;\n            that._processCommand(cm, input, opt_params);\n        });\n    },\n    _processCommand: function (cm, input, opt_params) {\n        var vim = cm.state.vim;\n        var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n        var previousCommand = commandHistoryRegister.toString();\n        if (vim.visualMode) {\n            exitVisualMode(cm);\n        }\n        var inputStream = new CodeMirror.StringStream(input);\n        commandHistoryRegister.setText(input);\n        var params = opt_params || {};\n        params.input = input;\n        try {\n            this.parseInput_(cm, inputStream, params);\n        }\n        catch (e) {\n            showConfirm(cm, e.toString());\n            throw e;\n        }\n        var command;\n        var commandName;\n        if (!params.commandName) {\n            if (params.line !== undefined) {\n                commandName = 'move';\n            }\n        }\n        else {\n            command = this.matchCommand_(params.commandName);\n            if (command) {\n                commandName = command.name;\n                if (command.excludeFromCommandHistory) {\n                    commandHistoryRegister.setText(previousCommand);\n                }\n                this.parseCommandArgs_(inputStream, params, command);\n                if (command.type == 'exToKey') {\n                    for (var i = 0; i < command.toKeys.length; i++) {\n                        vimApi.handleKey(cm, command.toKeys[i], 'mapping');\n                    }\n                    return;\n                }\n                else if (command.type == 'exToEx') {\n                    this.processCommand(cm, command.toInput);\n                    return;\n                }\n            }\n        }\n        if (!commandName) {\n            showConfirm(cm, 'Not an editor command \":' + input + '\"');\n            return;\n        }\n        try {\n            exCommands[commandName](cm, params);\n            if ((!command || !command.possiblyAsync) && params.callback) {\n                params.callback();\n            }\n        }\n        catch (e) {\n            showConfirm(cm, e.toString());\n            throw e;\n        }\n    },\n    parseInput_: function (cm, inputStream, result) {\n        inputStream.eatWhile(':');\n        if (inputStream.eat('%')) {\n            result.line = cm.firstLine();\n            result.lineEnd = cm.lastLine();\n        }\n        else {\n            result.line = this.parseLineSpec_(cm, inputStream);\n            if (result.line !== undefined && inputStream.eat(',')) {\n                result.lineEnd = this.parseLineSpec_(cm, inputStream);\n            }\n        }\n        var commandMatch = inputStream.match(/^(\\w+|!!|@@|[!#&*<=>@~])/);\n        if (commandMatch) {\n            result.commandName = commandMatch[1];\n        }\n        else {\n            result.commandName = inputStream.match(/.*/)[0];\n        }\n        return result;\n    },\n    parseLineSpec_: function (cm, inputStream) {\n        var numberMatch = inputStream.match(/^(\\d+)/);\n        if (numberMatch) {\n            return parseInt(numberMatch[1], 10) - 1;\n        }\n        switch (inputStream.next()) {\n            case '.':\n                return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n            case '$':\n                return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n            case '\\'':\n                var markName = inputStream.next();\n                var markPos = getMarkPos(cm, cm.state.vim, markName);\n                if (!markPos)\n                    throw new Error('Mark not set');\n                return this.parseLineSpecOffset_(inputStream, markPos.line);\n            case '-':\n            case '+':\n                inputStream.backUp(1);\n                return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n            default:\n                inputStream.backUp(1);\n                return undefined;\n        }\n    },\n    parseLineSpecOffset_: function (inputStream, line) {\n        var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n        if (offsetMatch) {\n            var offset = parseInt(offsetMatch[2], 10);\n            if (offsetMatch[1] == \"-\") {\n                line -= offset;\n            }\n            else {\n                line += offset;\n            }\n        }\n        return line;\n    },\n    parseCommandArgs_: function (inputStream, params, command) {\n        if (inputStream.eol()) {\n            return;\n        }\n        params.argString = inputStream.match(/.*/)[0];\n        var delim = command.argDelimiter || /\\s+/;\n        var args = trim(params.argString).split(delim);\n        if (args.length && args[0]) {\n            params.args = args;\n        }\n    },\n    matchCommand_: function (commandName) {\n        for (var i = commandName.length; i > 0; i--) {\n            var prefix = commandName.substring(0, i);\n            if (this.commandMap_[prefix]) {\n                var command = this.commandMap_[prefix];\n                if (command.name.indexOf(commandName) === 0) {\n                    return command;\n                }\n            }\n        }\n        return null;\n    },\n    buildCommandMap_: function () {\n        this.commandMap_ = {};\n        for (var i = 0; i < defaultExCommandMap.length; i++) {\n            var command = defaultExCommandMap[i];\n            var key = command.shortName || command.name;\n            this.commandMap_[key] = command;\n        }\n    },\n    map: function (lhs, rhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n            if (ctx) {\n                throw Error('Mode not supported for ex mappings');\n            }\n            var commandName = lhs.substring(1);\n            if (rhs != ':' && rhs.charAt(0) == ':') {\n                this.commandMap_[commandName] = {\n                    name: commandName,\n                    type: 'exToEx',\n                    toInput: rhs.substring(1),\n                    user: true\n                };\n            }\n            else {\n                this.commandMap_[commandName] = {\n                    name: commandName,\n                    type: 'exToKey',\n                    toKeys: rhs,\n                    user: true\n                };\n            }\n        }\n        else {\n            if (rhs != ':' && rhs.charAt(0) == ':') {\n                var mapping = {\n                    keys: lhs,\n                    type: 'keyToEx',\n                    exArgs: { input: rhs.substring(1) }\n                };\n                if (ctx) {\n                    mapping.context = ctx;\n                }\n                defaultKeymap.unshift(mapping);\n            }\n            else {\n                var mapping = {\n                    keys: lhs,\n                    type: 'keyToKey',\n                    toKeys: rhs\n                };\n                if (ctx) {\n                    mapping.context = ctx;\n                }\n                defaultKeymap.unshift(mapping);\n            }\n        }\n    },\n    unmap: function (lhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n            if (ctx) {\n                throw Error('Mode not supported for ex mappings');\n            }\n            var commandName = lhs.substring(1);\n            if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n                delete this.commandMap_[commandName];\n                return true;\n            }\n        }\n        else {\n            var keys = lhs;\n            for (var i = 0; i < defaultKeymap.length; i++) {\n                if (keys == defaultKeymap[i].keys\n                    && defaultKeymap[i].context === ctx) {\n                    defaultKeymap.splice(i, 1);\n                    return true;\n                }\n            }\n        }\n    }\n};\nvar exCommands = {\n    colorscheme: function (cm, params) {\n        if (!params.args || params.args.length < 1) {\n            showConfirm(cm, cm.getOption('theme'));\n            return;\n        }\n        cm.setOption('theme', params.args[0]);\n    },\n    map: function (cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 2) {\n            if (cm) {\n                showConfirm(cm, 'Invalid mapping: ' + params.input);\n            }\n            return;\n        }\n        exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);\n    },\n    imap: function (cm, params) { this.map(cm, params, 'insert'); },\n    nmap: function (cm, params) { this.map(cm, params, 'normal'); },\n    vmap: function (cm, params) { this.map(cm, params, 'visual'); },\n    unmap: function (cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 1 || !exCommandDispatcher.unmap(mapArgs[0], ctx)) {\n            if (cm) {\n                showConfirm(cm, 'No such mapping: ' + params.input);\n            }\n        }\n    },\n    move: function (cm, params) {\n        commandDispatcher.processCommand(cm, cm.state.vim, {\n            type: 'motion',\n            motion: 'moveToLineOrEdgeOfDocument',\n            motionArgs: { forward: false, explicitRepeat: true,\n                linewise: true },\n            repeatOverride: params.line + 1\n        });\n    },\n    set: function (cm, params) {\n        var setArgs = params.args;\n        var setCfg = params.setCfg || {};\n        if (!setArgs || setArgs.length < 1) {\n            if (cm) {\n                showConfirm(cm, 'Invalid mapping: ' + params.input);\n            }\n            return;\n        }\n        var expr = setArgs[0].split('=');\n        var optionName = expr[0];\n        var value = expr[1];\n        var forceGet = false;\n        if (optionName.charAt(optionName.length - 1) == '?') {\n            if (value) {\n                throw Error('Trailing characters: ' + params.argString);\n            }\n            optionName = optionName.substring(0, optionName.length - 1);\n            forceGet = true;\n        }\n        if (value === undefined && optionName.substring(0, 2) == 'no') {\n            optionName = optionName.substring(2);\n            value = false;\n        }\n        var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n        if (optionIsBoolean && value == undefined) {\n            value = true;\n        }\n        if (!optionIsBoolean && value === undefined || forceGet) {\n            var oldValue = getOption(optionName, cm, setCfg);\n            if (oldValue instanceof Error) {\n                showConfirm(cm, oldValue.message);\n            }\n            else if (oldValue === true || oldValue === false) {\n                showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n            }\n            else {\n                showConfirm(cm, '  ' + optionName + '=' + oldValue);\n            }\n        }\n        else {\n            var setOptionReturn = setOption(optionName, value, cm, setCfg);\n            if (setOptionReturn instanceof Error) {\n                showConfirm(cm, setOptionReturn.message);\n            }\n        }\n    },\n    setlocal: function (cm, params) {\n        params.setCfg = { scope: 'local' };\n        this.set(cm, params);\n    },\n    setglobal: function (cm, params) {\n        params.setCfg = { scope: 'global' };\n        this.set(cm, params);\n    },\n    registers: function (cm, params) {\n        var regArgs = params.args;\n        var registers = vimGlobalState.registerController.registers;\n        var regInfo = '----------Registers----------\\n\\n';\n        if (!regArgs) {\n            for (var registerName in registers) {\n                var text = registers[registerName].toString();\n                if (text.length) {\n                    regInfo += '\"' + registerName + '    ' + text + '\\n';\n                }\n            }\n        }\n        else {\n            var registerName;\n            regArgs = regArgs.join('');\n            for (var i = 0; i < regArgs.length; i++) {\n                registerName = regArgs.charAt(i);\n                if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n                    continue;\n                }\n                var register = registers[registerName] || new Register();\n                regInfo += '\"' + registerName + '    ' + register.toString() + '\\n';\n            }\n        }\n        showConfirm(cm, regInfo);\n    },\n    sort: function (cm, params) {\n        var reverse, ignoreCase, unique, number, pattern;\n        function parseArgs() {\n            if (params.argString) {\n                var args = new CodeMirror.StringStream(params.argString);\n                if (args.eat('!')) {\n                    reverse = true;\n                }\n                if (args.eol()) {\n                    return;\n                }\n                if (!args.eatSpace()) {\n                    return 'Invalid arguments';\n                }\n                var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n                if (!opts && !args.eol()) {\n                    return 'Invalid arguments';\n                }\n                if (opts[1]) {\n                    ignoreCase = opts[1].indexOf('i') != -1;\n                    unique = opts[1].indexOf('u') != -1;\n                    var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;\n                    var hex = opts[1].indexOf('x') != -1 && 1;\n                    var octal = opts[1].indexOf('o') != -1 && 1;\n                    if (decimal + hex + octal > 1) {\n                        return 'Invalid arguments';\n                    }\n                    number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n                }\n                if (opts[2]) {\n                    pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n                }\n            }\n        }\n        var err = parseArgs();\n        if (err) {\n            showConfirm(cm, err + ': ' + params.argString);\n            return;\n        }\n        var lineStart = params.line || cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        if (lineStart == lineEnd) {\n            return;\n        }\n        var curStart = new Pos(lineStart, 0);\n        var curEnd = new Pos(lineEnd, lineLength(cm, lineEnd));\n        var text = cm.getRange(curStart, curEnd).split('\\n');\n        var numberRegex = pattern ? pattern :\n            (number == 'decimal') ? /(-?)([\\d]+)/ :\n                (number == 'hex') ? /(-?)(?:0x)?([0-9a-f]+)/i :\n                    (number == 'octal') ? /([0-7]+)/ : null;\n        var radix = (number == 'decimal') ? 10 : (number == 'hex') ? 16 : (number == 'octal') ? 8 : null;\n        var numPart = [], textPart = [];\n        if (number || pattern) {\n            for (var i = 0; i < text.length; i++) {\n                var matchPart = pattern ? text[i].match(pattern) : null;\n                if (matchPart && matchPart[0] != '') {\n                    numPart.push(matchPart);\n                }\n                else if (!pattern && numberRegex.exec(text[i])) {\n                    numPart.push(text[i]);\n                }\n                else {\n                    textPart.push(text[i]);\n                }\n            }\n        }\n        else {\n            textPart = text;\n        }\n        function compareFn(a, b) {\n            if (reverse) {\n                var tmp;\n                tmp = a;\n                a = b;\n                b = tmp;\n            }\n            if (ignoreCase) {\n                a = a.toLowerCase();\n                b = b.toLowerCase();\n            }\n            var anum = number && numberRegex.exec(a);\n            var bnum = number && numberRegex.exec(b);\n            if (!anum) {\n                return a < b ? -1 : 1;\n            }\n            anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n            bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n            return anum - bnum;\n        }\n        function comparePatternFn(a, b) {\n            if (reverse) {\n                var tmp;\n                tmp = a;\n                a = b;\n                b = tmp;\n            }\n            if (ignoreCase) {\n                a[0] = a[0].toLowerCase();\n                b[0] = b[0].toLowerCase();\n            }\n            return (a[0] < b[0]) ? -1 : 1;\n        }\n        numPart.sort(pattern ? comparePatternFn : compareFn);\n        if (pattern) {\n            for (var i = 0; i < numPart.length; i++) {\n                numPart[i] = numPart[i].input;\n            }\n        }\n        else if (!number) {\n            textPart.sort(compareFn);\n        }\n        text = (!reverse) ? textPart.concat(numPart) : numPart.concat(textPart);\n        if (unique) { // Remove duplicate lines\n            var textOld = text;\n            var lastLine;\n            text = [];\n            for (var i = 0; i < textOld.length; i++) {\n                if (textOld[i] != lastLine) {\n                    text.push(textOld[i]);\n                }\n                lastLine = textOld[i];\n            }\n        }\n        cm.replaceRange(text.join('\\n'), curStart, curEnd);\n    },\n    vglobal: function (cm, params) {\n        this.global(cm, params);\n    },\n    global: function (cm, params) {\n        var argString = params.argString;\n        if (!argString) {\n            showConfirm(cm, 'Regular Expression missing from global');\n            return;\n        }\n        var inverted = params.commandName[0] === 'v';\n        var lineStart = (params.line !== undefined) ? params.line : cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        var tokens = splitBySlash(argString);\n        var regexPart = argString, cmd;\n        if (tokens.length) {\n            regexPart = tokens[0];\n            cmd = tokens.slice(1, tokens.length).join('/');\n        }\n        if (regexPart) {\n            try {\n                updateSearchQuery(cm, regexPart, true /** ignoreCase */, true /** smartCase */);\n            }\n            catch (e) {\n                showConfirm(cm, 'Invalid regex: ' + regexPart);\n                return;\n            }\n        }\n        var query = getSearchState(cm).getQuery();\n        var matchedLines = [];\n        for (var i = lineStart; i <= lineEnd; i++) {\n            var line = cm.getLineHandle(i);\n            var matched = query.test(line.text);\n            if (matched !== inverted) {\n                matchedLines.push(cmd ? line : line.text);\n            }\n        }\n        if (!cmd) {\n            showConfirm(cm, matchedLines.join('\\n'));\n            return;\n        }\n        var index = 0;\n        var nextCommand = function () {\n            if (index < matchedLines.length) {\n                var line = matchedLines[index++];\n                var lineNum = cm.getLineNumber(line);\n                if (lineNum == null) {\n                    nextCommand();\n                    return;\n                }\n                var command = (lineNum + 1) + cmd;\n                exCommandDispatcher.processCommand(cm, command, {\n                    callback: nextCommand\n                });\n            }\n        };\n        nextCommand();\n    },\n    substitute: function (cm, params) {\n        if (!cm.getSearchCursor) {\n            throw new Error('Search feature not available. Requires searchcursor.js or ' +\n                'any other getSearchCursor implementation.');\n        }\n        var argString = params.argString;\n        var tokens = argString ? splitBySeparator(argString, argString[0]) : [];\n        var regexPart, replacePart = '', trailing, flagsPart, count;\n        var confirm = false; // Whether to confirm each replace.\n        var global = false; // True to replace all instances on a line, false to replace only 1.\n        if (tokens.length) {\n            regexPart = tokens[0];\n            if (getOption('pcre') && regexPart !== '') {\n                regexPart = new RegExp(regexPart).source; //normalize not escaped characters\n            }\n            replacePart = tokens[1];\n            if (replacePart !== undefined) {\n                if (getOption('pcre')) {\n                    replacePart = unescapeRegexReplace(replacePart.replace(/([^\\\\])&/g, \"$1$$&\"));\n                }\n                else {\n                    replacePart = translateRegexReplace(replacePart);\n                }\n                vimGlobalState.lastSubstituteReplacePart = replacePart;\n            }\n            trailing = tokens[2] ? tokens[2].split(' ') : [];\n        }\n        else {\n            if (argString && argString.length) {\n                showConfirm(cm, 'Substitutions should be of the form ' +\n                    ':s/pattern/replace/');\n                return;\n            }\n        }\n        if (trailing) {\n            flagsPart = trailing[0];\n            count = parseInt(trailing[1]);\n            if (flagsPart) {\n                if (flagsPart.indexOf('c') != -1) {\n                    confirm = true;\n                }\n                if (flagsPart.indexOf('g') != -1) {\n                    global = true;\n                }\n                if (getOption('pcre')) {\n                    regexPart = regexPart + '/' + flagsPart;\n                }\n                else {\n                    regexPart = regexPart.replace(/\\//g, \"\\\\/\") + '/' + flagsPart;\n                }\n            }\n        }\n        if (regexPart) {\n            try {\n                updateSearchQuery(cm, regexPart, true /** ignoreCase */, true /** smartCase */);\n            }\n            catch (e) {\n                showConfirm(cm, 'Invalid regex: ' + regexPart);\n                return;\n            }\n        }\n        replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n        if (replacePart === undefined) {\n            showConfirm(cm, 'No previous substitute regular expression');\n            return;\n        }\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        var lineStart = (params.line !== undefined) ? params.line : cm.getCursor().line;\n        var lineEnd = params.lineEnd || lineStart;\n        if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n            lineEnd = Infinity;\n        }\n        if (count) {\n            lineStart = lineEnd;\n            lineEnd = lineStart + count - 1;\n        }\n        var startPos = clipCursorToContent(cm, new Pos(lineStart, 0));\n        var cursor = cm.getSearchCursor(query, startPos);\n        doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n    },\n    redo: CodeMirror.commands.redo,\n    undo: CodeMirror.commands.undo,\n    write: function (cm) {\n        if (CodeMirror.commands.save) {\n            CodeMirror.commands.save(cm);\n        }\n        else if (cm.save) {\n            cm.save();\n        }\n    },\n    nohlsearch: function (cm) {\n        clearSearchHighlight(cm);\n    },\n    yank: function (cm) {\n        var cur = copyCursor(cm.getCursor());\n        var line = cur.line;\n        var lineText = cm.getLine(line);\n        vimGlobalState.registerController.pushText('0', 'yank', lineText, true, true);\n    },\n    delmarks: function (cm, params) {\n        if (!params.argString || !trim(params.argString)) {\n            showConfirm(cm, 'Argument required');\n            return;\n        }\n        var state = cm.state.vim;\n        var stream = new CodeMirror.StringStream(trim(params.argString));\n        while (!stream.eol()) {\n            stream.eatSpace();\n            var count = stream.pos;\n            if (!stream.match(/[a-zA-Z]/, false)) {\n                showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                return;\n            }\n            var sym = stream.next();\n            if (stream.match('-', true)) {\n                if (!stream.match(/[a-zA-Z]/, false)) {\n                    showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                    return;\n                }\n                var startMark = sym;\n                var finishMark = stream.next();\n                if (isLowerCase(startMark) && isLowerCase(finishMark) ||\n                    isUpperCase(startMark) && isUpperCase(finishMark)) {\n                    var start = startMark.charCodeAt(0);\n                    var finish = finishMark.charCodeAt(0);\n                    if (start >= finish) {\n                        showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                        return;\n                    }\n                    for (var j = 0; j <= finish - start; j++) {\n                        var mark = String.fromCharCode(start + j);\n                        delete state.marks[mark];\n                    }\n                }\n                else {\n                    showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n                    return;\n                }\n            }\n            else {\n                delete state.marks[sym];\n            }\n        }\n    }\n};\nvar exCommandDispatcher = new ExCommandDispatcher();\nfunction doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query, replaceWith, callback) {\n    cm.state.vim.exMode = true;\n    var done = false;\n    var lastPos, modifiedLineNumber, joined;\n    function replaceAll() {\n        cm.operation(function () {\n            while (!done) {\n                replace();\n                next();\n            }\n            stop();\n        });\n    }\n    function replace() {\n        var text = cm.getRange(searchCursor.from(), searchCursor.to());\n        var newText = text.replace(query, replaceWith);\n        var unmodifiedLineNumber = searchCursor.to().line;\n        searchCursor.replace(newText);\n        modifiedLineNumber = searchCursor.to().line;\n        lineEnd += modifiedLineNumber - unmodifiedLineNumber;\n        joined = modifiedLineNumber < unmodifiedLineNumber;\n    }\n    function findNextValidMatch() {\n        var lastMatchTo = lastPos && copyCursor(searchCursor.to());\n        var match = searchCursor.findNext();\n        if (match && !match[0] && lastMatchTo && cursorEqual(searchCursor.from(), lastMatchTo)) {\n            match = searchCursor.findNext();\n        }\n        return match;\n    }\n    function next() {\n        while (findNextValidMatch() &&\n            isInRange(searchCursor.from(), lineStart, lineEnd)) {\n            if (!global && searchCursor.from().line == modifiedLineNumber && !joined) {\n                continue;\n            }\n            cm.scrollIntoView(searchCursor.from(), 30);\n            cm.setSelection(searchCursor.from(), searchCursor.to());\n            lastPos = searchCursor.from();\n            done = false;\n            return;\n        }\n        done = true;\n    }\n    function stop(close) {\n        if (close) {\n            close();\n        }\n        cm.focus();\n        if (lastPos) {\n            cm.setCursor(lastPos);\n            var vim = cm.state.vim;\n            vim.exMode = false;\n            vim.lastHPos = vim.lastHSPos = lastPos.ch;\n        }\n        if (callback) {\n            callback();\n        }\n    }\n    function onPromptKeyDown(e, _value, close) {\n        CodeMirror.e_stop(e);\n        var keyName = CodeMirror.keyName(e);\n        switch (keyName) {\n            case 'Y':\n                replace();\n                next();\n                break;\n            case 'N':\n                next();\n                break;\n            case 'A':\n                var savedCallback = callback;\n                callback = undefined;\n                cm.operation(replaceAll);\n                callback = savedCallback;\n                break;\n            case 'L':\n                replace();\n            case 'Q':\n            case 'Esc':\n            case 'Ctrl-C':\n            case 'Ctrl-[':\n                stop(close);\n                break;\n        }\n        if (done) {\n            stop(close);\n        }\n        return true;\n    }\n    next();\n    if (done) {\n        showConfirm(cm, 'No matches for ' + query.source);\n        return;\n    }\n    if (!confirm) {\n        replaceAll();\n        if (callback) {\n            callback();\n        }\n        return;\n    }\n    showPrompt(cm, {\n        prefix: dom('span', 'replace with ', dom('strong', replaceWith), ' (y/n/a/q/l)'),\n        onKeyDown: onPromptKeyDown\n    });\n}\nCodeMirror.keyMap.vim = {\n    attach: attachVimMap,\n    detach: detachVimMap,\n    call: cmKey\n};\nfunction exitInsertMode(cm) {\n    var vim = cm.state.vim;\n    var macroModeState = vimGlobalState.macroModeState;\n    var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n    var isPlaying = macroModeState.isPlaying;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    if (!isPlaying) {\n        cm.off('change', onChange);\n        CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n    }\n    if (!isPlaying && vim.insertModeRepeat > 1) {\n        repeatLastEdit(cm, vim, vim.insertModeRepeat - 1, true /** repeatForInsert */);\n        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n    }\n    delete vim.insertModeRepeat;\n    vim.insertMode = false;\n    cm.setCursor(cm.getCursor().line, cm.getCursor().ch - 1);\n    cm.setOption('keyMap', 'vim');\n    cm.setOption('disableInput', true);\n    cm.toggleOverwrite(false); // exit replace mode if we were in it.\n    insertModeChangeRegister.setText(lastChange.changes.join(''));\n    CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"normal\" });\n    if (macroModeState.isRecording) {\n        logInsertModeChange(macroModeState);\n    }\n}\nfunction _mapCommand(command) {\n    defaultKeymap.unshift(command);\n}\nfunction mapCommand(keys, type, name, args, extra) {\n    var command = { keys: keys, type: type };\n    command[type] = name;\n    command[type + \"Args\"] = args;\n    for (var key in extra)\n        command[key] = extra[key];\n    _mapCommand(command);\n}\ndefineOption('insertModeEscKeysTimeout', 200, 'number');\nCodeMirror.keyMap['vim-insert'] = {\n    fallthrough: ['default'],\n    attach: attachVimMap,\n    detach: detachVimMap,\n    call: cmKey\n};\nCodeMirror.keyMap['vim-replace'] = {\n    'Backspace': 'goCharLeft',\n    fallthrough: ['vim-insert'],\n    attach: attachVimMap,\n    detach: detachVimMap,\n    call: cmKey\n};\nfunction executeMacroRegister(cm, vim, macroModeState, registerName) {\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (registerName == ':') {\n        if (register.keyBuffer[0]) {\n            exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n        }\n        macroModeState.isPlaying = false;\n        return;\n    }\n    var keyBuffer = register.keyBuffer;\n    var imc = 0;\n    macroModeState.isPlaying = true;\n    macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n    for (var i = 0; i < keyBuffer.length; i++) {\n        var text = keyBuffer[i];\n        var match, key;\n        while (text) {\n            match = (/<\\w+-.+?>|<\\w+>|./).exec(text);\n            key = match[0];\n            text = text.substring(match.index + key.length);\n            vimApi.handleKey(cm, key, 'macro');\n            if (vim.insertMode) {\n                var changes = register.insertModeChanges[imc++].changes;\n                vimGlobalState.macroModeState.lastInsertModeChanges.changes =\n                    changes;\n                repeatInsertModeChanges(cm, changes, 1);\n                exitInsertMode(cm);\n            }\n        }\n    }\n    macroModeState.isPlaying = false;\n}\nfunction logKey(macroModeState, key) {\n    if (macroModeState.isPlaying) {\n        return;\n    }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register) {\n        register.pushText(key);\n    }\n}\nfunction logInsertModeChange(macroModeState) {\n    if (macroModeState.isPlaying) {\n        return;\n    }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register && register.pushInsertModeChanges) {\n        register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n    }\n}\nfunction logSearchQuery(macroModeState, query) {\n    if (macroModeState.isPlaying) {\n        return;\n    }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register && register.pushSearchQuery) {\n        register.pushSearchQuery(query);\n    }\n}\nfunction onChange(cm, changeObj) {\n    var macroModeState = vimGlobalState.macroModeState;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    if (!macroModeState.isPlaying) {\n        while (changeObj) {\n            lastChange.expectCursorActivityForChange = true;\n            if (lastChange.ignoreCount > 1) {\n                lastChange.ignoreCount--;\n            }\n            else if (changeObj.origin == '+input' || changeObj.origin == 'paste'\n                || changeObj.origin === undefined /* only in testing */) {\n                var selectionCount = cm.listSelections().length;\n                if (selectionCount > 1)\n                    lastChange.ignoreCount = selectionCount;\n                var text = changeObj.text.join('\\n');\n                if (lastChange.maybeReset) {\n                    lastChange.changes = [];\n                    lastChange.maybeReset = false;\n                }\n                if (text) {\n                    if (cm.state.overwrite && !/\\n/.test(text)) {\n                        lastChange.changes.push([text]);\n                    }\n                    else {\n                        lastChange.changes.push(text);\n                    }\n                }\n            }\n            changeObj = changeObj.next;\n        }\n    }\n}\nfunction onCursorActivity(cm) {\n    var vim = cm.state.vim;\n    if (vim.insertMode) {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) {\n            return;\n        }\n        var lastChange = macroModeState.lastInsertModeChanges;\n        if (lastChange.expectCursorActivityForChange) {\n            lastChange.expectCursorActivityForChange = false;\n        }\n        else {\n            lastChange.maybeReset = true;\n        }\n    }\n    else if (!cm.curOp.isVimOp) {\n        handleExternalSelection(cm, vim);\n    }\n}\nfunction handleExternalSelection(cm, vim, keepHPos) {\n    var anchor = cm.getCursor('anchor');\n    var head = cm.getCursor('head');\n    if (vim.visualMode && !cm.somethingSelected()) {\n        exitVisualMode(cm, false);\n    }\n    else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n        vim.visualMode = true;\n        vim.visualLine = false;\n        CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"visual\" });\n    }\n    if (vim.visualMode) {\n        var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n        var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n        head = offsetCursor(head, 0, headOffset);\n        anchor = offsetCursor(anchor, 0, anchorOffset);\n        vim.sel = {\n            anchor: anchor,\n            head: head\n        };\n        updateMark(cm, vim, '<', cursorMin(head, anchor));\n        updateMark(cm, vim, '>', cursorMax(head, anchor));\n    }\n    else if (!vim.insertMode && !keepHPos) {\n        vim.lastHPos = cm.getCursor().ch;\n    }\n}\nfunction InsertModeKey(keyName) {\n    this.keyName = keyName;\n}\nfunction onKeyEventTargetKeyDown(e) {\n    var macroModeState = vimGlobalState.macroModeState;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    var keyName = CodeMirror.keyName(e);\n    if (!keyName) {\n        return;\n    }\n    function onKeyFound() {\n        if (lastChange.maybeReset) {\n            lastChange.changes = [];\n            lastChange.maybeReset = false;\n        }\n        lastChange.changes.push(new InsertModeKey(keyName));\n        return true;\n    }\n    if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n        CodeMirror.lookupKey(keyName, 'vim-insert', onKeyFound);\n    }\n}\nfunction repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n    var macroModeState = vimGlobalState.macroModeState;\n    macroModeState.isPlaying = true;\n    var isAction = !!vim.lastEditActionCommand;\n    var cachedInputState = vim.inputState;\n    function repeatCommand() {\n        if (isAction) {\n            commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n        }\n        else {\n            commandDispatcher.evalInput(cm, vim);\n        }\n    }\n    function repeatInsert(repeat) {\n        if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n            repeat = !vim.lastEditActionCommand ? 1 : repeat;\n            var changeObject = macroModeState.lastInsertModeChanges;\n            repeatInsertModeChanges(cm, changeObject.changes, repeat);\n        }\n    }\n    vim.inputState = vim.lastEditInputState;\n    if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n        for (var i = 0; i < repeat; i++) {\n            repeatCommand();\n            repeatInsert(1);\n        }\n    }\n    else {\n        if (!repeatForInsert) {\n            repeatCommand();\n        }\n        repeatInsert(repeat);\n    }\n    vim.inputState = cachedInputState;\n    if (vim.insertMode && !repeatForInsert) {\n        exitInsertMode(cm);\n    }\n    macroModeState.isPlaying = false;\n}\nfunction repeatInsertModeChanges(cm, changes, repeat) {\n    function keyHandler(binding) {\n        if (typeof binding == 'string') {\n            CodeMirror.commands[binding](cm);\n        }\n        else {\n            binding(cm);\n        }\n        return true;\n    }\n    var head = cm.getCursor('head');\n    var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;\n    if (visualBlock) {\n        selectForInsert(cm, head, visualBlock + 1);\n        repeat = cm.listSelections().length;\n        cm.setCursor(head);\n    }\n    for (var i = 0; i < repeat; i++) {\n        if (visualBlock) {\n            cm.setCursor(offsetCursor(head, i, 0));\n        }\n        for (var j = 0; j < changes.length; j++) {\n            var change = changes[j];\n            if (change instanceof InsertModeKey) {\n                CodeMirror.lookupKey(change.keyName, 'vim-insert', keyHandler);\n            }\n            else if (typeof change == \"string\") {\n                cm.replaceSelection(change);\n            }\n            else {\n                var start = cm.getCursor();\n                var end = offsetCursor(start, 0, change[0].length);\n                cm.replaceRange(change[0], start, end);\n                cm.setCursor(end);\n            }\n        }\n    }\n    if (visualBlock) {\n        cm.setCursor(offsetCursor(head, 0, 1));\n    }\n}\nresetVimGlobalState();\nCodeMirror.Vim = vimApi;\nvar specialKey = { 'return': 'CR', backspace: 'BS', 'delete': 'Del', esc: 'Esc',\n    left: 'Left', right: 'Right', up: 'Up', down: 'Down', space: 'Space', insert: 'Ins',\n    home: 'Home', end: 'End', pageup: 'PageUp', pagedown: 'PageDown', enter: 'CR'\n};\nfunction lookupKey(hashId, key, e) {\n    if (key.length > 1 && key[0] == \"n\") {\n        key = key.replace(\"numpad\", \"\");\n    }\n    key = specialKey[key] || key;\n    var name = '';\n    if (e.ctrlKey) {\n        name += 'C-';\n    }\n    if (e.altKey) {\n        name += 'A-';\n    }\n    if ((name || key.length > 1) && e.shiftKey) {\n        name += 'S-';\n    }\n    name += key;\n    if (name.length > 1) {\n        name = '<' + name + '>';\n    }\n    return name;\n}\nvar handleKey = vimApi.handleKey.bind(vimApi);\nvimApi.handleKey = function (cm, key, origin) {\n    return cm.operation(function () {\n        return handleKey(cm, key, origin);\n    }, true);\n};\nfunction cloneVimState(state) {\n    var n = new state.constructor();\n    Object.keys(state).forEach(function (key) {\n        var o = state[key];\n        if (Array.isArray(o))\n            o = o.slice();\n        else if (o && typeof o == \"object\" && o.constructor != Object)\n            o = cloneVimState(o);\n        n[key] = o;\n    });\n    if (state.sel) {\n        n.sel = {\n            head: state.sel.head && copyCursor(state.sel.head),\n            anchor: state.sel.anchor && copyCursor(state.sel.anchor)\n        };\n    }\n    return n;\n}\nfunction multiSelectHandleKey(cm, key, origin) {\n    var isHandled = false;\n    var vim = vimApi.maybeInitVimState_(cm);\n    var visualBlock = vim.visualBlock || vim.wasInVisualBlock;\n    var wasMultiselect = cm.ace.inMultiSelectMode;\n    if (vim.wasInVisualBlock && !wasMultiselect) {\n        vim.wasInVisualBlock = false;\n    }\n    else if (wasMultiselect && vim.visualBlock) {\n        vim.wasInVisualBlock = true;\n    }\n    if (key == '<Esc>' && !vim.insertMode && !vim.visualMode && wasMultiselect) {\n        cm.ace.exitMultiSelectMode();\n    }\n    else if (visualBlock || !wasMultiselect || cm.ace.inVirtualSelectionMode) {\n        isHandled = vimApi.handleKey(cm, key, origin);\n    }\n    else {\n        var old = cloneVimState(vim);\n        cm.operation(function () {\n            cm.ace.forEachSelection(function () {\n                var sel = cm.ace.selection;\n                cm.state.vim.lastHPos = sel.$desiredColumn == null ? sel.lead.column : sel.$desiredColumn;\n                var head = cm.getCursor(\"head\");\n                var anchor = cm.getCursor(\"anchor\");\n                var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n                var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n                head = offsetCursor(head, 0, headOffset);\n                anchor = offsetCursor(anchor, 0, anchorOffset);\n                cm.state.vim.sel.head = head;\n                cm.state.vim.sel.anchor = anchor;\n                isHandled = handleKey(cm, key, origin);\n                sel.$desiredColumn = cm.state.vim.lastHPos == -1 ? null : cm.state.vim.lastHPos;\n                if (cm.virtualSelectionMode()) {\n                    cm.state.vim = cloneVimState(old);\n                }\n            });\n            if (cm.curOp.cursorActivity && !isHandled)\n                cm.curOp.cursorActivity = false;\n        }, true);\n    }\n    if (isHandled && !vim.visualMode && !vim.insert && vim.visualMode != cm.somethingSelected()) {\n        handleExternalSelection(cm, vim, true);\n    }\n    return isHandled;\n}\nexports.CodeMirror = CodeMirror;\nvar getVim = vimApi.maybeInitVimState_;\nexports.handler = {\n    $id: \"ace/keyboard/vim\",\n    drawCursor: function (element, pixelPos, config, sel, session) {\n        var vim = this.state.vim || {};\n        var w = config.characterWidth;\n        var h = config.lineHeight;\n        var top = pixelPos.top;\n        var left = pixelPos.left;\n        if (!vim.insertMode) {\n            var isbackwards = !sel.cursor\n                ? session.selection.isBackwards() || session.selection.isEmpty()\n                : Range.comparePoints(sel.cursor, sel.start) <= 0;\n            if (!isbackwards && left > w)\n                left -= w;\n        }\n        if (!vim.insertMode && vim.status) {\n            h = h / 2;\n            top += h;\n        }\n        domLib.translate(element, left, top);\n        domLib.setStyle(element.style, \"width\", w + \"px\");\n        domLib.setStyle(element.style, \"height\", h + \"px\");\n    },\n    $getDirectionForHighlight: function (editor) {\n        var cm = editor.state.cm;\n        var vim = getVim(cm);\n        if (!vim.insertMode) {\n            return editor.session.selection.isBackwards() || editor.session.selection.isEmpty();\n        }\n    },\n    handleKeyboard: function (data, hashId, key, keyCode, e) {\n        var editor = data.editor;\n        var cm = editor.state.cm;\n        var vim = getVim(cm);\n        if (keyCode == -1)\n            return;\n        if (!vim.insertMode) {\n            if (hashId == -1) {\n                if (key.charCodeAt(0) > 0xFF) {\n                    if (data.inputKey) {\n                        key = data.inputKey;\n                        if (key && data.inputHash == 4)\n                            key = key.toUpperCase();\n                    }\n                }\n                data.inputChar = key;\n            }\n            else if (hashId == 4 || hashId == 0) {\n                if (data.inputKey == key && data.inputHash == hashId && data.inputChar) {\n                    key = data.inputChar;\n                    hashId = -1;\n                }\n                else {\n                    data.inputChar = null;\n                    data.inputKey = key;\n                    data.inputHash = hashId;\n                }\n            }\n            else {\n                data.inputChar = data.inputKey = null;\n            }\n        }\n        if (cm.state.overwrite && vim.insertMode && key == \"backspace\" && hashId == 0) {\n            return { command: \"gotoleft\" };\n        }\n        if (key == \"c\" && hashId == 1) { // key == \"ctrl-c\"\n            if (!useragent.isMac && editor.getCopyText()) {\n                editor.once(\"copy\", function () {\n                    if (vim.insertMode)\n                        editor.selection.clearSelection();\n                    else\n                        cm.operation(function () { exitVisualMode(cm); });\n                });\n                return { command: \"null\", passEvent: true };\n            }\n        }\n        if (key == \"esc\" && !vim.insertMode && !vim.visualMode && !cm.ace.inMultiSelectMode) {\n            var searchState = getSearchState(cm);\n            var overlay = searchState.getOverlay();\n            if (overlay)\n                cm.removeOverlay(overlay);\n        }\n        if (hashId == -1 || hashId & 1 || hashId === 0 && key.length > 1) {\n            var insertMode = vim.insertMode;\n            var name = lookupKey(hashId, key, e || {});\n            if (vim.status == null)\n                vim.status = \"\";\n            var isHandled = multiSelectHandleKey(cm, name, 'user');\n            vim = getVim(cm); // may be changed by multiSelectHandleKey\n            if (isHandled && vim.status != null)\n                vim.status += name;\n            else if (vim.status == null)\n                vim.status = \"\";\n            cm._signal(\"changeStatus\");\n            if (!isHandled && (hashId != -1 || insertMode))\n                return;\n            return { command: \"null\", passEvent: !isHandled };\n        }\n    },\n    attach: function (editor) {\n        if (!editor.state)\n            editor.state = {};\n        var cm = new CodeMirror(editor);\n        editor.state.cm = cm;\n        editor.$vimModeHandler = this;\n        CodeMirror.keyMap.vim.attach(cm);\n        getVim(cm).status = null;\n        cm.on('vim-command-done', function () {\n            if (cm.virtualSelectionMode())\n                return;\n            getVim(cm).status = null;\n            cm.ace._signal(\"changeStatus\");\n            cm.ace.session.markUndoGroup();\n        });\n        cm.on(\"changeStatus\", function () {\n            cm.ace.renderer.updateCursor();\n            cm.ace._signal(\"changeStatus\");\n        });\n        cm.on(\"vim-mode-change\", function () {\n            if (cm.virtualSelectionMode())\n                return;\n            updateInputMode();\n            cm._signal(\"changeStatus\");\n        });\n        function updateInputMode() {\n            var isIntsert = getVim(cm).insertMode;\n            cm.ace.renderer.setStyle(\"normal-mode\", !isIntsert);\n            editor.textInput.setCommandMode(!isIntsert);\n            editor.renderer.$keepTextAreaAtCursor = isIntsert;\n            editor.renderer.$blockCursor = !isIntsert;\n        }\n        updateInputMode();\n        editor.renderer.$cursorLayer.drawCursor = this.drawCursor.bind(cm);\n    },\n    detach: function (editor) {\n        var cm = editor.state.cm;\n        CodeMirror.keyMap.vim.detach(cm);\n        cm.destroy();\n        editor.state.cm = null;\n        editor.$vimModeHandler = null;\n        editor.renderer.$cursorLayer.drawCursor = null;\n        editor.renderer.setStyle(\"normal-mode\", false);\n        editor.textInput.setCommandMode(false);\n        editor.renderer.$keepTextAreaAtCursor = true;\n    },\n    getStatusText: function (editor) {\n        var cm = editor.state.cm;\n        var vim = getVim(cm);\n        if (vim.insertMode)\n            return \"INSERT\";\n        var status = \"\";\n        if (vim.visualMode) {\n            status += \"VISUAL\";\n            if (vim.visualLine)\n                status += \" LINE\";\n            if (vim.visualBlock)\n                status += \" BLOCK\";\n        }\n        if (vim.status)\n            status += (status ? \" \" : \"\") + vim.status;\n        return status;\n    }\n};\nvimApi.defineOption({\n    name: \"wrap\",\n    set: function (value, cm) {\n        if (cm) {\n            cm.ace.setOption(\"wrap\", value);\n        }\n    },\n    type: \"boolean\"\n}, false);\nvimApi.defineEx('write', 'w', function () {\n    console.log(':write is not implemented');\n});\ndefaultKeymap.push({ keys: 'zc', type: 'action', action: 'fold', actionArgs: { open: false } }, { keys: 'zC', type: 'action', action: 'fold', actionArgs: { open: false, all: true } }, { keys: 'zo', type: 'action', action: 'fold', actionArgs: { open: true } }, { keys: 'zO', type: 'action', action: 'fold', actionArgs: { open: true, all: true } }, { keys: 'za', type: 'action', action: 'fold', actionArgs: { toggle: true } }, { keys: 'zA', type: 'action', action: 'fold', actionArgs: { toggle: true, all: true } }, { keys: 'zf', type: 'action', action: 'fold', actionArgs: { open: true, all: true } }, { keys: 'zd', type: 'action', action: 'fold', actionArgs: { open: true, all: true } }, { keys: '<C-A-k>', type: 'action', action: 'aceCommand', actionArgs: { name: \"addCursorAbove\" } }, { keys: '<C-A-j>', type: 'action', action: 'aceCommand', actionArgs: { name: \"addCursorBelow\" } }, { keys: '<C-A-S-k>', type: 'action', action: 'aceCommand', actionArgs: { name: \"addCursorAboveSkipCurrent\" } }, { keys: '<C-A-S-j>', type: 'action', action: 'aceCommand', actionArgs: { name: \"addCursorBelowSkipCurrent\" } }, { keys: '<C-A-h>', type: 'action', action: 'aceCommand', actionArgs: { name: \"selectMoreBefore\" } }, { keys: '<C-A-l>', type: 'action', action: 'aceCommand', actionArgs: { name: \"selectMoreAfter\" } }, { keys: '<C-A-S-h>', type: 'action', action: 'aceCommand', actionArgs: { name: \"selectNextBefore\" } }, { keys: '<C-A-S-l>', type: 'action', action: 'aceCommand', actionArgs: { name: \"selectNextAfter\" } });\ndefaultKeymap.push({\n    keys: 'gq',\n    type: 'operator',\n    operator: 'hardWrap'\n});\nvimApi.defineOperator(\"hardWrap\", function (cm, operatorArgs, ranges, oldAnchor, newHead) {\n    var anchor = ranges[0].anchor.line;\n    var head = ranges[0].head.line;\n    if (operatorArgs.linewise)\n        head--;\n    hardWrap(cm.ace, { startRow: anchor, endRow: head });\n    return Pos(head, 0);\n});\ndefineOption('textwidth', undefined, 'number', ['tw'], function (width, cm) {\n    if (cm === undefined) {\n        return;\n    }\n    if (width === undefined) {\n        var value = cm.ace.getOption('printMarginColumn');\n        return value;\n    }\n    else {\n        var column = Math.round(width);\n        if (column > 1) {\n            cm.ace.setOption('printMarginColumn', column);\n        }\n    }\n});\nactions.aceCommand = function (cm, actionArgs, vim) {\n    cm.vimCmd = actionArgs;\n    if (cm.ace.inVirtualSelectionMode)\n        cm.ace.on(\"beforeEndOperation\", delayedExecAceCommand);\n    else\n        delayedExecAceCommand(null, cm.ace);\n};\nfunction delayedExecAceCommand(op, ace) {\n    ace.off(\"beforeEndOperation\", delayedExecAceCommand);\n    var cmd = ace.state.cm.vimCmd;\n    if (cmd) {\n        ace.execCommand(cmd.exec ? cmd : cmd.name, cmd.args);\n    }\n    ace.curOp = ace.prevOp;\n}\nactions.fold = function (cm, actionArgs, vim) {\n    cm.ace.execCommand(['toggleFoldWidget', 'toggleFoldWidget', 'foldOther', 'unfoldall'\n    ][(actionArgs.all ? 2 : 0) + (actionArgs.open ? 1 : 0)]);\n};\nexports.handler.defaultKeymap = defaultKeymap;\nexports.handler.actions = actions;\nexports.Vim = vimApi;\n\n});                (function() {\n                    ace.require([\"ace/keyboard/vim\"], function(m) {\n                        if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n                            module.exports = m;\n                        }\n                    });\n                })();\n            "],"mappings":"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"},"metadata":{},"sourceType":"script"}